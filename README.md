CEX

There are three algorithms included in the project, all based to some degree on the Rijndael encryption algorithm. 
The first algorithm is named RDX; that stands for Rijndael Extended. It is the Rijndael algorithm extended to accept the longer key length of 512 bits (64 bytes). Aside from this change in available key sizes, it is the exact same algorithm used in Rijndael and AES implementations.
The second algorithm, RSX (Rijndael/Serpent Extended), is based on RDX, but uses an adapted key scheduler from the Serpent encryption algorithm.
The third is DCS (Dual CTR Stream), which is two independent AES CTR implementations that create a pseudo-random stream by XORing the two CTRs, and encrypts by XORing that stream with plaintext, all implemented using processer parallelization.
I wrote RDX with a specific set of design criteria; I wanted something that was faster and more flexible than the most common C# implementations of Rijndael. Another goal was to add a 512 bit key, without altering the cryptographic primitives in any way. One of the first tests I performed was to create random key, iv, and 128 bytes of plaintext within a loop, and then perform an equivalency test against the output of RijndaelManaged on encrypt cycles, and compare the decryption output to the plaintext. I ran this test a million times on each key size without failure. Now obviously this took hours to run, so it is not included in the project, but would be fairly straightforward to reproduce. The next step was to apply standard tests. The NIST AESAVS known answer tests are used to certify an AES implementation, all of the plaintext and key tests, 960 in total, are performed in the sample application, as well as the FIPS 197, and some of the Nessie unverified vector tests. So, up to a 256 bit key, RDX will produce the same output as any other valid implementation of Rijndael. Now of course, there are no tests for a 512 bit key, as this has not been adopted, and as far as I know, this is the only open source implementation that can use a 512 bit key. So is a 512 bit key safe? Well, there are no certainties in encryption, and some clever fellow is sure to create an attack that targets the longer key length with some success. But the real question is, how much could the security be reduced? Remember that a single bit doubles the number of calculations required to brute force a key, so as long as it could not be reduced by the full 256 bits, plus whatever amount that attack could reduce a 256 bit key, it is still stronger than the 256 bit key. A 512 bit key also adds 8 more rounds to the diffusion algorithm, something that has been suggested before.
RSX is simply a response to Rijndaels weak key scheduler. The diffusion algorithm in Rijndael has an AddRoundKey step, which is just a simple Xor of the round key and the result of numerous transpositions. The forward cipher (encryption), has no direct bond to how those round keys are generated, that is, so long as the round keys are of the correct number, and sufficiently random and distant from each other, it does not matter how they are generated. Most of the keys generated by Rijndaels key scheduler use a very weak formula, it is simply the Xor of the previous key, and a key Nk positions previous. This isn't even a weak PRF, and a number of serious attacks have been created that exploit the weak key scheduler. Now because there is no direct correlation between how the diffusion algorithm processes the key, and how the expanded keys are generated, it is possible to replace the key scheduler. In fact, you could use a secure PRNG to generate the entire 60 or 92 member integer array and apply that as a key directly, (it's a sledgehammer approach, granted, but not so impractical given current wire speeds and media sizes). But I didn't want to go too far, but rather use a well understood key scheduler, adapt it for Rijndael, and mitigate some weak key based attacks. I looked at each of the key schedulers among the AES finalists, and finally decided on Serpent's, a very strong scheduler, that does a much more thorough job of dispersing the initial entropy. If I had to choose between RDX and RSX, given any key size, it would be RSX. If I had to choose between all three of these algorithms, it would be DCS..
The idea of combining two encryption algorithms, or even two unique instances of the same algorithm, has been around for some time now, it has been studied, there are accepted security proofs, and if implemented properly, it is generally regarded as a safe way to build a strong encryptor. DCS uses two Rijndael transforms, each with unique counters and keys to generate a psuedo random stream. It is fully parallelized, written to take advantage of any number of processor cores. Because it is written using an AES configuration, it could be ported to C or C++ and adapted to use the AES-NI api, the processor level instruction set for AES.
