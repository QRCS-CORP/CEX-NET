Introduction

What follows is the product of my study of several encryption algorithms. I decided to write this library, out of a desire to learn more about them, and encryption in general. I have in the past adapted classes from popular libraries like Mono and Bouncy Castle, but this time I wanted to write my own implementations, ones that were optimized for the C# language, and possibly faster, and more flexible than these popular C# versions. As I was writing the base classes, I also began thinking about various attack vectors, and how they might be mitigated, and also how the existing primitives might be improved upon from a security perspective.
It is important to note, that using the base ciphers with their original key sizes, output from those classes will be exactly the same as any other valid implementation of that cipher; RDX (Rijndael) with a 256 bit key is Rijndael, as TFX (Twofish) with a standard key size is Twofish, and SPX (Serpent) is a valid Serpent implementation. This is proven. The Tests section contains the most complete and authoritative test suites available for each of these ciphers. So if you choose to stick with standard key lengths, you can use configurations that have been thoroughly cryptanalyzed.
One has to consider that these ciphers were designed more than 17 years ago; at the time, Windows 95 was the predominant operating system, and computer hardware was quite primitive by today's standards. So, concessions had to be made in cipher design in regards to speed and memory footprint. We are not so constrained with the hardware of today, so adding rounds to a cipher, or using a larger key size is less a consideration now, and will have even less impact in the future.
Speed remains an important design criterion with this project. The CTR mode and the decryption function of the CBC and CFB modes have been parallelized. If a block size of ParallelBlockSize (64000 by default, but configurable) bytes is passed to the mode, and the hardware utilizes multiple processor cores, the processing is automatically parallelized. On my middle tier quad-core Acer, I have reached speeds of over 7 gigabytes per minute with this library using Rijndael, making this by far the fastest implementation of these ciphers in the C# language that I have found.
I definitely have some strong reservations about publishing this code, not the least of which is that it is likely to spawn a number of so called 'AES 512' copies by people who may not understand enough about the algorithms to evaluate, produce, or maintain a secure encryption software. It's kind of a quandary though, if I leave it on Github, no one will ever see it, if I publish it, chances are it could be used irresponsibly.. I would urge anyone considering using one of the extended algorithms to study the work, thoroughly evaluate the implementations, and make an informed choice.

As for my part, I wrote these implementations based on well-known versions, and made as few changes to the ciphers as possible to extend the key size. I have confidence in the library itself, because I took care to test it every step of the way, and feel I am developing a good understanding of the cryptographic primitives used in its construction. This should however, be considered as what it was intended to be; experiments..

I hope to expand this library in the future, as I continue my exploration of encryption technologies, and I welcome input from cryptographers and programmers. If you have a comment or concern, I'd be glad to hear from you. My goals include moving what I feel are the best and strongest implementations to a Java library.

Version 1.3 is what I consider the first 'real' release of the library. By this I mean that many of the project objectives have been completed; the library is very easy to use, a documentation framework has been built, parallelization has been implemented where possible, and many of the primitives I wanted in the library have been added. There is a version 1.4 coming; where I will introduce some post-quantum asymmetric ciphers.. but from this point on the release should be stable, and I don't forsee a lot of breaking changes with future releases.

Documentation has been added as an optional download with the project distribution, though the website link on the sample forms Help menu, or directly at: CEX Help.

Before downloading the source files, it is your responsibility to check if these extended key lengths (512 bit and higher) are legal in your country. If you use this code, please do so responsibly and in accordance to law in your region.

CEX is also available on GitHub as the CEX Project. The library API documentation can be accessed from the CEX Homepage, along with the latest releases of the library and example code.

For a full featured implementation of these algorithms, including key management, authentication controls, anti-tampering measures, encrypted assets, a very cool interface, and many more features; check out the version on my website: CEX on vtdev.com.

Library Components

The library contains the following components, as it evolves, some will be added, some removed, and when possible, changes will be made to improve upon performance, security and documentation.

Encryption Engines

Base Algorithms

The three base ciphers; Rijndael, Serpent, and Twofish have all underwent thorough testing to ensure that they align with valid implementations that use a smaller maximum key size. The same algorithms are used to transform data at any key size; only the key schedule itself has been extended, (a key schedule takes a small user key, and expands it into a larger working array, used in the rounds function to create a unique output). These changes to the key schedule, and a flexible rounds assignment, increase the potential security of the cipher, make it more difficult to cryptanalyze, and more resistant to brute force attacks.
•RDX: (Rijndael) This is an implementation of the Rijndael algorithm used in AES, extended to a 512 bit key.
•SPX:  (Serpent) An implementation of the Serpent encryption algorithm, extended to accept a 512 bit key.
•TFX: (Twofish) An implementation of the Twofish encryption algorithm, extended to accept a 512 bit key.

HX Ciphers: Hash based Key Schedules

The HX Series Ciphers use the identical encryption and decryption algorithms (transforms), of the standard ciphers, the difference is that the key schedule has been replaced by a Hash based Key Derivation Function (HKDF). The HKDF (default) is powered by an SHA512 HMAC, and is one of the most cryptographically strong methods available to generate pseudo-random output. The HKDF based key schedule takes a minimum 192 bytes (1536 bits) of input as a user key when using SHA512, and uses that keying material to generate a cryptographically strong working key array. As of version 1.3, the digest engine that powers HKDF is now definable through the HX and M ciphers constructors KeyEngine parameter; so any of the implemented digests can be used to power the key schedule: Blake, Keccak, SHA-2, or Skein.

There are several advantages to using a hash based KDF; the stronger working keys are less susceptible to attack vectors that leverage weak or related keys. The larger user key size, also makes brute force attacks practically impossible; 2(256-1) compared to a minimum of 2(1536-1) iterations. Another advantage of the HX ciphers is that the number of diffusion rounds, (transformation cycles within the rounds function), are configurable independent of the initial key size.
•RHX: Minimum (default digest engine) 1536 bit key, and up to 38 rounds of diffusion.
•SHX: Minimum (default digest engine) 1536 bit key, and up to 128 rounds of diffusion.
•THX: Minimum (default digest engine) 1536 bit key, and up to 32 rounds of diffusion.

Super Ciphers

These are merged ciphers; where two ciphers are combined during the rounds processing stage. There are a number of existing implementations that use this combined cipher technique, they either encrypt a file twice, each time using a different key and cipher, or use the combined output from counter encryptions to create a pseudo random key stream which is combined with the input to create the cipher-text. Both of these methods share the same weakness, called a ‘meet in the middle’ attack. This is where it may be theoretically possible to unwind both ciphers with little more than the computational effort required to break one alone. I got around this by ‘merging’ the ciphers within the transform function. For example, RSM combines the Rijndael and Serpent ciphers. In the rounds function, the input data undergoes a round of Rijndael, the product of that round is processed as a round of Serpent, then another round of Rijndael etc. So if set to 18 rounds, it processes the state with 18 rounds of Rijndael and 16 rounds of Serpent. This should effectively mitigate the meet in the middle attack, and make most forms of differential or linear analysis far more difficult.
•RSM: Rijndael and Serpent merged. HKDF key scheduler and up to 42 rounds of diffusion.
•TSM: Twofish and Serpent merged. HKDF key scheduler and up to 32 rounds of diffusion.
•Fusion: Rijndael and Twofish merged. HKDF key scheduler and up to 32 rounds of diffusion.
•DCS: Two separate Rijndael cipher instances combined and used as a random key stream.

Cipher Modes
•CBC: Cipher Block Chaining, decryption is optionally parallelized.
•CFB: Cipher Feed Back, decryption is optionally parallelized.
•CTR: Segmented Integer Counter, encryption and decryption is optionally parallelized.
•OFB: Output Feed Back mode.
•ECB: Electronic Code Book mode.

Deterministic Random Byte Generators
•CTRDRBG: An Encryption Counter based Deterministic Random Byte Generator.
•DGCDRBG: A Digest Counter based Deterministic Random Byte Generator.
•HKDF: A Hash based Key Derivation Function.

Message Authentication Code
•CMAC: A Cipher based Message Authentication Code: CMAC.
•HMAC: A Hash based Message Authentication Code.
•SHA256HMAC: HMAC and SHA256 wrapper class.
•SHA512HMAC: HMAC and SHA512 wrapper class.
•VMPCMAC: A Variably Modified Permutation Composition based Message Authentication Code.

Message Digests
•SHA256: An implementation of SHA-2 with a 256 bit hash output.
•SHA512: An implementation of SHA-2 with a 512 bit hash output.
•Keccak: Keccak based SHA-3, with variable output sizes.
•Blake256: The Blake digest with a 256 bit return size.
•Blake512: The Blake digest with a 512 bit return size.
•Skein256: The Skein digest with a 256 bit digest return size.
•Skein512: The Skein digest with a 512 bit digest return size.
•Skein1024: The Skein digest with a 1024 bit digest return size.

Helper Classes
•KeyFactory: A helper class used to create or extract a Key file.
•KeyGenerator: A helper class for generating cryptographically strong keying material.
•KeyHeader: A helper class that manages an encryption key header structure.
•KeyParams: A Cipher Key and Vector Container class.
•MessageHeader: A helper class that manages a message header structure.

Numeric
•BigInteger: Provides BigInteger operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and other miscellaneous operations.

Padding
•ISO7816: ISO 7816 Padding.
•PKCS7: PKCS7 Padding.
•TBC: Trailing Bit Compliment Padding.
•X923: X923 Padding.
•Zeroes: All Zeroes Padding.

Processing
•CipherStream: Cipher helper class; performs all operations necessary to encrypt a file.
•DigestStream: Digest helper class; wraps the creation of a hash digest from a Stream.
•MacStream: MAC helper class; wraps the creation of a Message Authentication Code from a Stream.

Pseudo Random Number Generators
•BBSG: The Blum-Blum-Shub random number generator.
•CCG: A Cubic Congruential Generator II random number generator.
•CSPRng: A Cryptographically Secure PRNG using RNGCryptoServiceProvider.
•MODEXPG: A Modular Exponentiation Generator random number generator.
•QCG1: A Quadratic Congruential Generator I random number generator.
•QCG2: A Quadratic Congruential Generator II random number generator.
•SecureRandom: An implementation of a Cryptographically Secure Psuedo Random Number Generator.

Queuing
•JitterQueue: Adds a small amount of random delay time to a queuing operation.
•WaitQueue: demonstrates using a queue to create a constant time implementation.

Security
•SecureDelete: a 5 stage secure file deletion class.

Utilities
•Compare: Compare arrays for equality.
•Compression: a fully implemented compression and folder archiving class.
•FileUtilities: a variety of file, folder, and drive functions.
