<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CEXEngine</name>
    </assembly>
    <members>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB">
            <summary>
            <h3>Implements a Cipher FeedBack Mode: CFB.</h3>
            <para>CFB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            
            <list type="bullet">
            <item><description>Parallel processing is enabled on decryption by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CFB(new RDX(), [BlockSizeBits], [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">
            <summary>
            Cipher Mode Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key and Vector</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes within an array
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode.Name">
            <summary>
            Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Int32,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="BlockSizeBits">Block size in bits; minimum is 8, or 1 byte. Maximum is Cipher block size in bits</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Cipher is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if an in valid block size  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParams containing key and vector</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Key or IV  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CFB.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024">
            <summary>
            <h3>Skein1024: An implementation of the Skein digest with a 1024 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            
            <list type="bullet">
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 128 bytes, (1024 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> to reinitialize.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein1024())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">
            <summary>
            Hash Digest Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance
            </summary>
            
            <param name="OutputSize">The output size of the hash in bits. Output size must be divisible by 8 and greater than zero</param>
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid output size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ComputeHash(System.Byte[])">
            <summary>
            <para>Get the Hash value. Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> 
            is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version"></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ConfigValue">
            <summary>
            The post-chain configuration value ToDo: change these and threefish cipher to int type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ConfigString">
            <summary>
            The pre-chain configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher">
            <summary>
            Block Cipher Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams">
            <summary>
            A Cipher Key and Vector Container class.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.#ctor(System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key
            </summary>
            
            <param name="Key">Cipher Key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key and IV.
            </summary>
            
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key, IV, and IKM.
            </summary>
            
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
            <param name="IKM">IKM value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.KeyParams.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.KeyParams.IKM">
            <summary>
            Input Key Material
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.KeyParams.Key">
            <summary>
            Cipher Key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.KeyParams.IV">
            <summary>
            Cipher Initialization Vector
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.Compression">
            <summary>
            <h3>Compression: File and Folder Archiving and Compression.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Compression.#ctor(VTDev.Libraries.CEXEngine.Utility.Compression.CompressionFormats)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Format">Compression engine</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Compression.CompressArchive(System.String,System.String)">
            <summary>
            Compress and archive a folder
            </summary>
            
            <param name="InputPath">Folder path</param>
            <param name="OutputFile">Full path to new archive file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Compression.DeCompressArchive(System.String,System.String)">
            <summary>
            Decompress an archive
            </summary>
            
            <param name="InputFile">Full path to new archive file</param>
            <param name="OutputPath">Destination directory for expanded files</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Compression.CompressFile(System.String,System.String)">
            <summary>
            Compress a file
            </summary>
            
            <param name="InputFile">File to compress</param>
            <param name="OutputFile">Full path to destination file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Compression.DeCompressFile(System.String,System.String)">
            <summary>
            Decompress a file
            </summary>
            
            <param name="InputFile">Compressed file</param>
            <param name="OutputPath">Directory path destination</param>
            
            <returns>Success</returns>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Utility.Compression.ProgressCounter">
            <summary>
            Progress counter event
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.Compression.CompressionFormats">
            <summary>
            Compression types
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.Compression.CompressionFormats.None">
            <summary>
            No compression
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.Compression.CompressionFormats.Deflate">
            <summary>
            Deflate algorithm
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.Compression.CompressionFormats.GZip">
            <summary>
            Gzip algorithm
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.Compression.ProgressCounterDelegate">
            <summary>
            Progress counter delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress changed arguments</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">
            <summary>
            Pseudo Random Number Generator Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.GetBytes(System.Byte[])">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.GetBytes(System.Int32)">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next">
            <summary>
            Get a cryptographically secure pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong">
            <summary>
            Get a cryptographically secure pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Padding.TBC">
            <summary>
            <h3>The Trailing Bit Compliment Padding Scheme.</h3>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Padding.IPadding">
            <summary>
            Padding Mode Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.IPadding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.IPadding.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.IPadding.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Padding.IPadding.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.TBC.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.TBC.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.TBC.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Padding.TBC.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG">
            <summary>
            <h3>An implementation of the Cubic Congruential Generator II random number generator: CCG</h3>
            <para>Implements CCG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.4</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new CCG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">CubicResiduePrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be initialized.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.GetBytes(System.Int32)">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next">
            <summary>
            Get a cryptographically secure pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong">
            <summary>
            Get a cryptographically secure pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC">
            <summary>
            <h3>An implementation of a Variably Modified Permutation Composition based Message Authentication Code: VMPC-MAC.</h3>
            <para>A VMPC-MAC as outlined in the VMPC-MAC Specification<cite>VMPC-MAC</cite></para>
            
            <list type="bullet">
            <item><description>No fixed block size is used.</description></item>
            <item><description>MAC return size is 20 bytes.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new VMPCMAC(new RDX()))
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>VMPC-MAC Specification: <see href="http://www.vmpcfunction.com/vmpc_mac.pdf">VMPC-MAC: A Stream Cipher Based Authenticated Encryption Scheme</see>.</description></item>
            <item><description>VMPC Paper: <see href="http://www.vmpcfunction.com/vmpcmac.htm>VMPC-MAC">VMPC-MAC Authenticated Encryption Scheme</see>.</description></item>
            <item><description>IETF: <see href="http://www.okna.wroc.pl/vmpc.pdf">VMPC One-Way Function and Stream Cipher</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac">
            <summary>
            Message Authentication Code (MAC) Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.ComputeMac(System.Byte[])">
            <summary>
            Get the Mac hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the MAC
            </summary>
            
            <param name="KeyParam">MAC key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Mac hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the MAC
            </summary>
            
            <param name="KeyParam">VMPCMAC Key and IV.
            <para>Uses the Key and IV fields of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class.
            Key and IV must be between 1 and 768 bytes in length.
            Key and IV should be equal in size.</para>
            </param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt, Key, or Nonce is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the IV is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.InitKey(System.Byte[],System.Byte[])">
            <remarks>
            Section 3.2, table 2 <see href="http://vmpcfunction.com/vmpc_mac.pdf">VMPC-MAC: 
            A Stream Cipher Based Authenticated Encryption Scheme</see>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes.
            <para>Not used in VMPCMAC: Block size is variable.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512">
            <summary>
            <h3>SHA512: An implementation of the SHA-2 digest with a 512 bit digest return size.</h3>
            <para>The SHA-2<cite>Fips 180-4</cite> 512 digest</para>
            
            <list type="bullet">
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA-2 <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.#ctor">
            <summary>
            Initialize the digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value [64 bytes]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value, Always 64 bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM">
            <summary>
            <h3>TSM: An implementation based on the Twofish and Serpent Merged block ciphers, extended with an HKDF powered Key Schedule.</h3>
            
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 24, and 32, default is 16.</description></item>
            </list>
            
            <para>TSM is Twofish<cite>Twofish</cite> and Serpent<cite>Serpent</cite> ciphers, merged within the rounds function. 
            The transform combines the two ciphers within the rounds function processing loop. 
            In the rounds functions, a round of Twofish is processed; the permuted product of that transformation is then transformed again by a round of Serpent.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and creates a cipher 
            that is very resistant to cryptanalysis.</para>
            
            <para>The key schedule in TSM powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            TSM is capable of processing up to 32 rounds, that is twice the number of rounds used in a standard implementation of Twofish. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds"/> static property.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new TSM()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/09/18" version="1.2.0.0" author="John Underhill">Initial release using a fixed Digest key schedule generator</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release using an assignable Digest in the HKDF engine</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">Fips 198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator">
            <summary>
            Random Generator Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Generate(System.Byte[])">
            <summary>
            Generate a block of cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG">
            <summary>
            <h3>CTRDRBG: An implementation of a Encryption Counter based Deterministic Random Byte Generator.</h3>
            <para>A Block Cipher Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90B</cite></para>
            
            <list type="bullet">
            <item><description>Can be initialized with any block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">cipher</see>.</description></item>
            <item><description>Parallelized by default on a multi processer system when an input byte array of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.ParallelMinimumSize"/> bytes or larger is used.</description></item>
            <item><description>Parallelization can be disabled using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.IsParallel"/> property.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Cipher engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Combination of [Salt, Ikm, Nonce] must be: cipher key size +  cipher block size in length.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new CTRDRBG(new RDX()))
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Creates a CTR Bytes Generator using a block cipher
            </summary>
            
            <param name="Cipher">The block cipher</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt, ikm, or nonce is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Generate(System.Byte[])">
            <summary>
            Generate a block of cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Two state Seed paramater: 
            If Seed size is equal to cipher key size plus counter size, both are updated. 
            If Seed size is equal to counter size (16 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.IsParallel">
            <summary>
            Get/Set Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.ProcessorCount">
            <summary>
            Processor count
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.Name">
            <summary>
            Get: Algorithm Name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDRBG.ParallelMinimumSize">
            <summary>
            Get: Minimum input size to trigger parallel processing
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom">
            <summary>
            <h3>An implementation of a Cryptographically Secure Psuedo Random Number Generator: SecureRandom.</h3> 
            
            <para>Uses the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class to generate non-negative random numbers.</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (SecureRandom rnd = new SecureRandom())
                x = rnd.NextInt32();
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextChar">
            <summary>
            Get a random char
            </summary>
            
            <returns>Random char</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.AnyDouble">
            <summary>
            Get a non-ranged random double
            </summary>
            
            <returns>Random double</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextDouble">
            <summary>
            Get a random double in the range 0.0 to 1.0
            </summary>
            
            <returns>Random double</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16(System.Int16)">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16(System.Int16,System.Int16)">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <param name="Minimum">Minimum value</param>
            
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <returns>Random UInt16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16(System.UInt16)">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16(System.UInt16,System.UInt16)">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <param name="Minimum">Minimum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Next">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32(System.Int32)">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32(System.Int32,System.Int32)">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <param name="Minimum">Minimum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32">
            <summary>
            Get a random unsigned 32bit integer
            </summary>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32(System.UInt32)">
            <summary>
            Get a random unsigned integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32(System.UInt32,System.UInt32)">
            <summary>
            Get a random unsigned integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <param name="Minimum">Minimum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64">
            <summary>
            Get a random long integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64(System.Int64)">
            <summary>
            Get a random long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64(System.Int64,System.Int64)">
            <summary>
            Get a random long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <param name="Minimum">Minimum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64(System.UInt64)">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64(System.UInt64,System.UInt64)">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <param name="Minimum">Minimum value</param>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBytes(System.Int32)">
            <summary>
            Gets bytes pseudo random from RNGCryptoServiceProvider
            </summary>
            
            <param name="Size">Size of request</param>
            
            <returns>P-Rand bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBytes(System.Byte[])">
            <summary>
            Gets bytes pseudo random from RNGCryptoServiceProvider
            </summary>
            
            <param name="Data">Array to fill with pseudo random</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetChars(System.Int32)">
            <summary>
            Gets pseudo random chars
            </summary>
            
            <param name="Size">Size of request</param>
            
            <returns>P-Rand chars</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetByteRange(System.Int64)">
            <remarks>
            returns the number of bytes needed to build 
            an integer existing within a byte range
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBits(System.Byte[],System.Int64)">
            <remarks>
            If you need a dice roll, use the Random class (smaller range = reduced entropy)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Name">
            <summary>
            Get: Algorithm Name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2">
            <summary>
            <h3>An implementation of a Quadratic Congruential Generator II random number generator : QCG-II.</h3>
            <para>Implements QCGII as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.3</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new QCG2())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">QuadraidResidue2Prng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations; must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.GetBytes(System.Byte[])">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.GetBytes(System.Int32)">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next">
            <summary>
            Get a cryptographically secure pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong">
            <summary>
            Get a cryptographically secure pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Reset">
            <summary>
            Resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG">
            <summary>
            <h3>An implementation of a Blum-Blum-Shub random number generator.</h3>
            <para>Implements BBSG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.8</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new BBSG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            <item><description>Cryptographic Secure Pseudo-Random Bits Generation: <cite>Blum-Blum-Shub</cite>The Blum-Blum-Shub Generator.</description></item>
            <item><description>Handbook of Applied Cryptography Chapter 5<cite>Handbook of Applied Cryptography</cite>: Pseudorandom Bits and Sequences.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">BBSPrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Initialize class with Primes, and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="X">Random Generator State (X = X ** 2 mod N)</param>
            <param name="P">P Random Prime</param>
            <param name="Q">Q Random Prime</param>
            <param name="N">Random Prime (N = P * Q)</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P or Q is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.GetBytes(System.Int32)">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next">
            <summary>
            Get a cryptographically secure pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong">
            <summary>
            Get a cryptographically secure pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC">
            <summary>
            <h3>An implementation of a Cipher based Message Authentication Code: CMAC.</h3>
            <para>A CMAC as outlined in the NIST document: SP800-38B<cite>SP800-38B</cite></para>
            
            <list type="bullet">
            <item><description>MAC return size must be a divisible of 8.</description></item>
            <item><description>MAC return size can be no longer than the Cipher Block size.</description></item>
            <item><description>Valid Cipher block sizes are 8 and 16 byte wide.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Int32,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Cipher engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new CMAC(new RDX(), [DisposeEngine]))
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-38B: <see href="http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf">The CMAC Mode for Authentication</see>.</description></item>
            <item><description>RFC 4493: <see href="http://tools.ietf.org/html/rfc4493">The AES-CMAC Algorithm</see>.</description></item>
            <item><description>RFC 4494: <see href="http://tools.ietf.org/html/rfc4494">The AES-CMAC-96 Algorithm and Its Use with IPsec</see>.</description></item>
            <item><description>RFC 4493: <see href="http://tools.ietf.org/html/rfc4615">The AES-CMAC-PRF-128 Algorithm for the Internet Key Exchange Protocol (IKE)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Int32,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            <param name="Cipher">Instance of the block cipher</param>
            <param name="MacBits">Expected MAC return size in Bits; must be less or equal to Cipher Block size in bits</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid MAC size is chosen</exception>
            <exception cref="T:System.ArgumentException">Thrown if an invalid block size is chosen</exception>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Mac hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the MAC
            </summary>
            
            <param name="KeyParam">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> containing Key and IV. 
            <para>Uses the Key and IV fields of the KeyParams parameter.
            Key size must be one of the <c>LegalKeySizes</c> of the underlying cipher.
            IV size must be the ciphers blocksize.
            </para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM">
            <summary>
            <h3>RSM: An implementation based on the Rijndael and Serpent Merged block ciphers, extended with an HKDF powered Key Schedule.</h3>
            
            <list type="bullet">
            <item><description>The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            <item><description>Valid Rounds assignments are 10, 18, 26, 34 and 42, default is 18.</description></item>
            </list>
            
            <para>RSM is the Rijndael<cite>Rijndael</cite> and Serpent<cite>Serpent</cite> ciphers, merged within the rounds function. 
            The transform combines the two ciphers within the rounds function processing loop. 
            In the Transform functions rounds loop, a round of Serpent is processed; the permuted product of that transformation is then transformed again by a full round of Rijndael.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and a cipher 
            that is very resistant to differential cryptanalysis.</para>
            
            <para>The key schedule in RSM powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
            HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RSM is capable of processing up to 42 rounds, that is three times the number of rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds"/> static property.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RSM()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/09/18" version="1.2.0.0" author="John Underhill">Initial release using a fixed Digest key schedule generator</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release using an assignable Digest in the HKDF engine</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds"/> property contains available sizes</param>
            <param name="Block">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalBlockSizes"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid block size or invalid rounds count are chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LinearTransform(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Apply the linear transformation to the register set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.InverseTransform(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Apply the inverse of the linear transformation to the register set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">
            <summary>
            Stream Cipher Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key ot iv is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input and output arrays do not align or are too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Length of data to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if input array is smaller then the ouput array</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha">
            <summary>
            <h3>ChaCha+: A ChaCha stream cipher implementation.</h3>
            
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 and 384 (16, 32 and 48 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            </list>
            
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new ChaCha())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/14" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>ChaCha20 <see href="http://cr.yp.to/chacha/chacha-20080128.pdf">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.AdvanceCounter">
            <summary>
            Increment the internal counter by 1
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.GetCounter">
            <summary>
            Get the current counter value
            </summary>
            
            <returns>Counter</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. 
            <para>Uses the Key and IV fields of the KeyParam parameter. 
            The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.LegalKeySizes"/> property contains valid sizes</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key or iv is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.ResetCounter">
            <summary>
            Reset the Counter
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.RetreatCounter">
            <summary>
            Set the counter back by 1
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.ReturnByte(System.Byte)">
            <summary>
            Return an transformed byte
            </summary>
            
            <param name="Input">Input byte</param>
            
            <returns>Transformed byte</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Skip(System.Int64)">
            <summary>
            Skip a portion of the stream
            </summary>
            
            <param name="Length">Number of bytes to skip</param>
            
            <returns>Bytes skipped</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Reset">
            <summary>
            Reset the algorithm
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.LegalRounds">
            <summary>
            Get: Available number of rounds
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.VectorSize">
            <summary>
            Get: Initialization vector size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB">
            <summary>
            <h3>Implements a Output FeedBack Mode: OFB.</h3>
            <para>OFB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            
            <list type="bullet">
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new OFB(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">The KeyParams containing key and vector</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Key or IV  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.OFB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1">
            <summary>
            <h3>An implementation of a Quadratic Congruential Generator I random number generator: QCG-I</h3>
            <para>Implements QCGI as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.2</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new QCG1())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">QuadraidResidue1Prng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.GetBytes(System.Byte[])">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.GetBytes(System.Int32)">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next">
            <summary>
            Get a cryptographically secure pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong">
            <summary>
            Get a cryptographically secure pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256">
            <summary>
            <h3>SHA256: An implementation of the SHA-2 digest with a 256 bit digest return size</h3>.
            <para>The SHA-2<cite>Fips 180-4</cite> 256 digest</para>
            
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA-2 <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.#ctor">
            <summary>
            Initialize the digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value [32 bytes]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value, Always 32 bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BEToUInt32(System.Byte[],System.Int32)">
            <remarks>
            Big Endian to UInt32
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.UInt32ToBE(System.UInt32,System.Byte[],System.Int32)">
            <remarks>
            UInt32 to Big Endian
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.K1C">
            <remarks>
            the first 32 bits of the fractional parts of the cube roots of the first sixty-four prime numbers)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream">
            <summary>
            <h3>Digest stream helper class.</h3>
            
            <list type="bullet">
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digests</see> using the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">interface</see>.</description></item>
            <item><description>Digest can be Disposed when this class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.Dispose">Disposed</see>, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Input Stream can be Disposed when this class is Disposed, set the DisposeStream parameter in the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.Initialize(System.IO.Stream,System.Boolean)"/> call to true to dispose automatically.</description></item>
            <item><description>Implementation has a Progress counter that returns total sum of bytes processed per either <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.ComputeHash(System.Int64,System.Int64)">ComputeHash([InOffset], [OutOffset])</see> calls.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example of hashing a Stream:</description>
            <code>
            using (IDigest digest = new SHA512())
            {
                using (DigestStream dstrm = new DigestStream(digest, [false]))
                {
                    // assign the input stream
                    dstrm.Initialize(InputStream, [true]);
                    // get the digest
                    (byte[]) hash = dstrm.ComputeHash([Length], [InOffset]);
                }
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest"/> instance</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.Initialize(System.IO.Stream,System.Boolean)">
            <summary>
            Initialize internal state
            </summary>
            
            <param name="InStream">The Source stream to be transformed</param>
            <param name="DisposeStream">Dispose of streams when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Input stream is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.ComputeHash">
            <summary>
            Process the entire length of the Input Stream
            </summary>
            
            <returns>The Message Digest</returns>
            
            <exception cref="T:System.InvalidOperationException">Thrown if ComputeHash is called before Initialize()</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.ComputeHash(System.Int64,System.Int64)">
            <summary>
            Process a length within the Input stream using an Offset
            </summary>
            
            <returns>The Message Digest</returns>
            
            <param name="Length">The number of bytes to process</param>
            <param name="Offset">The Input Stream positional offset</param>
            
            <exception cref="T:System.InvalidOperationException">Thrown if ComputeHash is called before Initialize()</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Process.DigestStream.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX">
            <summary>
            <h3>SPX: An extended implementation of the Serpent encryption cipher.</h3>
            
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256 and 512 bits (16, 24, 32 and 64 bytes).</description></item>
            <item><description>Block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 32, 40, 48, 56, and 64, default is 32.</description></item>
            </list>
            
            <para>SPX is an implementation of the Serpent<cite>Serpent</cite> block cipher. 
            The Key Schedule has been written so that it can both accept a larger key size of 512 bits, 
            and produce the required number of working keys with a variable number of diffusion rounds.</para>
            
            <para>The diffusion rounds, (the portion of the cipher that does the actual mixing of plaintext into ciphertext),
            is exactly the same with every key length, only it can now process an increased number of rounds, from 32; 
            the standard, up to 64 rounds. 
            This increase in the ciphers diffusion cycles makes linear and differential analysis more difficult, 
            and the larger key size ensures that it can not be brute forced.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new SPX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/14" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LinearTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.InverseTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the inverse of the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalKeySizes">
            <summary>
            Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion">
            <summary>
            <h3>Fusion: An implementation of the Twofish and Rijndael Merged ciphers, extended with an HKDF powered Key Schedule.</h3>
            
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>Fusion is a parallelized stream cipher; it encrypts a random 128 bit counter to create a key stream, used to transform the input data. 
            The pseudo random generator used to create the key stream is a combination of the Rijndael<cite>Rijndael</cite> and Twofish<cite>Twofish</cite> ciphers:
            In the Transform functions rounds loop, a round of Twofish is processed; the permuted product of that transformation is then transformed again by a full round of Rijndael.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and creates a cipher 
            that is very resistant to cryptanalysis.</para>
            
            <para>The key schedule in Fusion powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RHX is capable of processing up to thirty-two rounds, that is eighteen rounds more than the fourteen rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalRounds"/> static property.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new Fusion())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/09/18" version="1.2.0.0" author="John Underhill">Initial release using a fixed Digest key schedule generator</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release using an assignable Digest in the HKDF engine</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalRounds"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalKeySizes"/> property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key or iv is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offsets and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Generate(System.Int32,System.Byte[])">
            <remarks>
            Generate an array of pseudo random bytes
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Increment(System.Byte[])">
            <remarks>
            Incremental counter with carry
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Increase(System.Byte[],System.Int32)">
            <remarks>
            Increase a byte array by a numerical value
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.IsParallel">
            <summary>
            Get/Set: Enable processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">
            <summary>
            <h3>An implementation of a Hash based Message Authentication Code: HMAC<cite>Fips 198-1</cite>.</h3>
            <para>A HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>.</description></item>
            <item><description>Block size is the Digests engines block size.</description></item>
            <item><description>Digest size is the Digest engines digest return size.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new HMAC(new SHA256Digest(), [DisposeEngine]))
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">Message Digest instance</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Digest">Message Digest instance</param>
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the digest
            </summary>
            
            <param name="Input">Hash input data</param>
            <param name="InOffset">Starting position with the Input array</param>
            <param name="Length">Length of data to process</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>HMAC hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Completes processing and returns the HMAC code
            </summary>
            
            <param name="Output">Output array that receives the hash code</param>
            <param name="OutOffset">Offset within Output array</param>
            
            <returns>Hash size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class.
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DigestSize"/></para>
            </param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the IKM of the KeyParams parameter is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the IKM is less than digest size</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Reset">
            <summary>
            Reset and initialize the underlying digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Update(System.Byte)">
            <summary>
            Update the digest with 1 byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.Compare">
            <summary>
            <h3>Compare arrays for equality.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Compare.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Compare Byte Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Compare.AreEqual(System.Char[],System.Char[])">
            <summary>
            Compare Char Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Compare.AreEqual(System.Int32[],System.Int32[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20">
            <summary>
            <h3>Salsa20+: A Salsa20 stream cipher implementation.</h3>
            <para>Deprecated: removed by 1.4</para>
            
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 and 384 (16, 32 and 48 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            </list>
            
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new Salsa20())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/14" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.AdvanceCounter">
            <summary>
            Increment the internal counter by 1
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.GetCounter">
            <summary>
            Get the current counter value
            </summary>
            
            <returns>Counter</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. 
            <para>Uses the Key and IV fields of KeyParam. 
            The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes"/> property contains valid Key sizes. 
            IV must be 8 bytes in size.</para>
            </param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key or iv  is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ResetCounter">
            <summary>
            Reset the state counter
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.RetreatCounter">
            <summary>
            Set the counter back by 1
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ReturnByte(System.Byte)">
            <summary>
            Return a transformed byte
            </summary>
            
            <param name="Input">Input byte</param>
            
            <returns>Transformed byte</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Skip(System.Int64)">
            <summary>
            Skip a portion of the stream
            </summary>
            
            <param name="Length">Number of bytes to skip</param>
            
            <returns>Bytes skipped</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Reset">
            <summary>
            Reset the algorithm
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Key">
            <summary>
            Get: Cipher key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.VectorSize">
            <summary>
            Get: Initialization vector size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.KeccakDigestSizes">
            <summary>
            Available SHA3 digest return sizes
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.KeccakDigestSizes.D224">
            <summary>
            Digest size is 224 bits (28 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.KeccakDigestSizes.D256">
            <summary>
            Digest size is 256 bits (32 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.KeccakDigestSizes.D288">
            <summary>
            Digest size is 288 bits (36 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.KeccakDigestSizes.D384">
            <summary>
            Digest size is 384 bits (48 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.KeccakDigestSizes.D512">
            <summary>
            Digest size is 512 bits (64 bytes)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak">
            <summary>
            <h3>Keccak: An implementation of the SHA-3 Keccak digest.</h3>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            <list type="bullet">
            <item><description>Hash sizes are 28, 32, 48 and 64 bytes (224, 256, 384 and 512 bits).</description></item>
            <item><description>Block sizes are 144, 136, 104, and 72 bytes (1152, 1088, 832, 576 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA3Digest())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the Bouncy Castle <see href="http://grepcode.com/file/repo1.maven.org/maven2/org.bouncycastle/bcprov-ext-jdk15on/1.51/org/bouncycastle/crypto/digests/SHA3Digest.java">SHA3Digest</see> class, 
            sphlib 3.0 <see href="http://www.saphir2.com/sphlib/">keccak512.java</see>, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.#ctor(System.Int32)">
            <summary>
            Initialize the digest; a 512 bit digest size is selected by default
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.KeccakDigestSizes)">
            <summary>
            Initialize the digest
            </summary>
            <param name="DigestSize">Digest size enum in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS">
            <summary>
            <h3>DCS: A dual AES CTR parallelized stream cipher implementation.</h3>
            
            <list type="bullet">
            <item><description>Valid Key size is 768 bit (96 bytes).</description></item>
            <item><description>Minimum input size required for parallel processing is 1024 bytes.</description></item>
            </list>
            
            <para>DCS is a stream cipher that uses two Rijndael<cite>Rijndael</cite> streams in an AES<cite>Fips 197</cite> configuration; 
            that is a 256 bit key and 128 bit block size. 
            It creates two AES SIC (Segmented Integer Counter) streams using unique keys and 128 bit counters. 
            These two independent streams are combined using a logical exclusive OR operation (XOR) to produce a pseudo random key stream. 
            That key stream is XORd with the input data to produce the cipher text. 
            DCS uses a single 768 bit key to generate the random stream, making it impervious to brute force attacks. 
            It is also automatically parallelized, intended to run at high speed on multi processer systems.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new DCS())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/14" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>AES Proposal: <see href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael</see>.</description></item>
            <item><description>Fips 197: Announcing the <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Advanced Encryption Standard (AES)</see></description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="KeyParam">Cipher key container. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.LegalKeySizes"/> property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if key contains too many repeating sequences</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input and output arrays do not align or are too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if input array is smaller then the ouput array</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if input array is smaller then the ouput array</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Generate(System.Int32,System.Byte[],System.Byte[])">
            <remarks>
            Generate an array of p-random bytes
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Increment(System.Byte[])">
            <remarks>
            Incremental counter with carry
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Increase(System.Byte[],System.Int32)">
            <remarks>
            Increase a byte array by a numerical value
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.ExpandKey(System.Byte[])">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.ParallelBlockSize">
            <summary>
            Get: Parallel block size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.DCS.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Padding.ZeroPad">
            <summary>
            <h3>The Zero Padding Scheme (Not Recommended).</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.ZeroPad.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.ZeroPad.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.ZeroPad.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Padding.ZeroPad.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC">
            <summary>
            <h3>SHA256 Hash based Message Authentication Code Wrapper using SHA-2 256.</h3>
            <para>A SHA512 HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>; 32 bytes, (256 bits).</description></item>
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new SHA256HMAC(), [DisposeEngine])
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>NIST Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>NIST Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Boolean)">
            <summary>
            Initialize the class
            <para>When using this constructor, you must call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> before processing.</para>
            </summary>
            
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the hash buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">KeyParams containing HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class. 
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DigestSize"/></para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockSize">
            <summary>
            Get: The Ciphers internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.BlockSizes">
            <summary>
            <para>Block sizes in bits. Can be cast as Block byte size integers, 
            i.e. (int sz = BlockSizes.B512) is equal to 64.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockSizes.B128">
            <summary>
            128 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockSizes.B256">
            <summary>
            256 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockSizes.B512">
            <summary>
            512 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.BlockSizes.B1024">
            <summary>
            1024 bit block size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.CipherModes">
            <summary>
            Cipher Modes
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.CipherModes.CBC">
            <summary>
            Cipher Block Chaining Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.CipherModes.CFB">
            <summary>
            Cipher FeedBack Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.CipherModes.CTR">
            <summary>
            SIC Counter Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.CipherModes.ECB">
            <summary>
            Electronic CodeBook Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.CipherModes.OFB">
            <summary>
            Output FeedBack Mode
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digests">
            <summary>
            Message Digests
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Blake256">
            <summary>
            The Blake digest with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Blake512">
            <summary>
            The Blake digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Keccak">
            <summary>
            The SHA-3 digest based on Keccak with a variable return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.SHA256">
             <summary>
            The SHA-2 digest with a 256 bit return size
             </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.SHA512">
            <summary>
            The SHA-2 digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Skein256">
            <summary>
            The Skein digest with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Skein512">
            <summary>
            The Skein digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digests.Skein1024">
            <summary>
            The Skein digest with a 1024 bit return size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Engines">
            <summary>
            Encryption Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.ChaCha">
            <summary>
            An implementation of the ChaCha Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.Fusion">
            <summary>
            An implementation of the Twofish and Rijndael Merged Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.RDX">
            <summary>
            An extended implementation of the Rijndael Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.RHX">
            <summary>
            An implementation based on the Rijndael Block Cipher, using HKDF with a SHA512 HMAC for expanded key generation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.RSM">
            <summary>
            An implementation based on the Rijndael and Serpent Merged Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.RSX">
            <summary>
            (Deprecated, gone by 1.4) An extended implementation of the Rijndael Block Cipher, using a Serpent key schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.DCS">
            <summary>
            A Dual AES CTR parallelized Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.Salsa">
            <summary>
            (Deprecated, gone by 1.4) A Salsa20 Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.SPX">
            <summary>
            An extended implementation of the Serpent Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.SHX">
            <summary>
            The Serpent Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.TFX">
            <summary>
            An extended implementation of the Twofish Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.THX">
            <summary>
            A Twofish Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Engines.TSM">
            <summary>
            An implementation based on the Twofish and Serpent Merged Block Ciphers, using an HKDF Key Schedule
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generators">
            <summary>
            Random Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.CTRDRBG">
            <summary>
            An implementation of a Encryption Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.DGCDRBG">
            <summary>
            An implementation of a Digest Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Generators.HKDF">
            <summary>
            A Hash based Key Derivation Function HKDF
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.IVSizes">
            <summary>
            <para>IV Sizes in bits. Can be cast as IV byte size integers, 
            i.e. (int sz = IVSizes.V128) is equal to 16.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.IVSizes.V64">
            <summary>
            64 bit IV
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.IVSizes.V128">
            <summary>
            128 bit IV
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.IVSizes.V256">
            <summary>
            256 bit IV
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.KeySizes">
            <summary>
            <para>Key Sizes in bits. Can be cast as Key byte size integers, 
            i.e. (int sz = KeySizes.K256) is equal to 32.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K128">
            <summary>
            128 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K192">
            <summary>
            192 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K256">
            <summary>
            256 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K384">
            <summary>
            384 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K448">
            <summary>
            448 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K512">
            <summary>
            512 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K768">
            <summary>
            768 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K1024">
            <summary>
            1024 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K1536">
            <summary>
            1536 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K2560">
            <summary>
            2560 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K3584">
            <summary>
            3584 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.KeySizes.K4608">
            <summary>
            4608 bit Key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Macs">
            <summary>
            Message Authentication Code Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Macs.CMAC">
            <summary>
            A Cipher based Message Authentication Code wrapper (CMAC)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Macs.HMAC">
            <summary>
            A Hash based Message Authentication Code wrapper (HMAC)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Macs.SHA256HMAC">
            <summary>
            SHA256 Hash based Message Authentication Code
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Macs.SHA512HMAC">
            <summary>
            SHA512 Hash based Message Authentication Code
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Macs.VMPCMAC">
            <summary>
            A Variably Modified Permutation Composition based Message Authentication Code (VMPC-MAC)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">
            <summary>
            Pseudo Random Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.BBSG">
            <summary>
            A Blum-Blum-Shub random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.CCG">
            <summary>
            A Cubic Congruential Generator II (CCG) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.CSPRng">
            <summary>
             A Secure PRNG using RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.MODEXPG">
            <summary>
            A Modular Exponentiation Generator (MODEXPG) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.QCG1">
            <summary>
            A Quadratic Congruential Generator I (QCG-I) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Prngs.QCG2">
            <summary>
            A Quadratic Congruential Generator II (QCG-II) random number generator
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.PaddingModes">
            <summary>
            Padding Modes
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.PaddingModes.ISO7816">
            <summary>
            ISO7816 Padding Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.PaddingModes.PKCS7">
            <summary>
            PKCS7 Padding Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.PaddingModes.TBC">
            <summary>
            Trailing Bit Complement Padding Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.PaddingModes.X923">
            <summary>
            X923 Padding Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.PaddingModes.Zeros">
            <summary>
            Zero Padding Mode
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.RoundCounts">
            <summary>
            Rounds Count. Can be cast as round count integers, 
            i.e. (int ct = RoundCounts.R12) is equal to 12.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R8">
            <summary>
            8 Rounds: ChaCha
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R10">
            <summary>
            10 Rounds: ChaCha, RHX, RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R12">
            <summary>
            12 Rounds: ChaCha, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R14">
            <summary>
            14 Rounds: ChaCha, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R16">
            <summary>
            16 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R18">
            <summary>
            18 Rounds: ChaCha, Fusion, RSM, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R20">
            <summary>
            20 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R22">
            <summary>
            22 Rounds: ChaCha, Fusion, RHX, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R24">
            <summary>
            24 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R26">
            <summary>
            26 Rounds: ChaCha, Fusion, RSM, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R28">
            <summary>
            28 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R30">
            <summary>
            30 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R32">
            <summary>
            32 Rounds: Fusion, SHX, SPX, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R34">
            <summary>
            34 Rounds, RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R38">
            <summary>
            38 Rounds, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R40">
            <summary>
            40 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R42">
            <summary>
            42 Rounds: RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R48">
            <summary>
            48 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R56">
            <summary>
            56 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R64">
            <summary>
            64 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R80">
            <summary>
            80 Rounds: SHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R96">
            <summary>
            96 Rounds: SHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.RoundCounts.R128">
            <summary>
            128 Rounds: SHX
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Padding.ISO7816">
            <summary>
            <h3>The ISO7816 Padding Scheme.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.ISO7816.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.ISO7816.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.ISO7816.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Padding.ISO7816.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct">
            <summary>
            An encrypted file header structure. 
            <para>KeyID and Extension values must each be 16 bytes in length.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct.KeyID">
            <summary>
            The 16 byte key identifier
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct.Extension">
            <summary>
            The encrypted message file extension
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct.MessageMac">
            <summary>
            The HMAC hash value of the encrypted file
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            MessageHeaderStruct constructor
            </summary>
            
            <param name="KeyID">A unique 16 byte key ID</param>
            <param name="Extension">A 16 byte encrypted file extension</param>
            <param name="MessageHash">A message hash value, can be null</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct.Reset">
            <summary>
            Clear all struct members
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader">
            <summary>
            <h3>A helper class that manages a message header structure.</h3>
            
            <list type="bullet">
            <item><description>KeyID and Extension values must always be 16 bytes in length; if they are not specified they are auto-generated.</description></item>
            <item><description>GetHeaderSize returns size of base header; the size of the optional Message Authentication code is contained in the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/>.</description></item>
            <item><description>MessageMac is the MAC value of the encrypted message file.</description></item>
            <item><description>HMAC key is contained in the Key file.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.Create(System.IO.Stream,System.String,System.Byte[])">
            <summary>
            Create a serialized message header
            </summary>
            
            <param name="KeyStream">A Stream containing a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/></param>
            <param name="Extension">The file extension</param>
            <param name="Hash">The message files hash value, can be null</param>
            
            <returns>Serialized MessageHeaderStruct</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.DeSerializeHeader(System.IO.Stream,System.Int32)">
            <summary>
            Serialize a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct"/>
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            <param name="MacLength">Length in bytes of the Message Authentication Code; must align to MacLength property in <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/></param>
            
            <returns>A populated MessageHeaderStruct</returns>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid MessageStream is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.SerializeHeader(VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct)">
            <summary>
            Serialize a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeaderStruct"/>
            </summary>
            
            <param name="MessageHeader">An populated MessageHeaderStruct</param>
            
            <returns>A serialized MessageHeaderStruct MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.EncryptExtension(System.String,System.Byte[])">
            <summary>
            Encrypt the file extension
            </summary>
            
            <param name="Extension">The message file extension</param>
            <param name="Random">Random byte array used to encrypt the extension</param>
            
            <returns>Encrypted file extension</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.GetExtension(System.IO.Stream,System.Byte[])">
            <summary>
            Get decrypted file extension
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            <param name="Random">Random byte array used to encrypt the extension</param>
            
            <returns>File extension</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.GetKeyId(System.IO.Stream)">
            <summary>
            Get the messages unique key identifier
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            
            <returns>The unique 16 byte ID of the key used to encrypt this message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.GetMessageMac(System.IO.Stream,System.Int32)">
            <summary>
            Get the MAC value for this file
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            <param name="MacSize">Size of the Message Authentication Code</param>
            
            <returns>64 byte Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.HasHeader(System.IO.Stream)">
            <summary>
            Test for valid header in file
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.SetExtension(System.IO.Stream,System.Byte[])">
            <summary>
            Set the messages 16 byte Key ID value
            </summary>
            
            <param name="MessageStream">The message stream</param>
            <param name="Extension">The message file extension</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.SetKeyId(System.IO.Stream,System.Byte[])">
            <summary>
            Set the messages 16 byte Key ID value
            </summary>
            
            <param name="MessageStream">The message stream</param>
            <param name="KeyID">The unique 16 byte ID of the key used to encrypt this message</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.SetMessageMac(System.IO.Stream,System.Byte[])">
            <summary>
            Set the messages MAC value
            </summary>
            
            <param name="MessageStream">The message stream</param>
            <param name="Mac">The Message Authentication Code</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Helper.MessageHeader.GetHeaderSize">
            <summary>
            Get the size of a MessageHeaderStruct
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Padding.X923">
            <summary>
            <h3>The X.923 Padding Scheme.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.X923.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.X923.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.X923.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Padding.X923.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Queue.JitterQueue">
            <summary>
            <h3>JitterQueue: Adds a small amount of random delay time to a queuing operation.</h3>
            <para>Note v1.3: Not Tested</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.#ctor(System.Int32,System.Int16)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Size">Queue size, should be a multible of cipher block size, e.g. 16 block = 1440 queue</param>
            <param name="MaxTime">Maximum delay time in milliseconds. Range is 1 to 65535</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.DeQueue">
            <summary>
            Empty the queue
            </summary>
            
            <returns>Queued values</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Final(System.Byte[])">
            <summary>
            Process a partial queue size, then trigger wait
            </summary>
            
            <param name="Data">Queue input</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Initialize">
            <summary>
            Initialize the queue
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Queue(System.Byte[])">
            <summary>
            Add data to the queue
            </summary>
            
            <param name="Data">Queue input</param>
            
            <returns>Returns true if queue is full</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX">
            <summary>
            <h3>RSX: An extended implementation of the Rijndael encryption cipher, using a Serpent key expansion routine.</h3>
            <para>Deprecated: removed by 1.4</para>
            
            <list type="bullet">
            <item><description>Valid Key sizes are 256, and 512 bit.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RSX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/09/12" version="1.1.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.LegalBlockSizes"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid block size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.SerpentKey(System.Byte[])">
            <remarks>
            Expand key material into a session key.
            Uses an adjusted version of Serpents key scheduler with 
            an extended polynominal primitive, and rounds adjusted for Rijndael.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb1(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb2(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb3(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb4(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb5(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb6(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Sb7(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <remarks>
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Dispose(System.Boolean)">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Security.SecureDelete">
            <summary>
            <h3>Secure File Deletion class.</h3>
            </summary>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-88R1<cite>SP800-88R1</cite>: Table A-5 clear and purge on an ATA drive.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Security.SecureDelete.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Security.SecureDelete.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Security.SecureDelete.Delete(System.String)">
            <summary>
            Delete a file
            </summary>
            
            <param name="FilePath">Path to file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Security.SecureDelete.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Security.SecureDelete.FileSize">
            <summary>
            The file size in bytes
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Padding.PKCS7">
            <summary>
            <h3>The PKCS7 Padding Scheme.</h3>
            <para>PKCS7 as outlined in RFC 5652<cite>RFC 5652</cite></para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.PKCS7.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.PKCS7.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Padding.PKCS7.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Padding.PKCS7.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream">
            <summary>
            <h3>MAC stream helper class.</h3>
            
            <list type="bullet">
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Macs">Macs</see> using the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac">interface</see>.</description></item>
            <item><description>Mac must be fully initialized before passed to the constructor.</description></item>
            <item><description>Mac can be Disposed when this class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.Dispose">Disposed</see>, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Input Stream can be Disposed when this class is Disposed, set the DisposeStream parameter in the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.Initialize(System.IO.Stream,System.Boolean)"/> call to true to dispose automatically.</description></item>
            <item><description>Implementation has a Progress counter that returns total sum of bytes processed per either <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.ComputeMac(System.Int64,System.Int64)">ComputeMac([InOffset], [OutOffset])</see> calls.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example of hashing a Stream:</description>
            <code>
            using (IMac mac = new SHA512HMAC())
            {
                mac.Initialize(new KeyParams(Key));
                
                using (MacStream mstrm = new MacStream(mac, [false]))
                {
                    // assign the input stream
                    mstrm.Initialize(InputStream, [true]);
                    // get the digest
                    (byte[]) hash = mstrm.ComputeMac([Length], [InOffset]);
                }
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac,System.Boolean)">
            <summary>
            Initialize the class.
            <para>Mac must be fully initialized, including key, before calling this method.</para>
            </summary>
            
            <param name="Mac">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac"/> instance</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see> is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if an uninitialized Mac is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.Initialize(System.IO.Stream,System.Boolean)">
            <summary>
            Initialize internal state
            </summary>
            
            <param name="InStream">The Source stream to be transformed</param>
            <param name="DisposeStream">Dispose of streams when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Input stream is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.ComputeMac">
            <summary>
            Process the entire length of the Input Stream
            </summary>
            
            <returns>The Message Authentication Code</returns>
             
            <exception cref="T:System.InvalidOperationException">Thrown if ComputeMac is called before Initialize()</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.ComputeMac(System.Int64,System.Int64)">
            <summary>
            Process a length within the Input stream using an Offset
            </summary>
            
            <param name="Length">The number of bytes to process</param>
            <param name="Offset">The Input Stream positional offset</param>
            
            <returns>The Message Authentication Code</returns>
            
            <exception cref="T:System.InvalidOperationException">Thrown if ComputeHash is called before Initialize()</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Process.MacStream.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream">
            <summary>
            <h3>Cipher stream helper class.</h3>
            
            <list type="bullet">
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">Cipher Mode</see> wrapped <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">Block Ciphers</see>, or any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Ciphers</see>.</description></item>
            <item><description>Cipher Engine can be Disposed when this class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Dispose">Disposed</see>, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Streams can be Disposed when the class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Dispose">Disposed</see>, set the DisposeStream parameter in the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Initialize(System.IO.Stream,System.IO.Stream,System.Boolean)"/> call to true to dispose automatically.</description></item>
            <item><description>Implementation has a Progress counter that returns total sum of bytes processed per any of the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Write">Write()</see> calls.</description></item>
            <item><description>Changes to the Cipher or StreamCipher <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ParallelBlockSize">ParallelBlockSize</see> must be set after initialization.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example of encrypting a Stream:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RDX()))
            {
                // initialize the cipher
                cipher.Initialize(true, new KeyParams(Key, Iv));
                
                using (CipherStream cstrm = new CipherStream(cipher, [false]))
                {
                    // assign the input and output streams
                    cstrm.Initialize(InputStream, OutputStream, [true]);
                    // encrypt/decrypt write to the output stream
                    cstrm.Write([InOffset], [OutOffset]);
                }
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.#ctor(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the class with a KeyHeader Structure; containing the cipher description, and a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class containing the Key material.
            <para>This constructor creates and configures cryptographic instances based on the cipher description contained in a KeyHeaderStruct. 
            Cipher modes, padding, and engines are destroyed automatically through this classes Dispose() method.</para>
            </summary>
            
            <param name="Encryption">Cipher is an encryptor</param>
            <param name="Header">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/> containing the cipher description</param>
            <param name="KeyParam">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class containing the encryption Key material</param>
            
            <exception cref="T:System.ArgumentException">Thrown if an invalid <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct">KeyHeaderStruct</see> is used</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams">KeyParams</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode,VTDev.Libraries.CEXEngine.Crypto.Padding.IPadding,System.Boolean)">
            <summary>
            Initialize the class with a Block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">Cipher</see> and optional <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Padding.IPadding">Padding</see> instances.
            <para>This constructor requires a fully initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.CipherModes">CipherMode</see> instance.
            If the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.PaddingModes">PaddingMode</see> parameter is null, X9.23 padding will be used if required.</para>
            </summary>
            
            <param name="Cipher">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">Block Cipher</see> wrapped in a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">Cipher</see> mode</param>
            <param name="Padding">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Padding.IPadding">Padding</see> instance</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">Cipher</see> is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if an uninitialized Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher,System.Boolean)">
            <summary>
            Initialize the class with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> instance.
            <para>This constructor requires a fully initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">StreamCipher</see> instance.</para>
            </summary>
            
            <param name="Cipher">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> instance</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if an uninitialized Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Initialize(System.IO.Stream,System.IO.Stream,System.Boolean)">
            <summary>
            Initialize internal state
            </summary>
            
            <param name="InStream">The Source stream to be transformed</param>
            <param name="OutStream">The transformed Output stream</param>
            <param name="DisposeStream">Dispose of streams when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Input or Output stream is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Write">
            <summary>
            Process the entire length of the Input Stream (fastest)
            </summary>
            
            <exception cref="T:System.InvalidOperationException">Thrown if Write is called before Initialize()</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Write(System.Int64,System.Int64)">
            <summary>
            Process a length within the Input stream using Offsets
            </summary>
            
            <param name="InOffset">The Input Stream positional offset</param>
            <param name="OutOffset">The Output Stream positional offset</param>
            
            <exception cref="T:System.InvalidOperationException">Thrown if Write is called before Initialize()</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ParallelBlockProfile">
            <summary>
            Get/Set: Determines how the size of a parallel block is calculated; using the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.BlockProfiles">Block Profiles</see>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ProcessorCount">
            <summary>
            Get: The system processor count
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.BlockProfiles">
            <summary>
            ParallelBlockProfile enumeration
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.BlockProfiles.ProgressProfile">
            <summary>
            Set parallel block size as a division of 100 segments
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.BlockProfiles.SpeedProfile">
            <summary>
            Set parallel block size for maximum possible speed
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Process.CipherStream.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB">
            <summary>
            <h3>Implements an Electronic Cookbook Mode: ECB (Not Recommended).</h3>
            <para>ECB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            
            <list type="bullet">
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new ECB(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">KeyParam containing key and vector</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if Key is null</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes.
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters.
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.ECB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC">
            <summary>
            <h3>Implements a Cipher Block Chaining Mode: CBC.</h3>
            <para>CBC as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            
            <list type="bullet">
            <item><description>Parallel processing is enabled on decryption by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CBC(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParam containing key and vector</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. Parallel capable in Decryption mode. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. Parallel capable in Decryption mode. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng">
            <summary>
            <h3>An implementation of a Cryptographically Secure PRNG using the RNGCryptoServiceProvider class.</h3>
            <para>Implements a random number generator using the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new CSPRng())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4>:</description>
            <list type="number">
            <item><description>RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class documentation.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.GetBytes(System.Int32)">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next">
            <summary>
            Get a cryptographically secure pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong">
            <summary>
            Get a cryptographically secure pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512">
            <summary>
            <h3>Blake512: An implementation of the Blake digest with a 512 bit return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Blake<cite>Blake</cite> digest</para>
            
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Blake512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 Proposal <see href="https://131002.net/blake">Blake</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            <item><description>SHA3 Submission in C: <see href="https://131002.net/blake/blake_ref.c">blake_ref.c</see>.</description></item>
            <item><description>The: <see href="http://hashlib.codeplex.com/">HashLib</see> Project (test vectors).</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent project by Dominik Reichl: <see href="http://www.codeproject.com/Articles/286937/BlakeSharp-A-Csharp-Implementation-of-the-BLAKE-Ha">Blake Sharp</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX">
            <summary>
            <h3>TFX: An extended implementation of the Twofish encryption cipher.</h3>
            
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256 and 512 bits (16, 24, 32 and 64 bytes).</description></item>
            <item><description>Block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>TFX is an implementation of the Twofish<cite>Twofish</cite> block cipher. 
            TFX extends the original design allowing it to accept the longer key length (512 bits).</para>
            
            <para>The number of diffusion rounds processed in the ciphers transformation method has also been extended, and is user configurable; 
            from the original 16 rounds, to a full 32 rounds of transformation. 
            This increase in key size eliminates brute force attacks, and the increase in the number of diffusion rounds makes cryptanalysis far more difficult.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new TFX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/14" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">A 128-Bit Block Cipher</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX">
            <summary>
            <h3>RDX: An extended implementation of the Rijndael encryption cipher.</h3>
            
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256, and 512 bit.</description></item>
            <item><description>Valid block sizes are 16 and 32 bytes wide.</description></item>
            </list>
            
            <para>RDX is an implementation of the Rijndael<cite>Rijndael</cite> encryption algorithm, the same one used in the AES<cite>Fips 197</cite> standard. 
            What has been done is to extend Rijndael so that it now accepts the longer key length (512 bits). 
            The extended key length provides more security against attacks that attempt to brute force the key, and also adds eight more rounds of diffusion.</para>
            
            <para>The increased number of rounds brings the total from 14 rounds with a 256 bit key, to 22 rounds with the 512 bit key size. 
            These added passes through the rounds function further disperse the input through row and column transpositions, and XORs with a longer expanded key array.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RDX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/09/10" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release; updates to layout and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>AES Proposal: <see href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael</see>.</description></item>
            <item><description>Fips 197: Announcing the <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Advanced Encryption Standard (AES)</see></description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.#ctor(System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalBlockSizes"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid block size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.Hex">
            <summary>
            <h3>A Hexadecimal conversion helper class.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Hex.ToString(System.Byte[])">
            <summary>
            Convert an array into a hex string
            </summary>
            
            <param name="Data">Data to convert</param>
            
            <returns>Data as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Hex.Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode an array of bytes in hexadecimal format
            </summary>
            
            <param name="Data">The bytes to encode</param>
            <param name="Offset">The starting offset within the Data array</param>
            <param name="Length">The number of bytes to encode</param>
            
            <returns>Encode bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.Hex.Decode(System.String)">
            <summary>
            Decode a Hex encoded string and return the output
            </summary>
            
            <param name="Data">Hex string</param>
            
            <returns>Decoded bytes</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC">
            <summary>
            <h3>SHA512 Hash based Message Authentication Code Wrapper using SHA-2 512.</h3>
            <para>A SHA512 HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>; 64 bytes, (512 bits).</description></item>
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new SHA512HMAC(), [DisposeEngine])
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>NIST Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>NIST Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Boolean)">
            <summary>
            Initialize the class
            <para>When using this constructor, you must call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> before processing.</para>
            </summary>
            
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the HMAC
            </summary>
            
            <param name="KeyParam">KeyParams containing HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class.
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DigestSize"/></para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Queue.WaitQueue">
            <summary>
            <h3>WaitQueue: An implementation of a delayed Wait Queue.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.#ctor(System.Int32,System.Double)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Size">Queue size, should be a multible of cipher block size, e.g. 16 block = 1440 queue</param>
            <param name="CTime">Constant time value for each queue processed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.DeQueue">
            <summary>
            Empty the queue
            </summary>
            
            <returns>Queued values</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Final(System.Byte[])">
            <summary>
            Process a partial queue size, then trigger wait
            </summary>
            
            <param name="Data">Queue input</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Initialize">
            <summary>
            Initialize the queue
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Queue(System.Byte[])">
            <summary>
            Add data to the queue
            </summary>
            
            <param name="Data">Queue input</param>
            
            <returns>Returns true if queue is full</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Queue.WaitQueue.ProcessingTimes">
            <summary>
            Contains high and low processing times
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Queue.WaitQueue.ProcessingTimes.Low">
            <summary>
            Low order time
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Queue.WaitQueue.ProcessingTimes.High">
            <summary>
            Maximum time
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue">
            <summary>
            <h3>Test WaitQueue to calculate time threshhold measurements.</h3>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue.Samples">
            <summary>
            Timing samples, maximum and minimum times
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue.#ctor(System.Int32,System.Double)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Size">Size of queue</param>
            <param name="CTime">Not used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue.Initialize">
            <summary>
            Initialize the queue
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue.SQueue(System.Byte[])">
            <summary>
            Add data to the queue
            </summary>
            
            <param name="Data">Queue input</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG">
            <summary>
            <h3>An implementation of the Modular Exponentiation Generator random number generator: MODEXPG</h3>
            <para>Implements MODEXPG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.6</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new MODEXPG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">ModulusExponentPrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime</param>
            <param name="G">Random Generator State</param>
            <param name="Y">Random Generator Seed</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.GetBytes(System.Int32)">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next">
            <summary>
            Get a cryptographically secure pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong">
            <summary>
            Get a cryptographically secure pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG">
            <summary>
            <h3>DGTDRBG: An implementation of a Digest Counter based Deterministic Random Byte Generator.</h3>
            <para>A Digest Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90A</cite></para>
            
            <list type="bullet">
            <item><description>Can be initialized with any <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">digest</see>.</description></item>
            <item><description>Combination of [Salt, Ikm, Nonce] must be at least: digest block size + counter (8 bytes) size in length.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new DGTDRBG(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90A: <see href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">Appendix E1.</see></description></item>
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">Hash function</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Info value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Generate(System.Byte[])">
            <summary>
            Generate a block of cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Three state Seed paramater: 
            If Seed size is equal to digest blocksize plus counter size, both are updated. 
            If Seed size is equal to digest block size, internal state seed is updated.
            If Seed size is equal to counter size (8 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Seed does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.BlockUpdate(System.Byte[])">
            <remarks>
            Docs say class 'should be parallelizable'. 
            Only problem is, digest consumes most of the processing time,
            and setup for a parallel loop will likely cost more than time
            saved in small sized runs..
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDRBG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory">
            <summary>
            <h3>A helper class used to create or extract a Key file.</h3>
            
            <list type="bullet">
            <item><description>Constructors may use a fully qualified path to a key file, or the key file stream.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.KeyParams,VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)"/> method requires a populated KeyParams class.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)"/> and <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Prngs,VTDev.Libraries.CEXEngine.Crypto.Digests,VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)"/> methods auto-generate keying material.</description></item>
            <item><description>The Extract() method retrieves a populated cipher description (KeyHeaderStruct), and key material (KeyParams), from the key file.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)"/> overload:</description>
            <code>
            // create the key file
            new KeyFactory(KeyPath).Create(keyHeaderStruct);
            </code>
            
            <description>Example using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Extract(VTDev.Libraries.CEXEngine.Crypto.KeyParams@,VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct@)"/> method:</description>
            <code>
            // local vars
            keyparam KeyParams;
            KeyHeaderStruct header;
            
            new KeyFactory(KeyPath).Extract(out keyparam, out header);
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct">VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct Struct</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader">VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">VTDev.Libraries.CEXEngine.Crypto.Prngs Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator">VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams">VTDev.Libraries.CEXEngine.Crypto.KeyParams class</seealso>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.#ctor(System.String)">
            <summary>
            Initialize this class with a key file path
            </summary>
            
            <param name="KeyPath">The fully qualified path to the key file to be read or created</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.#ctor(System.IO.Stream)">
            <summary>
            Initialize this class with a key file stream
            </summary>
            
            <param name="KeyStream">The fully qualified path to the key file to be read or created</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Finalize">
            <summary>
            Finalizer: ensure resources are destroyed
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)">
            <summary>
            Create a key file using automatic key material generation.
            <para>The Key, and optional IV and IKM are generated automatically using the cipher description contained in the Header. 
            This overload creates keying material using the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator"/> default seed and digest engines: 
            <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng"/> and 
            <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512">SHA-2 512</see></para>
            </summary>
            
            <param name="Header">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct">Key Header</see> containing the cipher description</param>
            
            <exception cref="T:System.IO.FileLoadException">A key file exists at the path specified</exception>
            <exception cref="T:System.UnauthorizedAccessException">The key file path is read only</exception>
            <exception cref="T:System.ArgumentNullException">A KeyParams member is null, but specified in the Header</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A Header parameter does not match a KeyParams value</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.KeyParams,VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)">
            <summary>
            Create a key file using a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> containing the key material, and a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/> containing the cipher description.
            </summary>
            
            <param name="KeyParam">An initialized and populated key material container</param>
            <param name="Header">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct">Key Header</see> containing the cipher description</param>
            
            <exception cref="T:System.IO.FileLoadException">A key file exists at the path specified</exception>
            <exception cref="T:System.UnauthorizedAccessException">The key file path is read only</exception>
            <exception cref="T:System.ArgumentNullException">A KeyParams member is null, but specified in the Header</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A Header parameter does not match a KeyParams value</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Prngs,VTDev.Libraries.CEXEngine.Crypto.Digests,VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)">
            <summary>
            Create a key file using automatic key material generation.
            <para>The Key, and optional IV and IKM are generated automatically using the cipher description contained in the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/>.
            This overload creates keying material using the seed and digest engines specified with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator"/> class</para>
            </summary>
            
            <param name="SeedEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">Random Generator</see> used to create the stage I seed material during key generation.</param>
            <param name="HashEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest Engine</see> used in the stage II phase of key generation.</param>
            <param name="Header">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct">Key Header</see> containing the cipher description</param>
            
            <exception cref="T:System.IO.FileLoadException">A key file exists at the path specified</exception>
            <exception cref="T:System.UnauthorizedAccessException">The key file path is read only</exception>
            <exception cref="T:System.ArgumentNullException">A KeyParams member is null, but specified in the Header</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A Header parameter does not match a KeyParams value</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.KeyParams,VTDev.Libraries.CEXEngine.Crypto.Engines,System.Int32,VTDev.Libraries.CEXEngine.Crypto.IVSizes,VTDev.Libraries.CEXEngine.Crypto.CipherModes,VTDev.Libraries.CEXEngine.Crypto.PaddingModes,VTDev.Libraries.CEXEngine.Crypto.BlockSizes,VTDev.Libraries.CEXEngine.Crypto.RoundCounts,VTDev.Libraries.CEXEngine.Crypto.Digests,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Create a Key file using a manual description of the cipher parameters.
            </summary>
            
            <param name="KeyParam">An initialized and populated key material container</param>
            <param name="EngineType">The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">Engine</see> type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.IVSizes">Initialization Vector</see></param>
            <param name="CipherType">The type of <see cref="T:VTDev.Libraries.CEXEngine.Crypto.CipherModes">Cipher Mode</see></param>
            <param name="PaddingType">The type of cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.PaddingModes">Padding Mode</see></param>
            <param name="BlockSize">The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.BlockSizes">Block Size</see></param>
            <param name="Rounds">The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.RoundCounts">Rounds</see></param>
            <param name="KdfEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers</param>
            <param name="MacSize">The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key</param>
            <param name="MacEngine">The HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engine used to authenticate a message file encrypted with this key</param>
            
            <exception cref="T:System.IO.FileLoadException">A key file exists at the path specified</exception>
            <exception cref="T:System.UnauthorizedAccessException">The key file path is read only</exception>
            <exception cref="T:System.ArgumentNullException">A KeyParams member is null, but specified in the Header</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">A Header parameter does not match a KeyParams value</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Extract(VTDev.Libraries.CEXEngine.Crypto.KeyParams@,VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct@)">
            <summary>
            Extract a key file
            </summary>
            
            <param name="KeyParam">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> container that receives the key material from the file</param>
            <param name="Header">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/> that receives the cipher description</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512">
            <summary>
            <h3>Skein512: An implementation of the Skein digest with a 512 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> to reinitialize.</description></item>
            </list> 
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance
            </summary>
            
            <param name="OutputSize">The output size of the hash in bits. Output size must be divisible by 8 and greater than zero</param>
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid output size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ComputeHash(System.Byte[])">
            <summary>
            <para>Get the Hash value. Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> 
            is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version"></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ConfigValue">
            <summary>
            The post-chain configuration value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ConfigString">
            <summary>
            The configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct">
            <summary>
            Key header structure.
            <para>KeyID and ExtRandom values must each be 16 bytes in length.
            If they are not specified they will be populated automatically.</para>
            </summary>
            
            <example>
            <description>Example of populating a <c>KeyHeaderStruct</c> structure:</description>
            <code>
               KeyHeaderStruct khs = new KeyHeaderStruct(
                   Engines.RHX,        // cipher engine
                   192,                // key size in bytes
                   IVSizes.V128,       // cipher iv size enum
                   CipherModes.CTR,    // cipher mode enum
                   PaddingModes.X923,  // cipher padding mode enum
                   BlockSizes.B128,    // block size enum
                   RoundCounts.R18,    // diffusion rounds enum
                   Digests.Skein512,   // cipher kdf engine
                   64,                 // mac size
                   Digests.Keccak);    // mac digest
            </code>
            </example>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.EngineType">
            <summary>
            The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">Engine</see> type
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.KeySize">
            <summary>
            The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeySizes">Key Size</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.IvSize">
            <summary>
            Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.IVSizes">Initialization Vector</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.CipherType">
            <summary>
            The type of <see cref="T:VTDev.Libraries.CEXEngine.Crypto.CipherModes">Cipher Mode</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.PaddingType">
            <summary>
            The type of cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.PaddingModes">Padding Mode</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.BlockSize">
            <summary>
            The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.BlockSizes">Block Size</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.RoundCount">
            <summary>
            The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.RoundCounts">Rounds</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.KdfEngine">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.MacSize">
            <summary>
            The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.MacEngine">
            <summary>
            The HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engine used to authenticate a message file encrypted with this key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.KeyID">
            <summary>
            The unique 16 byte ID field used to identify this key. A null value auto generates this field.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.ExtensionKey">
            <summary>
            An array of random bytes used to encrypt a message file extension. A null value auto generates this field.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.#ctor(VTDev.Libraries.CEXEngine.Crypto.Engines,System.Int32,VTDev.Libraries.CEXEngine.Crypto.IVSizes,VTDev.Libraries.CEXEngine.Crypto.BlockSizes,VTDev.Libraries.CEXEngine.Crypto.RoundCounts,VTDev.Libraries.CEXEngine.Crypto.Digests,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests,System.Byte[],System.Byte[])">
            <summary>
            Key header constructor used with Stream Ciphers. 
            <para>Optional fields passing a null value will auto-generate their values.
            The KeyId and ExtensionKey fields require a 16 byte value if added manually.</para>
            </summary>
            
            <param name="EngineType">The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">Engine</see> type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.IVSizes">Initialization Vector</see></param>
            <param name="BlockSize">The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.BlockSizes">Block Size</see></param>
            <param name="RoundCount">The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.RoundCounts">Rounds</see></param>
            <param name="KdfEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers</param>
            <param name="MacEngine">The HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engine used to authenticate a message file encrypted with this key</param>
            <param name="MacSize">The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key</param>
            <param name="KeyId">The unique 16 byte ID field used to identify this key. A null value auto generates this field.</param>
            <param name="ExtensionKey">An array of random bytes used to encrypt a message file extension. A null value auto generates this field.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid KeyId, MessageKey, or ExtensionKey is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.#ctor(VTDev.Libraries.CEXEngine.Crypto.Engines,System.Int32,VTDev.Libraries.CEXEngine.Crypto.IVSizes,VTDev.Libraries.CEXEngine.Crypto.CipherModes,VTDev.Libraries.CEXEngine.Crypto.PaddingModes,VTDev.Libraries.CEXEngine.Crypto.BlockSizes,VTDev.Libraries.CEXEngine.Crypto.RoundCounts,VTDev.Libraries.CEXEngine.Crypto.Digests,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests,System.Byte[],System.Byte[])">
            <summary>
            Key header constructor. 
            <para>Optional fields passing a null value will auto-generate their values.
            The KeyId and ExtensionKey fields require a 16 byte value if added manually.</para>
            </summary>
            
            <param name="EngineType">The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">Engine</see> type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.IVSizes">Initialization Vector</see></param>
            <param name="CipherType">The type of <see cref="T:VTDev.Libraries.CEXEngine.Crypto.CipherModes">Cipher Mode</see></param>
            <param name="PaddingType">The type of cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.PaddingModes">Padding Mode</see></param>
            <param name="BlockSize">The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.BlockSizes">Block Size</see></param>
            <param name="RoundCount">The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.RoundCounts">Rounds</see></param>
            <param name="KdfEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers</param>
            <param name="MacEngine">The HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engine used to authenticate a message file encrypted with this key</param>
            <param name="MacSize">The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key</param>
            <param name="KeyId">The unique 16 byte ID field used to identify this key. A null value auto generates this field.</param>
            <param name="ExtensionKey">An array of random bytes used to encrypt a message file extension. A null value auto generates this field.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid KeyId, MessageKey, or ExtensionKey is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct.Reset">
            <summary>
            Clear all struct members
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader">
            <summary>
            <h3>A helper class that manages an encryption key header structure.</h3>
            
            <list type="bullet">
            <item><description>Keys are contracted MAC enabled by default; set the MacSize member of the KeyHeaderStruct to 0, to disable message authentication.</description></item>
            <item><description>The key description and a KeyParams structure containing key material can easily be obtained using the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyFactory"/> class Extract() method</description></item>
            <item><description>The KeyID member is a unique Guid that identifies this key in a message file.</description></item>
            <item><description>The ExtRandom member is an array of random bytes used to encrypt the messages file extension.</description></item>
            <item><description>KeyID and ExtRandom values must always be 16 bytes in length if specified manually.</description></item>
            <item><description>KeySize, IvSize, and MacSize determine size values and corresponding offsets of additional Keying material.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.DeSerializeHeader(System.IO.Stream)">
            <summary>
            Deserialize a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/>
            </summary>
            
            <param name="KeyStream">Stream containing a serialized KeyHeaderStruct</param>
            
            <returns>A populated KeyHeaderStruct</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SerializeHeader(VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)">
            <summary>
            Serialize a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct"/>
            </summary>
            
            <param name="KeyHeader">A KeyHeaderStruct</param>
            
            <returns>A stream containing the KeyHeaderStruct data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetBlockSize(System.IO.Stream)">
            <summary>
            Get the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.BlockSizes">Block Size</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Cipher Block Size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetCipherType(System.IO.Stream)">
            <summary>
            Get the cipher processing <see cref="T:VTDev.Libraries.CEXEngine.Crypto.CipherModes">Mode type</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Cipher processing Mode</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetEngineType(System.IO.Stream)">
            <summary>
            Get the cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">Engine type</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Cipher Engine type</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetExtensionKey(System.IO.Stream)">
            <summary>
            Get the random field used to encrypt a file extension
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Random array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetKeyId(System.IO.Stream)">
            <summary>
            Get the Cipher keys Unique ID
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Key ID</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetKeySize(System.IO.Stream)">
            <summary>
            Get the cipher Key Size in bytes
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Cipher Key size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetKdfEngine(System.IO.Stream)">
            <summary>
            Get the cipher Key Derivation Function <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Engine</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Cipher KDF Engine</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetIvSize(System.IO.Stream)">
            <summary>
            Get the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.IVSizes">IV Size</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Cipher IV Size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetMacEngine(System.IO.Stream)">
            <summary>
            Get the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">HMAC engine</see> used to generate the message authentication code
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Digest engine</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetMacSize(System.IO.Stream)">
            <summary>
            Get the size of the message authentication code in bytes
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>HMAC hash value size in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetPaddingType(System.IO.Stream)">
            <summary>
            Get the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.PaddingModes">Padding Mode type</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Cipher Padding Mode</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetRoundCount(System.IO.Stream)">
            <summary>
            Get the Cipher diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.RoundCounts">Rounds Count</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Cipher Rounds Count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.IsValid(System.IO.Stream)">
            <summary>
            Get this is a valid header file
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.IsValid(VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeaderStruct)">
            <summary>
            Get this is a valid header file
            </summary>
            
            <param name="Header">The stream containing a key header</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetBlockSize(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.BlockSizes)">
            <summary>
            Set the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.BlockSizes">Block Size</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="BlockSize">The cipher block size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetCipherType(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.CipherModes)">
            <summary>
            Set the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.CipherModes">Processing Mode</see> type
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="CipherType">Cipher mode</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetEngineType(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Engines)">
            <summary>
            Set the Cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">Engine</see> type
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="EngineType">Engine type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetKdfEngine(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Set the Cipher Key Derivation <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Engine</see> type
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="EngineType">KDF Engine type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetKeyId(System.IO.Stream,System.Guid)">
            <summary>
            Set the unique 16 byte Key ID
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="KeyId">Guid Key id</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetKeySize(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.KeySizes)">
            <summary>
            Set the cipher Key Size in bytes
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="KeySize">Key size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetIvSize(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.IVSizes)">
            <summary>
            Set the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.IVSizes">IV Size</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="IvSize">IV size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetMacEngine(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Set the HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest engine</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="Digest">Digest engine type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetMacSize(System.IO.Stream,System.Int32)">
            <summary>
            Set the HMAC message code size
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="Size">Size of the MAC engine digest</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetPaddingType(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.PaddingModes)">
            <summary>
            Set the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.PaddingModes">Padding Mode</see> type
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="PaddingType">Padding mode</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.SetRoundCount(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.RoundCounts)">
            <summary>
            Set the cipher diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.RoundCounts">Rounds Count</see>
            </summary>
            
            <param name="KeyStream">The stream containing a key header</param>
            <param name="RoundCount">Rounds count</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyHeader.GetHeaderSize">
            <summary>
            Get the size of the KeyHeaderStruct
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX">
            <summary>
            <h3>THX: A Twofish Cipher extended with an HKDF powered Key Schedule.</h3>
            
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>THX is an implementation of the Twofish<cite>Twofish</cite> block cipher combined with an HKDF powered Key Schedule. 
            The number of transformation rounds processed is also user definable; from the standard 16 rounds, to a full 32 rounds of transformation.</para>
            
            <para>The key schedule in THX powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even the Twofish key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            THX is capable of processing up to 32 rounds, that is twice the number of rounds used in a standard implementation of Twofish. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds"/> static property.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new THX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release using a fixed Digest key schedule generator</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release using an assignable Digest in the HKDF engine</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">Fips 198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR">
            <summary>
            <h3>Implements a Parallel Segmented Counter Mode: CTR.</h3>
            <para>CTR as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            
            <list type="bullet">
            <item><description>Parallel processing is enabled by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Engines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">The KeyParams containing key and vector</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Key or IV  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. Parallel capable function if Output array length is at least equal to <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelMinimumSize"/>. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters.  Parallel capable function if Output array length is at least equal to <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelMinimumSize"/>. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mode.CTR.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger">
            <summary>
            BigInteger: Provides BigInteger operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and other miscellaneous operations
            </summary>
            
            <example>
            <description>Creating a random prime example:</description>
            <code>
            BigInteger P = BigInteger.ProbablePrime(BitLength, new SecureRandom());
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Zero">
            <summary>
            The BigInteger constant zero
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.One">
            <summary>
            The BigInteger constant one
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Two">
            <summary>
            The BigInteger constant two
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Three">
            <summary>
            The BigInteger constant three
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Four">
            <summary>
            The BigInteger constant four
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Ten">
            <summary>
            The BigInteger constant ten
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger._primeLists">
            <remarks>
            Each list has a product 2^31
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#cctor">
            <remarks>
            Static constructor
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#ctor(System.Byte[])">
            <summary>
            <para>Translates a byte array containing the two's-complement binary representation of a BigInteger into a BigInteger. 
            The input array is assumed to be in big-endian byte-order: the most significant byte is in the zeroth element.</para>
            </summary>
            <param name="Value">big-endian two's-complement binary representation of BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>Translates a byte array containing the two's-complement binary representation of a BigInteger into a BigInteger. 
            The input array is assumed to be in big-endian byte-order: the most significant byte is in the zeroth element.</para>
            </summary>
            <param name="Value">big-endian two's-complement binary representation of BigInteger</param>
            <param name="Offset">Byte offset within Value</param>
            <param name="Length">Byte length of Value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#ctor(System.String)">
            <summary>
            <para>Translates the decimal String representation of a BigInteger into a BigInteger. 
            The String representation consists of an optional minus sign followed by a sequence of one or more decimal digits. 
            The character-to-digit mapping is provided by Character.digit. 
            The String may not contain any extraneous characters (whitespace, for example).</para>
            </summary>
            <param name="Value">Decimal String representation of BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#ctor(System.String,System.Int32)">
            <summary>
            <para>Translates the String representation of a BigInteger in the specified radix into a BigInteger. 
            The String representation consists of an optional minus or plus sign followed by a sequence of one or more digits in the specified radix. 
            The character-to-digit mapping is provided by Character.digit. The String may not contain any extraneous characters (whitespace, for example).</para>
            </summary>
            <param name="Value">String representation of BigInteger</param>
            <param name="Radix">Radix to be used in interpreting Value</param>
            
            <exception cref="T:System.FormatException">Thrown if a Zero length BigInteger  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            <para>Constructs a randomly generated BigInteger, uniformly distributed over the range 0 to (2numBits - 1), inclusive. 
            The uniformity of the distribution assumes that a fair source of SecureRandom bits is provided in rnd. 
            Note that this constructor always constructs a non-negative BigInteger.</para>
            </summary>
            <param name="BitLength">Maximum bitLength of the new BigInteger</param>
            <param name="Rnd">Source of randomness to be used in computing the new BigInteger</param>
            
            <exception cref="T:System.ArgumentException">Thrown if a negative BitLength  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            <para>Constructs a randomly generated positive BigInteger that is probably prime, with the specified bitLength. 
            It is recommended that the ProbablePrime method be used in preference to this constructor unless there is a compelling need to specify a certainty.</para>
            </summary>
            <param name="BitLength">BitLength of the returned BigInteger</param>
            <param name="Certainty"><para>A measure of the uncertainty that the caller is willing to tolerate. 
            The probability that the new BigInteger represents a prime number will exceed (1 - 1/2certainty). 
            The execution time of this constructor is proportional to the value of this parameter.</para></param>
            <param name="Rnd">Source of SecureRandom bits used to select candidates to be tested for primality</param>
            
            <exception cref="T:System.ArithmeticException">Thrown if a BitLength of less than 2  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#ctor(System.Int32,System.Byte[])">
            <summary>
            <para>Translates the sign-magnitude representation of a BigInteger into a BigInteger. 
            The sign is represented as an integer signum value: -1 for negative, 0 for zero, or 1 for positive. 
            The magnitude is a byte array in big-endian byte-order: the most significant byte is in the zeroth element. 
            A zero-length magnitude array is permissible, and will result in a BigInteger value of 0, whether signum is -1, 0 or 1.</para>
            </summary>
            <param name="Signum">Signum of the number (-1 for negative, 0 for zero, 1 for positive)</param>
            <param name="Magnitude">Big-endian binary representation of the magnitude of the number</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.#ctor(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            <para>Translates the sign-magnitude representation of a BigInteger into a BigInteger. 
            The sign is represented as an integer signum value: -1 for negative, 0 for zero, or 1 for positive. 
            The magnitude is a byte array in big-endian byte-order: the most significant byte is in the zeroth element. 
            A zero-length magnitude array is permissible, and will result in a BigInteger value of 0, whether signum is -1, 0 or 1.</para>
            </summary>
            <param name="Signum">Signum of the number (-1 for negative, 0 for zero, 1 for positive)</param>
            <param name="Magnitude">Big-endian binary representation of the magnitude of the number</param>
            <param name="Offset">Byte offset within Magnitude</param>
            <param name="Length">Byte length of Magnitude</param>
            
            <exception cref="T:System.FormatException">Thrown if an invalid Signum  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Abs">
            <summary>
            Returns a BigInteger whose value is the absolute value of this BigInteger
            </summary>
            <returns>Abs(this)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Add(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this + val)
            </summary>
            <param name="Value">Value to be added to this BigInteger</param>
            <returns>this + Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.And(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this &amp; Value). (This method returns a negative BigInteger if and only if this and val are both negative.)
            </summary>
            <param name="Value">Value to be AND'ed with this BigInteger</param>
            <returns>this &amp; Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.AndNot(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            <para>Returns a BigInteger whose value is (this &amp; ~val). 
            This method, which is equivalent to and(val.not()), is provided as a convenience for masking operations. 
            (This method returns a negative BigInteger if and only if this is negative and val is positive.)</para>
            </summary>
            <param name="Value">Value to be complemented and AND'ed with this BigInteger</param>
            <returns>this &amp; ~Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ClearBit(System.Int32)">
            <summary>
            Returns a BigInteger whose value is equivalent to this BigInteger with the designated bit cleared. (Computes (this &amp; ~(1 &lt; &lt; n)).)
            </summary>
            <param name="N">Index of bit to clear</param>
            <returns>this &amp; ~(1 &lt; &lt; N)</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Bit address (N) is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.CompareTo(System.Object)">
            <summary>
            Compares this BigInteger with the specified Object for equality
            </summary>
            <param name="Obj">Object to which this BigInteger is to be compared</param>
            <returns>True if and only if the specified Object is a BigInteger whose value is numerically equal to this BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.CompareTo(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            <para>Compares this BigInteger with the specified BigInteger. 
            This method is provided in preference to individual methods for each of the six boolean comparison operators (&#60;, ==, &#62;, &#62;=, !=, &#60;=). 
            The suggested idiom for performing these comparisons is: (x.compareTo(y) 'operator' 0), where operator is one of the six comparison operators.</para>
            </summary>
            <param name="Value">BigInteger to which this BigInteger is to be compared</param>
            <returns>-1, 0 or 1 as this BigInteger is numerically less than, equal to, or greater than Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Divide(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this / Value)
            </summary>
            <param name="Value">Value by which this BigInteger is to be divided</param>
            <returns>this / Value</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Signum = zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.DivideAndRemainder(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns an array of two BigIntegers containing (this / Value) followed by (this % Value)
            </summary>
            <param name="Value">Value by which this BigInteger is to be divided, and the remainder computed</param>
            <returns>An array of two BigIntegers: the quotient (this / Value) is the initial element, and the remainder (this % Value) is the final element</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Signum = zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.FlipBit(System.Int32)">
            <summary>
            Returns a BigInteger whose value is equivalent to this BigInteger with the designated bit flipped. (Computes (this ^ (1&lt;&lt; N)).)
            </summary>
            <param name="N">Index of bit to flip</param>
            <returns>this ^ (1&lt;&lt; N)</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if bit address (N) is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Equals(System.Object)">
            <summary>
            Compares this BigInteger with the specified Object for equality
            </summary>
            <param name="Obj">Object to which this BigInteger is to be compared</param>
            <returns>true if and only if the specified Object is a BigInteger whose value is numerically equal to this BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Gcd(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is the greatest common divisor of abs(this) and abs(val). Returns 0 if this==0 &#38; val==0
            </summary>
            <param name="Value">Value with which the GCD is to be computed</param>
            <returns>GCD(Abs(this), Abs(Value))</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.GetHashCode">
            <summary>
            Returns the hash code for this BigInteger
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.GetLowestSetBit">
            <summary>
            <para>Returns the index of the rightmost (lowest-order) one bit in this BigInteger (the number of zero bits to the right of the rightmost one bit). 
            Returns -1 if this BigInteger contains no one bits. (Computes (this==0? -1 : log2(this &#38; -this)).)</para>
            </summary>
            <returns>Index of the rightmost one bit in this BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.IsProbablePrime(System.Int32)">
            <summary>
            Returns true if this BigInteger is probably prime, false if it's definitely composite. If certainty is  0, true is returned
            </summary>
            <param name="Certainty"><para>A measure of the uncertainty that the caller is willing to tolerate: 
            if the call returns true the probability that this BigInteger is prime exceeds (1 - 1/2certainty). 
            The execution time of this method is proportional to the value of this parameter.</para></param>
            <returns>true if this BigInteger is probably prime, false if it's definitely composite</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Max(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns the maximum of this BigInteger and Value
            </summary>
            <param name="Value">Value with which the maximum is to be computed</param>
            <returns>The BigInteger whose value is the greater of this and Value. If they are equal, either may be returned</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Min(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns the minimum of this BigInteger and val
            </summary>
            <param name="Value">Value with which the minimum is to be computed</param>
            <returns>The BigInteger whose value is the lesser of this BigInteger and Value. If they are equal, either may be returned</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Mod(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this mod m). This method differs from remainder in that it always returns a non-negative BigInteger
            </summary>
            <param name="M">The modulus</param>
            <returns>this mod M</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Modulus (M) is less than 1</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ModInverse(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this-1 mod m)
            </summary>
            <param name="M">The modulus</param>
            <returns>this-1 mod M</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Modulus (M) is less than 1</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ModPow(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this exponent mod m). (Unlike pow, this method permits negative exponents.)
            </summary>
            <param name="Exponent">The exponent</param>
            <param name="M">The modulus</param>
            <returns>this exponent mod M</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Modulus (M) is less than 1</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Multiply(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this * Value)
            </summary>
            <param name="Value">Value to be multiplied by this BigInteger</param>
            <returns>this * Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Negate">
            <summary>
            Returns a BigInteger whose value is (-this)
            </summary>
            <returns>~this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.NextProbablePrime">
            <summary>
            <para>Returns the first integer greater than this BigInteger that is probably prime. 
            The probability that the number returned by this method is composite does not exceed 2-100. 
            This method will never skip over a prime when searching: if it returns p, there is no prime q such that this &lt; q &lt; p.</para>
            </summary>
            <returns>The first integer greater than this BigInteger that is probably prime</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Signum is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Not">
            <summary>
            Returns a BigInteger whose value is (~this). (This method returns a negative value if and only if this BigInteger is non-negative.)
            </summary>
            <returns>~this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Or(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this | val). (This method returns a negative BigInteger if and only if either this or val is negative.)
            </summary>
            <param name="Value">Value to be OR'ed with this BigInteger</param>
            <returns>this | Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Pow(System.Int32)">
            <summary>
            Returns a BigInteger whose value is (this pow exponent). Note that exponent is an integer rather than a BigInteger
            </summary>
            <param name="Exponent">Exponent to which this BigInteger is to be raised</param>
            <returns>this pow Exponent</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Exponent is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ProbablePrime(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            <para>Returns a positive BigInteger that is probably prime, with the specified bitLength. 
            The probability that a BigInteger returned by this method is composite does not exceed 2(-100)</para>
            </summary>
            <param name="BitLength">BitLength of the returned BigInteger</param>
            <param name="Rnd">Source of SecureRandom bits used to select candidates to be tested for primality</param>
            <returns>A BigInteger of BitLength bits that is probably prime</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Remainder(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this % Value)
            </summary>
            <param name="Value">Value by which this BigInteger is to be divided, and the remainder computed</param>
            <returns>this % Value</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Signum is zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.SetBit(System.Int32)">
            <summary>
            <para>Returns a BigInteger whose value is equivalent to this BigInteger with the designated bit set. (Computes (this | (1 &lt;&lt; N)).)</para>
            </summary>
            <param name="N">Index of bit to set</param>
            <returns>this | (1 &lt;&lt; N)</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if bit address (N) is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ShiftLeft(System.Int32)">
            <summary>
            <para>Returns a BigInteger whose value is (this &#60;&#60; N). 
            The shift distance, n, may be negative, in which case this method performs a right shift. (Computes floor(this * 2n).)</para>
            </summary>
            <param name="N">Shift distance in bits</param>
            <returns>this &#60;&#60; N</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ShiftRight(System.Int32)">
            <summary>
            <para>Returns a BigInteger whose value is (this &#62;&#62; N). Sign extension is performed. 
            The shift distance, n, may be negative, in which case this method performs a left shift. (Computes floor(this / 2n).)</para>
            </summary>
            <param name="N">Shift distance in bits</param>
            <returns>this &#62;&#62; N</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Subtract(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this - Value)
            </summary>
            <param name="Value">Value to be subtracted from this BigInteger</param>
            <returns>this - Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.TestBit(System.Int32)">
             <summary>
             Returns true if and only if the designated bit is set. (Computes ((this &amp; (1 &amp;&amp; N)) != 0).)
             </summary>
             
             <param name="N">Index of bit to test</param>
             <returns>true if and only if the designated bit is set</returns>
            
             <exception cref="T:System.ArithmeticException">Thrown if bit position (N) is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ToByteArray">
            <summary>
            <para>Returns a byte array containing the two's-complement representation of this BigInteger. 
            The byte array will be in big-endian byte-order: the most significant byte is in the zeroth element. 
            The array will contain the minimum number of bytes required to represent this BigInteger, including at least one sign bit, which is (ceil((this.bitLength() + 1)/8)). 
            (This representation is compatible with the (byte[]) constructor.)</para>
            </summary>
            <returns>A byte array containing the two's-complement representation of this BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ToByteArrayUnsigned">
            <summary>
            Returns an unsigned byte array containing the two's-complement representation of this BigInteger
            </summary>
            <returns>A byte array containing the two's-complement representation of this BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ToString">
            <summary>
            <para>Returns the decimal String representation of this BigInteger. 
            The digit-to-character mapping provided by Character.forDigit is used., and a minus sign is prepended if appropriate.</para>
            </summary>
            <returns>Decimal String representation of this BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ToString(System.Int32)">
            <summary>
            Returns the String representation of this BigInteger in the given radix
            </summary>
            <param name="Radix">Radix of the String representation</param>
            <returns>String representation of this BigInteger in the given radix</returns>
            
            <exception cref="T:System.FormatException">Thrown if bases other than 2, 10, 16 are used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.ValueOf(System.Int64)">
            <summary>
            <para>Returns a BigInteger whose value is equal to that of the specified long. 
            This "static factory method" is provided in preference to a (long) constructor because it allows for reuse of frequently used BigIntegers.</para>
            </summary>
            <param name="Value">Value of the BigInteger to return</param>
            <returns>A BigInteger with the specified value.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.Xor(VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger whose value is (this ^ val). (This method returns a negative BigInteger if and only if exactly one of this and val are negative.)
            </summary>
            <param name="Value">Value to be XOR'ed with this BigInteger</param>
            <returns>this ^ Value</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.BitCount">
            <summary>
            Number of bits in the two's complement representation of this BigInteger that differ from its sign bit
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.BitLength">
            <summary>
            Number of bits in the minimal two's-complement representation of this BigInteger, excluding a sign bit
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.IntValue">
            <summary>
            <para>Converts this BigInteger to an int. 
            If this BigInteger is too big to fit in an int, only the low-order 32 bits are returned. 
            Note that this conversion can lose information about the overall magnitude of the BigInteger value as well as return a result with the opposite sign.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.LongValue">
            <summary>
            <para>Converts this BigInteger to a long. 
            If this BigInteger is too big to fit in a long, only the low-order 64 bits are returned. 
            Note that this conversion can lose information about the overall magnitude of the BigInteger value as well as return a result with the opposite sign.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Numeric.BigInteger.SignValue">
            <summary>
            The sign value
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator">
            <summary>
            <h3>A helper class for generating cryptographically strong keying material.</h3>
            
            <list type="bullet">
            <item><description>SHA-2<cite></cite> Generates key material using a two stage Hmac_k(Prng()) process.</description></item>
            <item><description>Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, and Skein<cite>Skein</cite> also use a two stage generation method; Hash(Prng()).</description></item>
            <item><description>Prng can be any of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Prngs"/> generators.</description></item>
            <item><description>Hash can be any of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests"/> digests.</description></item>
            <item><description>Default Prng is CSPRng<cite>RNGCryptoServiceProvider</cite>, default digest is SHA512.</description></item>
            <item><description>Resources are disposed of automatically.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Create an array of pseudo random keying material:</description>
            <code>
            byte[] rand;
            using (KeyGenerator gen = new KeyGenerator(Prng, Digest))
                // generate pseudo random bytes
                rand = gen.Generate(Size);
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Assignable digests and Prng parameters added</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Prng">VTDev.Libraries.CEXEngine.Crypto.Prng Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">VTDev.Libraries.CEXEngine.Crypto.Prngs Enumeration</seealso>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.#ctor">
            <summary>
            <para>Initializes the class with default generators; SHA-2 512, and RNGCryptoServiceProvider</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Prngs,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class and generators
            </summary>
            <param name="SeedEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">Prng</see> that supplies the key and seed material to the hash function</param>
            <param name="HashEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> type used to create the pseudo random keying material</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.GetKeyParams(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a populated KeyParams class
            </summary>
            
            <param name="KeySize">Size of Key to generate in bytes</param>
            <param name="IVSize">Size of Optional IV in bytes</param>
            <param name="IKMSize">Size of Optional IKM in bytes</param>
            
            <returns>A populated <see cref="T:VTDev.Libraries.CEXEngine.Crypto.KeyParams"/> class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.GetBytes(System.Byte[])">
            <summary>
            Fill an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.GetBytes(System.Int32)">
            <summary>
            Return an array with cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.Reset">
            <summary>
            Reset the seed <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Prngs">PRNG</see> and the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> engines
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.GetBlock">
            <remarks>
            Create keying material using a two stage generator
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Helper.KeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256">
            <summary>
            <h3>Blake256: An implementation of the Blake digest with a 256 bit return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Blake<cite>Blake</cite> digest</para>
            <list type="bullet">
            <item><description>Block size is 32 bytes, (256 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Blake256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 Proposal <see href="https://131002.net/blake">Blake</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            <item><description>SHA3 Submission in C: <see href="https://131002.net/blake/blake_ref.c">blake_ref.c</see>.</description></item>
            <item><description>The: <see href="http://hashlib.codeplex.com/">HashLib</see> Project (test vectors).</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent project by Dominik Reichl: <see href="http://www.codeproject.com/Articles/286937/BlakeSharp-A-Csharp-Implementation-of-the-BLAKE-Ha">Blake Sharp</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX">
            <summary>
            <h3>SHX: A Serpent cipher extended with an HKDF powered Key Schedule.</h3>
            
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 32, 40, 48, 56, 64, 80, 96 and 128, default is 64.</description></item>
            </list>
            
            <para>SHX is a Serpent<cite>Serpent</cite> implementation that uses an HKDF generator to expand the user supplied key into a working key integer array. 
            It also takes a user defined number of rounds between 32 (the standard number of rounds), all the way up to 128 rounds in 8 round sets. 
            A round count of 40 or 48 is more than sufficient, as theoretical attacks to date are only able to break up to 12 rounds; and would require an enormous amount of memory and processing power.
            The transform in SHX is identical to the Serpent implementation SPX, it process rounds by first moving the byte input array into 4 integers, then processing the rounds in a while loop. 
            Each round consists of an XOR of each state word (<math>Rn</math>) with a key, an S-Box transformation of those words, and then a linear transformation. 
            Each of the 8 S-Boxes are used in succession within a loop cycle. The final round XORs the last 4 keys with the state and shifts them back into the output byte array.</para>
            
            <para>The key schedule in SHX powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            SHX is capable of processing up to 128 rounds, that is four times the number of rounds used in a standard implementation of Serpent. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds"/> static property.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new SHX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release using a fixed Digest key schedule generator</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release using an assignable Digest in the HKDF engine</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds"/> property contains available sizes</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container.<para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib0(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb1(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib1(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb2(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib2(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb3(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib3(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb4(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib4(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb5(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib5(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb6(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib6(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb7(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib7(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LinearTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.InverseTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the inverse of the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.FileUtilities">
            <summary>
            <h3>File, Folder and Drive methods wrapper class.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DriveGetSize(System.String)">
            <summary>
            Get Total Drive space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DriveGetFreeSpace(System.String)">
            <summary>
            Get Drive Free space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DriveGetFreeSpaceMB(System.String)">
            <summary>
            Get Drive Free space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DriveGetPath(System.String)">
            <summary>
            Get the drive path from a directory or file path
            </summary>
            
            <param name="DirectoryPath">Path</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.IsDriveReady(System.String)">
            <summary>
            Drive is available
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryCreate(System.String)">
            <summary>
            Create a folder
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryChecked(System.String)">
            <summary>
            Test for directory and create
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryExists(System.String)">
            <summary>
            Test for directory
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryGetFileCount(System.String)">
            <summary>
            Get the number of files in a directory
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>Count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryGetFiles(System.String)">
            <summary>
            Return all the files in a directory
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            
            <returns>File names [string]]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryGetCommon(System.Environment.SpecialFolder)">
            <summary>
            Get common directories
            </summary>
            
            <param name="FolderPath">Folder enum</param>
            
            <returns>Directory [string]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryGetPath(System.String)">
            <summary>
            Get file directory from path
            </summary>
            
            <param name="FilePath">File path</param>
            
            <returns>Directory [string]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryGetSize(System.String)">
            <summary>
            Return all the files in a directory
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            
            <returns>File names [string]]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryHasPermission(System.String,System.Security.AccessControl.FileSystemRights)">
            <summary>
            Test a directory for create file access permissions
            </summary>
            
            <param name="DirectoryPath">Full path to file or directory </param>
            <param name="AccessRight">File System right tested</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryIsWritable(System.String)">
            <summary>
            Directory can write/create
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryCanCreate(System.String)">
            <summary>
            Test a directory for create file access permissions
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryCanWrite(System.String)">
            <summary>
            Test a directory for write file access permissions
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryAddAccessRule(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Add an access rule to a folder
            </summary>
            
            <param name="Path">Folder path</param>
            <param name="User">UNC path to user profile ex. Environment.UserDomainName + "\\" + Environment.UserName</param>
            <param name="Rights">Desired file system rights</param>
            <param name="Access">Desired level of access</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryAddSecurity(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Add a file system right to a directory
            </summary>
            
            <param name="Path">Full path to directory</param>
            <param name="Account">UNC path to user profile</param>
            <param name="Rights">Desired file system rights</param>
            <param name="ControlType">Access control type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryGetAccessRules(System.String,System.String)">
            <summary>
            Get access rules for a folder
            </summary>
            
            <param name="Path">Folder path</param>
            <param name="Account">UNC path to user profile</param>
            
            <returns>Rule collection [AuthorizationRuleCollection]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.DirectoryRemoveSecurity(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Remove a file system right to a directory
            </summary>
            
            <param name="FileName">Full path to directory</param>
            <param name="Account">UNC path to user profile</param>
            <param name="Rights">Desired file system rights</param>
            <param name="ControlType">Access control type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.FileJoinPaths(System.String,System.String)">
            <summary>
            Safely create a full path
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            <param name="FileName">File name</param>
            
            <returns>Full path to file</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.FileHasPermission(System.String,System.Security.AccessControl.FileSystemRights)">
            <summary>
            Test a file for create file access permissions
            </summary>
            
            <param name="FilePath">Full path to file</param>
            <param name="AccessRight">File System right tested</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.FileGetSize(System.String)">
            <summary>
            Get the size of  file
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>File length</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.FileGetUniqueName(System.String)">
            <summary>
            Adds an extension to a file unique to the directory
            </summary>
            
            <param name="FullPath">Full file path</param>
            
            <returns>Unique filename in original path</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.FileIsReadable(System.String)">
            <summary>
            File is readable
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.FileIsReadOnly(System.String)">
            <summary>
            Test a file to see if it is readonly
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Read only</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.IsValidFileName(System.String)">
            <summary>
            Test if file name is valid [has extension]
            </summary>
            
            <param name="FileName">File name</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.IsValidFilePath(System.String)">
            <summary>
            Test path to see if directory exists and file name has proper format
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.FormatBytes(System.Int64)">
            <summary>
            Format bytes into larger sizes
            </summary>
            
            <param name="bytes">Length in bytes</param>
            
            <returns>Size string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.FileUtilities.GetLocalProfile">
            <summary>
            Get the local profile path
            </summary>
            
            <returns>Profile path</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">
            <summary>
            <h3>HKDF: An implementation of an Hash based Key Derivation Function.</h3>
            <para>HKDF as outlined in RFC 5869<cite>RFC 5869</cite></para>
            
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new HKDF(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Changes to formatting and documentation</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC HMAC</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            Guiding Publications:
            
            
            </remarks>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 5869: <see href="http://tools.ietf.org/html/rfc5869">Specification</see>.</description></item>
            <item><description>HKDF Scheme: <see href="http://tools.ietf.org/html/rfc5869">Whitepaper</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a HKDF Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac)">
            <summary>
            Creates a HKDF Bytes Generator based on the given HMAC function
            </summary>
            
            <param name="Hmac">The HMAC digest used</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Hmac is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Generate(System.Byte[])">
            <summary>
            Generate a block of cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate cryptographically secure pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType">
            <summary>
            Specifies the Skein initialization type.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.Normal">
            <summary>
            Identical to the standard Skein initialization.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ZeroedState">
            <summary>
            Creates the initial state with zeros instead of the configuration block, then initializes the hash.
            This does not start a new UBI block type, and must be done manually.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ChainedState">
            <summary>
            Leaves the initial state set to its previous value, which is then chained with subsequent block transforms.
            This does not start a new UBI block type, and must be done manually.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ChainedConfig">
            <summary>
            Creates the initial state by chaining the previous state value with the config block, then initializes the hash.
            This starts a new UBI block type with the standard Payload type.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType">
            <summary>
            The Unique Block Iteration (UBI) options
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Key">
            <summary>
            A key that turns Skein into a MAC or KDF function.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Config">
            <summary>
            The configuration block.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Personalization">
            <summary>
            A string that applications can use to create different functions for different uses.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.PublicKey">
            <summary>
            Used to hash the public key when hashing a message for signing.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.KeyIdentifier">
            <summary>
            Used for key derivation.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Nonce">
            <summary>
            Nonce value for use in stream cipher mode and randomized hashing.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Message">
            <summary>
            The normal message input of the hash function.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Out">
            <summary>
            The output transform.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak">
            <summary>
            <para>The Unique Block Iteration (UBI) implementations, <see href="https://www.schneier.com/skein1.3.pdf">section 2.3</see>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.StartNewBlockType(VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType)">
            <summary>
            Starts a new UBI block type by setting BitsProcessed to zero, setting the first flag, and setting the block type.
            </summary>
            <param name="type">The UBI block type of the new block</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.IsFirstBlock">
            <summary>
            Gets or sets the first block flag.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.IsFinalBlock">
            <summary>
            Gets or sets the final block flag.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.TreeLevel">
            <summary>
            Gets or sets the current tree level.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.BitsProcessed">
            <summary>
            Gets or sets the number of bits processed so far, inclusive.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.BlockType">
            <summary>
            Gets or sets the current UBI block type.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.Tweak">
            <summary>
            The current Threefish tweak value.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256">
            <summary>
            <h3>Skein256: An implementation of the Skein digest with a 256 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            <list type="bullet">
            <item><description>Block size is 32 bytes, (256 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> to reinitialize.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">VTDev.Libraries.CEXEngine.Crypto.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance.
            </summary>
            
            <param name="OutputSize">The output size of the hash in bits. Output size must be divisible by 8 and greater than zero</param>
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid output size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ComputeHash(System.Byte[])">
            <summary>
            <para>Get the Hash value. Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> 
            is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version"></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ConfigValue">
            <summary>
            The post-chain configuration value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ConfigString">
            <summary>
            The pre-chain configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX">
            <summary>
            <h3>RHX: A Rijndael Cipher extended with an HKDF powered Key Schedule.</h3>
            
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            <item><description>Valid Rounds are 10 to 38, default is 22.</description></item>
            </list>
            
            <para>The key schedule in RHX is the defining difference between this and a standard version of Rijndael<cite>Rijndael</cite>; 
            instead of using a simple inline function to expand the user supplied key into a larger working array, it uses a hash based pseudo-random generator to create the working key.</para>
            
            <para>HKDF<cite>RFC 5869</cite> is a key derivation function that uses a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
            HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RHX is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in post-quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RHX is capable of processing up to 38 rounds, that is twenty-four rounds more than the fourteen rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds"/> static property.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RHX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
                <revision date="2014/11/11" version="1.2.0.0" author="John Underhill">Initial release using a fixed Digest key schedule generator</revision>
                <revision date="2015/01/23" version="1.3.0.0" author="John Underhill">Secondary release using an assignable Digest in the HKDF engine</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds"/> property contains available sizes</param>
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalBlockSizes"/> property contains available sizes</param>
            <param name="KeyEngine"><para>The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digests">Digest</see> 
            implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/></para>.</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid block size or invalid rounds count are chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and initialize state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
    </members>
</doc>
