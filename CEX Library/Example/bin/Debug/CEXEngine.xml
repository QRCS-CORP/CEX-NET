<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CEXEngine</name>
    </assembly>
    <members>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.DriveTools">
            <summary>
            Drive methods wrapper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DriveTools.GetSize(System.String)">
            <summary>
            Get Total Drive space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DriveTools.GetFreeSpace(System.String)">
            <summary>
            Get Drive Free space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DriveTools.GetFreeSpaceMB(System.String)">
            <summary>
            Get Drive Free space
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DriveTools.GetPath(System.String)">
            <summary>
            Get the drive path from a directory or file path
            </summary>
            
            <param name="DirectoryPath">Path</param>
            
            <returns>Result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DriveTools.IsReady(System.String)">
            <summary>
            Drive is available
            </summary>
            
            <param name="DrivePath">Path to drive</param>
            
            <returns>Result</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Security.SecureDelete">
            <summary>
            <h3>Secure File Deletion class.</h3>
            </summary>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-88R1<cite>SP800-88R1</cite>: Table A-5 clear and purge on an ATA drive.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Security.SecureDelete.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Security.SecureDelete.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Security.SecureDelete.Delete(System.String)">
            <summary>
            Delete a file
            </summary>
            
            <param name="FilePath">Path to file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Security.SecureDelete.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Security.SecureDelete.FileSize">
            <summary>
            The file size in bytes
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG">
            <summary>
            <h3>An implementation of the Cubic Congruential Generator II random number generator: CCG</h3>
            <para>Implements CCG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.4</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new CCG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">CubicResiduePrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">
            <summary>
            Pseudo Random Number Generator Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next(System.Int32)">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Next(System.Int32,System.Int32)">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be initialized.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CCG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher">
            <summary>
            <h3>Volume cipher helper class.</h3>
            <para>Extends the StreamCipher class for encrypting a compressed directory of files.
            If the cipher is for encryption, files are compressed and encrypted to the output stream.
            If the cipher is for decryption, the input stream contains the compressed and encrypted directory, 
            and the directory path is the destination path for the decrypted and inflated files.</para>
            
            </summary> 
            
            <example>
            <description>Example of archiving/encrypting and decrypting/inflating a Directory:</description>
            <code>
            public static void CompressionCipherTest(string InputDirectory, string OutputDirectory, string CompressedFilePath)
            {
                KeyParams kp = new KeyGenerator().GetKeyParams(32, 16);
                // Create an archive //
                // create the cipher
                using (ICipherMode cipher = new CTR(new RDX()))
                {
                    // initialize the cipher for encryption
                    cipher.Initialize(true, kp);
            
                    // create the archive file
                    using (FileStream fs = new FileStream(CompressedFilePath, FileMode.Create))
                    {
                        // compress and encrypt directory
                        using (CompressionCipher cc = new CompressionCipher(true, cipher))
                        {
                            // set the input folder path and archive output stream
                            cc.Initialize(InputDirectory, fs);
                            // write the compressed and encrypted archive to file
                            cc.Write();
                        }
                    }
                }
            
                // Inflate an archive //
                // create the cipher
                using (ICipherMode cipher = new CTR(new RDX()))
                {
                    // initialize the cipher for decryption
                    cipher.Initialize(false, kp);
            
                    // open the archive
                    using (FileStream decmp = new FileStream(CompressedFilePath, FileMode.Open))
                    {
                        // decrypt and inflate to output directory
                        using (CompressionCipher cc = new CompressionCipher(false, cipher))
                        {
                            // set the output folder path and archive path
                            cc.Initialize(OutputDirectory, decmp);
                            // decrypt and inflate the directory
                            cc.Write();
                        }
                    }
                }
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/05/18" version="1.3.8.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher Mode</see> wrapped <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Block Ciphers</see>, or any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Ciphers</see>.</description></item>
            <item><description>Cipher Engine can be Disposed when this class is Disposed, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Streams can be Disposed when the class is Disposed, set the DisposeStream parameter in the Initialize(Stream, Stream, bool) call to true to dispose automatically.</description></item>
            <item><description>Implementation has a Progress counter that returns total sum of bytes processed per any of the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher.Write">Write()</see> calls.</description></item>
            <item><description>Changes to the Cipher or StreamCipher ParallelBlockSize must be set after initialization.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">
            <summary>
            <h3>Cipher stream helper class.</h3>
            <para>Wraps encryption stream functions in an easy to use interface.</para>
            
            </summary> 
            
            <example>
            <description>Example of encrypting and decrypting a Stream:</description>
            <code>
            public static void StreamCipherTest()
            {
                const int BLSZ = 1024;
                KeyParams key;
                byte[] data;
                MemoryStream instrm;
                MemoryStream outstrm = new MemoryStream();
            
                using (KeyGenerator kg = new KeyGenerator())
                {
                    // get the key
                    key = kg.GetKeyParams(32, 16);
                    // 2048 bytes
                    data = kg.GetBytes(BLSZ * 2);
                }
                // data to encrypt
                instrm = new MemoryStream(data);
            
                // Encrypt a stream //
                // create the outbound cipher
                using (ICipherMode cipher = new CTR(new RDX()))
                {
                    // initialize the cipher for encryption
                    cipher.Initialize(true, key);
                    // set block size
                    ((CTR)cipher).ParallelBlockSize = BLSZ;
            
                    // encrypt the stream
                    using (StreamCipher sc = new StreamCipher(cipher))
                    {
                        sc.Initialize(instrm, outstrm);
                        // encrypt the buffer
                        sc.Write();
                    }
                }
            
                // reset stream position
                outstrm.Seek(0, SeekOrigin.Begin);
                MemoryStream tmpstrm = new MemoryStream();
            
                // Decrypt a stream //
                // create the decryption cipher
                using (ICipherMode cipher = new CTR(new RDX()))
                {
                    // initialize the cipher for decryption
                    cipher.Initialize(false, key);
                    // set block size
                    ((CTR)cipher).ParallelBlockSize = BLSZ;
            
                    // decrypt the stream
                    using (StreamCipher sc = new StreamCipher(cipher))
                    {
                        sc.Initialize(outstrm, tmpstrm);
                        // process the encrypted bytes
                        sc.Write();
                    }
                }
            
                // compare decrypted output with data
                if (!Compare.AreEqual(tmpstrm.ToArray(), data))
                    throw new Exception();
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher Mode</see> wrapped <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Block Ciphers</see>, or any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Ciphers</see>.</description></item>
            <item><description>Cipher Engine can be Disposed when this class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Dispose">Disposed</see>, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Streams can be Disposed when the class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Dispose">Disposed</see>, set the DisposeStream parameter in the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Initialize(System.IO.Stream,System.IO.Stream,System.Boolean)"/> call to true to dispose automatically.</description></item>
            <item><description>Implementation has a Progress counter that returns total sum of bytes processed per any of the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Write">Write()</see> calls.</description></item>
            <item><description>Changes to the Cipher or StreamCipher <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ParallelBlockSize">ParallelBlockSize</see> must be set after initialization.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher._outStream">
            <summary>
            The output stream (protected member)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.#ctor(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the class with a CipherDescription Structure; containing the cipher implementation details, and a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class containing the Key material.
            <para>This constructor creates and configures cryptographic instances based on the cipher description contained in a CipherDescription. 
            Cipher modes, padding, and engines are destroyed automatically through this classes Dispose() method.</para>
            </summary>
            
            <param name="Encryption">Cipher is an encryptor</param>
            <param name="Header">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> containing the cipher description</param>
            <param name="KeyParam">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class containing the encryption Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if an invalid <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">CipherDescription</see> or <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams">KeyParams</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode,VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding,System.Boolean)">
            <summary>
            Initialize the class with a Block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> and optional <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding">Padding</see> instances.
            <para>This constructor requires a fully initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes">CipherMode</see> instance.
            If the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes">PaddingMode</see> parameter is null, X9.23 padding will be used if required.</para>
            </summary>
            
            <param name="Cipher">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Block Cipher</see> wrapped in a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> mode</param>
            <param name="Padding">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding">Padding</see> instance</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null or uninitialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher,System.Boolean)">
            <summary>
            Initialize the class with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> instance.
            <para>This constructor requires a fully initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">StreamCipher</see> instance.</para>
            </summary>
            
            <param name="Cipher">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> instance</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null or uninitialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Initialize(System.IO.Stream,System.IO.Stream,System.Boolean)">
            <summary>
            Initialize internal state
            </summary>
            
            <param name="InStream">The Source stream to be transformed</param>
            <param name="OutStream">The transformed Output stream</param>
            <param name="DisposeStream">Dispose of streams when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null Input or Output stream is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Write">
            <summary>
            Process the entire length of the Input Stream (fastest)
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if Write is called before Initialize(), or the Input stream is too short</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Write(System.Int64,System.Int64)">
            <summary>
            Process a length within the Input stream using Offsets
            </summary>
            
            <param name="InOffset">The Input Stream positional offset</param>
            <param name="OutOffset">The Output Stream positional offset</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if Write is called before Initialize(), or if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ParallelBlockProfile">
            <summary>
            Get/Set: Determines how the size of a parallel block is calculated; using the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.BlockProfiles">Block Profiles</see>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, 
            or the size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ProcessorCount">
            <summary>
            Get: The system processor count
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.BlockProfiles">
            <summary>
            ParallelBlockProfile enumeration
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.BlockProfiles.ProgressProfile">
            <summary>
            Set parallel block size as a division of 100 segments
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.BlockProfiles.SpeedProfile">
            <summary>
            Set parallel block size for maximum possible speed
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher.#ctor(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the class with a CipherDescription Structure; containing the cipher implementation details, and a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class containing the Key material.
            <para>This constructor creates and configures cryptographic instances based on the cipher description contained in a CipherDescription. 
            Cipher modes, padding, and engine classes are destroyed automatically through this classes Dispose() method.</para>
            </summary>
            
            <param name="Encryption">Cipher is an encryptor</param>
            <param name="Header">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> containing the cipher description</param>
            <param name="KeyParam">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class containing the encryption Key material</param>
            
            <exception cref="T:System.ArgumentException">Thrown if an invalid <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">CipherDescription</see> is used</exception>
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams">KeyParams</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher.#ctor(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode,VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding,System.Boolean)">
            <summary>
            Initialize the class with a Block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> and optional <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding">Padding</see> instances.
            <para>This constructor requires a fully initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes">CipherMode</see> instance.
            If the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes">PaddingMode</see> parameter is null, X9.23 padding will be used if required.</para>
            </summary>
            
            <param name="Compress">The volume cipher is in compression mode (encrypt)</param>
            <param name="Cipher">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Block Cipher</see> wrapped in a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> mode</param>
            <param name="Padding">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding">Padding</see> instance</param>
            <param name="DisposeEngine">Dispose of cipher engine when Dispose() on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if an uninitialized Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher.#ctor(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher,System.Boolean)">
            <summary>
            Initialize the class with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> instance.
            <para>This constructor requires a fully initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">StreamCipher</see> instance.</para>
            </summary>
            
            <param name="Compress">The volume cipher is in compression mode (encrypt)</param>
            <param name="Cipher">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> instance</param>
            <param name="DisposeEngine">Dispose of cipher engine when Dispose() on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> is used</exception>
            <exception cref="T:System.ArgumentException">Thrown if an uninitialized Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher.Initialize(System.String,System.IO.Stream,VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats,System.Boolean)">
            <summary>
            Initialize internal state
            </summary>
            
            <param name="DirectoryPath">The Source directory, or destination path</param>
            <param name="DataStream">The input or output stream</param>
            <param name="CompressionFormat">The type of compression to apply to the stream stream</param>
            <param name="DisposeStream">Dispose of streams when Dispose() on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the directory path has no files, does not exist, or is not writeable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher.Write(System.Int64,System.Int64)">
             <summary>
             Process the entire length of the Input Stream (fastest)
             </summary>
            
             <param name="InOffset">The Input Stream positional offset</param>
             <param name="OutOffset">The Output Stream positional offset</param>
             
             <exception cref="T:System.InvalidOperationException">Thrown if Write is called before Initialize()</exception>
             <exception cref="T:System.ArgumentOutOfRangeException">Thrown if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher.Write">
            <summary>
            Process a length within the Input stream using Offsets
            </summary>
            
            <exception cref="T:System.InvalidOperationException">Thrown if Write is called before Initialize()</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes">
            <summary>
            <para>Key Sizes in bits. Can be cast as Key byte size integers, 
            i.e. (int sz = KeySizes.K256) is equal to 32.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K128">
            <summary>
            128 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K192">
            <summary>
            192 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K256">
            <summary>
            256 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K384">
            <summary>
            384 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K448">
            <summary>
            448 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K512">
            <summary>
            512 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K768">
            <summary>
            768 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1024">
            <summary>
            1024 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1088">
            <summary>
            1088 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1280">
            <summary>
            1280 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1536">
            <summary>
            1536 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1664">
            <summary>
            1664 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K1792">
            <summary>
            1792 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2048">
            <summary>
            2048 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2240">
            <summary>
            2240 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2304">
            <summary>
            2304 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2560">
            <summary>
            2560 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K2816">
            <summary>
            2816 bit Key 
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K3072">
            <summary>
            3072 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K3584">
            <summary>
            3584 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K4096">
            <summary>
            4096 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K4608">
            <summary>
            4608 bit Key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes.K5120">
            <summary>
            5120 bit Key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512">
            <summary>
            <h3>Skein512: An implementation of the Skein digest with a 512 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/03/10" version="1.3.0.0">Added Initialize call to Ctor</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> to reinitialize.</description></item>
            </list> 
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">
            <summary>
            Hash Digest Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance
            </summary>
            
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value.
            <para>Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Used to re-initialize the digest state.
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ConfigValue">
            <summary>
            The post-chain configuration value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.ConfigString">
            <summary>
            The configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein512.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512">
            <summary>
            <h3>Blake512: An implementation of the Blake digest with a 512 bit return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Blake<cite>Blake</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Blake512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 Proposal <see href="https://131002.net/blake">Blake</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            <item><description>SHA3 Submission in C: <see href="https://131002.net/blake/blake_ref.c">blake_ref.c</see>.</description></item>
            <item><description>The: <see href="http://hashlib.codeplex.com/">HashLib</see> Project (test vectors).</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent project by Dominik Reichl: <see href="http://www.codeproject.com/Articles/286937/BlakeSharp-A-Csharp-Implementation-of-the-BLAKE-Ha">Blake Sharp</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake512.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha">
            <summary>
            <h3>ChaCha+: A parallelized ChaCha stream cipher implementation.</h3>
            <para>A ChaCha cipher extended to use up to 30 rounds.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new ChaCha())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/06/14" version="1.4.0.0">Added parallel processing</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128 and 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>ChaCha20 <see href="http://cr.yp.to/chacha/chacha-20080128.pdf">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">
            <summary>
            Stream Cipher Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key ot iv is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if the input and output arrays do not align or are too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Length of data to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if input array is smaller then the ouput array</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.LegalRounds"/> property contains available sizes. Default is 20 rounds.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. 
            <para>Uses the Key and IV fields of KeyParam. 
            The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.LegalKeySizes"/> property contains valid Key sizes. 
            IV must be 8 bytes in size.</para>
            </param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key or iv  is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size  is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Reset">
            <summary>
            Reset the primary internal counter
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Counter">
            <summary>
            Get the current counter value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.DistributionCode">
            <summary>
            Get/Set: Sets the Nonce value in the initialization parameters (Tau-Sigma). 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code must be 16 bytes in length and sufficiently asymmetric (no more than 2 repeats, of 2 bytes, at a distance of 2 intervals).</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.ChaCha.VectorSize">
            <summary>
            Get: Initialization vector size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey">
            <summary>
            A Generalized Merkle Signature Scheme Private Key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">
            <summary>
            The Asymmetric key interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.ToBytes">
            <summary>
            Converts the key pair to a byte array
            </summary>
            
            <returns>The encoded key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.ToStream">
            <summary>
            Returns the current key pair set as a MemoryStream
            </summary>
            
            <returns>KeyPair as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.WriteTo(System.Byte[])">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">KeyPair as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">KeyPair as a byte array; can be initialized as zero bytes</param>
            <param name="Offset">The starting position within the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the key pair to an output stream
            </summary>
            
            <param name="Output">Output Stream</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.#ctor(System.Byte[][],System.Byte[][],System.Byte[][][],System.Byte[][][],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash[][],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash[][],System.Collections.Generic.List{System.Byte[]}[],System.Collections.Generic.List{System.Byte[]}[],System.Collections.Generic.List{System.Byte[]}[][],System.Collections.Generic.List{System.Byte[]}[][],System.Byte[][],System.Byte[][],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Generates a new GMSS private key
            </summary>
            
            <param name="CurrentSeed">A seed for the generation of private OTS keys for the current subtrees</param>
            <param name="NextNextSeed">A seed for the generation of private OTS keys for the next subtrees</param>
            <param name="CurrentAuthPath">Array of current authentication paths</param>
            <param name="NextAuthPath">Array of next authentication paths</param>
            <param name="CurrentTreehash">Array of current treehash instances</param>
            <param name="NextTreehash">Array of next treehash instances</param>
            <param name="CurrentStack">Array of current shared stacks</param>
            <param name="NextStack">Array of next shared stacks</param>
            <param name="CurrentRetain">Array of current retain stacks</param>
            <param name="NextRetain">Array of next retain stacks</param>
            <param name="NextRoot">The roots of the next subtree</param>
            <param name="CurrentRootSig">Array of signatures of the roots of the current subtrees</param>
            <param name="ParameterSet">The GMSS Parameterset</param>
            <param name="Digest">The digest type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.#ctor(System.Int32[],System.Byte[][],System.Byte[][],System.Byte[][][],System.Byte[][][],System.Byte[][][],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash[][],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash[][],System.Collections.Generic.List{System.Byte[]}[],System.Collections.Generic.List{System.Byte[]}[],System.Collections.Generic.List{System.Byte[]}[][],System.Collections.Generic.List{System.Byte[]}[][],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf[],System.Int32[],System.Byte[][],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc[],System.Byte[][],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            
            </summary>
            
            <param name="Index">The tree indices</param>
            <param name="CurrentSeeds">A seed for the generation of private OTS keys for the current subtrees</param>
            <param name="NextNextSeeds">A seed for the generation of private OTS keys for the next subtrees</param>
            <param name="CurrentAuthPaths">Array of current authentication paths</param>
            <param name="NextAuthPaths">Array of next authentication paths</param>
            <param name="Keep">Keep array for the authPath algorithm</param>
            <param name="CurrentTreehash">Treehash for authPath algorithm of current tree</param>
            <param name="NextTreehash">Treehash for authPath algorithm of next tree (TREE+)</param>
            <param name="CurrentStack">Shared stack for authPath algorithm of current tree</param>
            <param name="NextStack">Shared stack for authPath algorithm of next tree (TREE+)</param>
            <param name="CurrentRetain">Retain stack for authPath algorithm of current tree</param>
            <param name="NextRetain">Retain stack for authPath algorithm of next tree (TREE+)</param>
            <param name="NextNextLeaf">Array of upcoming leafs of the tree after next (LEAF++) of each layer</param>
            <param name="UpperLeaf">Needed for precomputation of upper nodes</param>
            <param name="UpperTreehashLeaf">Needed for precomputation of upper treehash nodes</param>
            <param name="MinTreehash">Index of next treehash instance to receive an update</param>
            <param name="NextRoot">The roots of the next trees (ROOT+)</param>
            <param name="NextNextRoot">The roots of the tree after next (ROOT++)</param>
            <param name="CurrentRootSig">Array of signatures of the roots of the current subtrees (SIG)</param>
            <param name="NextRootSig">Array of signatures of the roots of the next subtree (SIG+)</param>
            <param name="ParameterSet">The GMSS Parameterset</param>
            <param name="Digest">The digest type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey)">
            <summary>
            Copy Constructor
            </summary>
            
            <param name="PrivateKey">The GMSSPrivateKey to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.#ctor(System.IO.Stream)">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.#ctor(System.Byte[])">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="Key">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.From(System.Byte[])">
            <summary>
            Read a Private key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized GMSSPrivateKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.From(System.IO.Stream)">
            <summary>
            Read a Private key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized GMSSPrivateKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.ToBytes">
            <summary>
            Converts the Private key to an encoded byte array
            </summary>
            
            <returns>The encoded GMSSPrivateKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.ToStream">
            <summary>
            Converts the GMSSPrivateKey to an encoded MemoryStream
            </summary>
            
            <returns>The Private Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the GMSSPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded GMSSPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded GMSSPrivateKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Private Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.ComputeAuthPaths(System.Int32)">
            <summary>
            Computes the upcoming currentAuthpath of <c>layer</c> using the revisited authentication path computation of Dahmen/Schneider 2008
            </summary>
            
            <param name="Layer">The actual layer</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.GetMinTreehashIndex(System.Int32)">
            <summary>
            This method returns the index of the next Treehash instance that should receive an update
            </summary>
            
            <param name="Layer">The layer of the GMSS tree</param>
            
            <returns>Return index of the treehash instance that should get the update</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.HeightOfPhi(System.Int32)">
            <summary>
            Returns the largest h such that 2^h | Phi
            </summary>
            
            <param name="Phi">The leaf index</param>
            
            <returns>Return The largest <c>h</c> with <c>2^h | Phi</c> if <c>Phi!=0</c> else return <c>-1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.NextKey(System.Int32)">
            <summary>
            This method updates the GMSS private key for the next signature
            </summary>
            
            <param name="Layer">The layer where the next key is processed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.NextTree(System.Int32)">
            <summary>
            Switch to next subtree if the current one is depleted
            </summary>
            
            <param name="Layer">The layer the layer where the next tree is processed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.UpdateKey(System.Int32)">
            <summary>
            This method computes the authpath (AUTH) for the current tree.
            Additionally the root signature for the next tree (SIG+), the authpath
            (AUTH++) and root (ROOT++) for the tree after next in layer
            <c>layer</c>, and the LEAF++^1 for the next next tree in the
            layer above are updated This method is used by nextKey()
            </summary>
            
            <param name="Layer"></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.UpdateNextNextAuthRoot(System.Int32)">
            <summary>
            Updates the authentication path and root calculation for the tree after next (AUTH++, ROOT++) in layer <c>layer</c>
            </summary>
            
            <param name="Layer">The layer</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.Clone">
            <summary>
            Create a shallow copy of this MPKCPublicKey instance
            </summary>
            
            <returns>MPKCPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.DeepCopy">
            <summary>
            Create a deep copy of this GMSSPrivateKey instance
            </summary>
            
            <returns>The GMSSPrivateKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey">
            <summary>
            A Ring-LWE Private Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.#ctor(System.Int32,System.Byte[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="N">The number of coefficients</param>
            <param name="R2">The private key as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.#ctor(System.IO.Stream)">
            <summary>
            Reads a Private Key from a Stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.#ctor(System.Byte[])">
            <summary>
            Reads a Private Key from a byte array
            </summary>
            
            <param name="KeyArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.From(System.Byte[])">
            <summary>
            Read a Private key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized RLWEPrivateKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.From(System.IO.Stream)">
            <summary>
            Read a Private key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized RLWEPrivateKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.ToBytes">
            <summary>
            Converts the Private key to an encoded byte array
            </summary>
            
            <returns>The encoded RLWEPrivateKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.ToStream">
            <summary>
            Converts the RLWEPrivateKey to an encoded MemoryStream
            </summary>
            
            <returns>The Private Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the RLWEPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded RLWEPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded RLWEPrivateKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Private Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.Clone">
            <summary>
            Create a shallow copy of this MPKCPublicKey instance
            </summary>
            
            <returns>MPKCPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.DeepCopy">
            <summary>
            Create a deep copy of this RLWEPrivateKey instance
            </summary>
            
            <returns>The RLWEPrivateKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.R2">
            <summary>
            Get: Returns the private key as a byte array
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey.N">
            <summary>
            Get: Returns the number of coefficients
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey">
            <summary>
            A NTRU Private Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32,System.Int32,System.Boolean,System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.TernaryPolynomialType)">
            <summary>
            Constructs a new private key from a polynomial
            </summary>
            
            <param name="T">The polynomial which determines the key: if <c>FastFp=true</c>, <c>f=1+3T</c>; otherwise, <c>f=T</c></param>
            <param name="FP">Fp the inverse of <c>f</c></param>
            <param name="N">The number of polynomial coefficients</param>
            <param name="Q">The big q modulus</param>
            <param name="Sparse">Sparse whether the polynomial <c>T</c> is sparsely or densely populated</param>
            <param name="FastFp">FastFp whether <c>FP=1</c></param>
            <param name="PolyType">PolyType type of the polynomial <c>T</c></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.#ctor(System.IO.MemoryStream)">
            <summary>
            Reads a Private Key from a Stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.#ctor(System.Byte[])">
            <summary>
            Reads a Private Key from a byte array
            </summary>
            
            <param name="KeyArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.From(System.Byte[])">
            <summary>
            Read a Private key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized NTRUPrivateKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.From(System.IO.MemoryStream)">
            <summary>
            Read a Private key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized NTRUPrivateKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.ToBytes">
            <summary>
            Converts the Private key to an encoded byte array
            </summary>
            
            <returns>The encoded NTRUPrivateKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.ToStream">
            <summary>
            Converts the NTRUPrivateKey to an encoded MemoryStream
            </summary>
            
            <returns>The Private Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the NTRUPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded NTRUPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded NTRUPrivateKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Private Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Clone">
            <summary>
            Create a shallow copy of this NTRUPrivateKey instance
            </summary>
            
            <returns>NTRUPrivateKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.DeepCopy">
            <summary>
            Create a deep copy of this NTRUPrivateKey instance
            </summary>
            
            <returns>The NTRUPrivateKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.N">
            <summary>
            Get: The number of polynomial coefficients
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.Q">
            <summary>
            Get: The big Q modulus
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.PolyType">
            <summary>
            Get: PolyType type of the polynomial <c>T</c>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.T">
            <summary>
            Get/Set: The polynomial which determines the key: if <c>FastFp=true</c>, <c>F=1+3T</c>; otherwise, <c>F=T</c>
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey.FP">
            <summary>
            Get: Fp the inverse of <c>F</c>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen">
            <summary>
            An implementation of the <a href="http://en.wikipedia.org/wiki/Sch%C3%B6nhage%E2%80%93Strassen_algorithm">Schnhage-Strassen algorithm</a>
            for multiplying large numbers.
            </summary>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Arnold Schnhage und Volker Strassen: Schnelle Multiplikation groer Zahlen<cite>Schnelle Multiplikation groer Zahlen</cite>.</description></item>
            <item><description>Eine verstandliche Beschreibung des Schonhage-Strassen-Algorithmus<cite>Eine verstandliche Beschreibung des Schonhage-Strassen-Algorithmus</cite>.</description></item>
            </list>
            
            Numbers are internally represented as <c>int</c> arrays; the <c>int</c>s are interpreted as unsigned numbers.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AddModFn(System.Int32[],System.Int32[])">
            <summary>
            Adds two positive numbers (meaning they are interpreted as unsigned) modulo 2^2^N+1,
            where N is <c>A.Length*32/2</c>; in other words, n is half the number of bits in <c>A</c>.
            <para>Both input values are given as <c>int</c> arrays; they must be the same length.
            The result is returned in the first argument.</para>
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            <param name="B">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AddShifted(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Adds two numbers, <c>A</c> and <c>B</c>, after shifting <c>B</c> by <c>numElements</c> elements.
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit</param>
            <param name="B">A number in base 2^32 starting with the lowest digit</param>
            <param name="NumElements">The shift amount in bits</param>
            
            <remarks>
            Both numbers are given as <c>int</c> arrays and must be positive numbers (meaning they are interpreted as unsigned).
            The result is returned in the first argument. If any elements of B are shifted outside the valid range for <c>A</c>, they are dropped.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AppendBits(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Reads BitLenB bits from <c>B</c>, starting at array index 
            <c>StartB</c>, and copies them into <c>A</c>, starting at bit
            <c>BitLenA</c>. The result is returned in <c>A</c>.
            </summary>
            
            <param name="A">Array A</param>
            <param name="BitLenA">Array A bit length</param>
            <param name="B">Array B</param>
            <param name="StartB">B starting position</param>
            <param name="BitLenB">Array B bit length</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.CyclicShiftRight(System.Int32[],System.Int32)">
            <summary>
            Cyclicly shifts a number to the right modulo 2^2^n+1 and returns the result in a new array.
            <para>"Right" means towards the lower array indices and the lower bits; this is equivalent to
            a multiplication by <c>2^(-numBits) modulo 2^2^n+1</c>. The number n is <c>a.Length*32/2</c>; 
            in other words, n is half the number of bits in <c>A</c>.
            Both input values are given as <c>int</c> arrays; they must be the same length.
            </para>
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            <param name="NumBits">The shift amount in bits</param>
            
            <returns>The shifted number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.CyclicShiftLeftBits(System.Int32[],System.Int32)">
            <summary>
            Shifts a number to the left modulo 2^2^n+1 and returns the result in a new array.
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            <param name="NumBits">The shift amount in bits</param>
            
            <returns>The shifted number</returns>
            
            <remarks>
            <para>"Left" means towards the lower array indices and the lower bits; this is equivalent to
            a multiplication by 2^numBits modulo 2^2^n+1.
            The number n is <c>a.Length*32/2</c>; in other words, n is half the number of bits in <c>A</c>.
            Both input values are given as <c>int</c> arrays; they must be the same length. The result is returned in the first argument.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.CyclicShiftLeftElements(System.Int32[],System.Int32)">
            <summary>
            Cyclicly shifts an array towards the higher indices by <c>numElements</c> elements and returns the result in a new array.
            </summary>
            
            <param name="A">Input array</param>
            <param name="NumElements">The shift amount in bits</param>
            
            <returns>The shifted number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Dft(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            Performs a Fermat Number Transform on an array whose elements are <c>int</c> arrays.<br/>
            </summary>
            <param name="A">Array to process</param>
            <param name="M">M Value</param>
            <param name="N">N Value</param>
            
            <remarks>
            <para><c>A</c> is assumed to be the lower half of the full array and the upper half is assumed to be all zeros.
            The number of subarrays in <c>A</c> must be 2^n if m is even and 2^(n+1) if m is odd.<br/>
            Each subarray must be ceil(2^(n-1)) bits in length.<br/>
            * n must be equal to m/2-1.</para>
            <para><a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform_%28general%29#Number-theoretic_transform">Number-theoretic transform</a></para>
            
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Idft(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            Performs a modified Inverse Fermat Number Transform on an array whose elements are <c>int</c> arrays.
            </summary>
            
            <param name="A">Array to process: Must be ceil(2^(n-1)) bits in length</param>
            <param name="M">M Value</param>
            <param name="N">N Value</param>
            
            <remarks>
            The modification is that the last step (the one where the upper half is subtracted from the lower half) is omitted.
            <c>A</c> is assumed to be the upper half of the full array and the upper half is assumed to be all zeros.
            The number of subarrays in <c>A</c> must be 2^n if m is even and 2^(n+1) if m is odd.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Multiplies two BigIntegers using the Schnhage-Strassen algorithm.
            </summary>
            
            <param name="A">Factor A</param>
            <param name="B">Factor B</param>
            
            <returns>BigInteger equal to <c>A.Multiply(B)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Multiply(System.Int32[],System.Int32[])">
            <summary>
            Multiplies two positive numbers represented as int arrays, i.e. in base <c>2^32</c>.
            <para>Positive means an int is always interpreted as an unsigned number, regardless of the sign bit.<br/>
            The arrays must be ordered least significant to most significant,
            so the least significant digit must be at index 0.
            Schnhage-Strassen is used unless the numbers are in a range where
            <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba</a> is more efficient.</para>
            </summary>
            
            <param name="A">Factor A</param>
            <param name="B">Factor B</param>
            
            <returns>Array equal to <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.MultKaratsuba(System.Int32[],System.Int32[])">
            <summary>
            Multiplies two positive numbers represented as <c>int</c> arrays using the Karatsuba algorithm
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Array equal to <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.MultSimple(System.Int32[],System.Int32[])">
            <summary>
            Multiplies two positive numbers (meaning they are interpreted as unsigned) represented as
            <c>int</c> arrays using the simple O(n) algorithm.
            </summary>
            
            <param name="A">Array A: a number in base 2^32 starting with the lowest digit</param>
            <param name="B">Array B:  a number in base 2^32 starting with the lowest digit</param>
            
            <returns>Array equal to <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.MultModFn(System.Int32[],System.Int32[])">
            <summary>
            Multiplies two positive numbers (meaning they are interpreted as unsigned) modulo Fn where Fn=2^2^n+1, and returns the result in a new array.
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            <param name="B">A number in base 2^32 starting with the lowest digit; the length must be a power of 2</param>
            
            <returns>Result of calculation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ModFn(System.Int32[])">
            <summary>
            Reduces all subarrays modulo 2^2^n+1 where n=<c>a[i].Length*32/2</c> for all i;
            in other words, n is half the number of bits in the subarray.
            </summary>
            
            <param name="A">Int array whose length is a power of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ModFn(System.Int32[][])">
            <summary>
            Reduces all subarrays modulo 2^2^n+1 where n=<c>a[i].Length*32/2</c> for all i;
            in other words, n is half the number of bits in the subarray.
            </summary>
            
            <param name="A">Int arrays whose length is a power of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SubModPow2(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Subtracts two positive numbers (meaning they are interpreted as unsigned) modulo 2^numBits.
            <para>Both input values are given as <c>int</c> arrays.
            The result is returned in the first argument.</para>
            </summary>
            
            <param name="A">A number in base 2^32 starting with the lowest digit</param>
            <param name="B">A number in base 2^32 starting with the lowest digit</param>
            <param name="NumBits">The number of bits to shift</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ToBigInteger(System.Int32[])">
            <summary>
            Converts an <c>int</c> array to a <c>BigInteger</c>
            </summary>
            
            <param name="A">The integer array</param>
            
            <returns><c>BigInteger</c> representation of the array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ToIntArray(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Converts a <c>BigInteger</c> to an <c>int</c> array.
            </summary>
            
            <param name="A">BigInteger A</param>
            
            <returns>An <c>int</c> array that is compatible with the <c>mult()</c> methods</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AddExpand(System.Int32[],System.Int32[])">
             <summary>
             Adds two positive numbers (meaning they are interpreted as unsigned) that are given as
             int arrays and returns the result in a new array. The result may be one longer
             than the input due to a carry.
             </summary>
             
             <param name="A">A number in base 2^32 starting with the lowest digit</param>
             <param name="B">A number in base 2^32 starting with the lowest digit</param>
            
             <returns>The sum</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.AddModPow2(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Adds two positive numbers (meaning they are interpreted as unsigned) modulo 2^numBits.
            Both input values are given as int arrays. The result is returned in the first argument.
            </summary>
            <param name="A">A number in base 2^32 starting with the lowest digit</param>
            <param name="B">A number in base 2^32 starting with the lowest digit</param>
            <param name="NumBits">The modulo bit size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.Multiply(System.Int32[],System.Int32,System.Int32[],System.Int32)">
            <remarks>
            <para>Schnhage-Strassen is used unless the numbers are in a range where
            <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba</a> is more efficient.</para>
            The Schnhage-Strassen algorithm works as follows:
            Given numbers a and b, split both numbers into pieces of length 2^(n-1) bits.
            Take the low n+2 bits of each piece of a, zero-pad them to 3n+5 bits, and concatenate them to a new number u.
            Do the same for b to obtain v.
            Calculate all pieces of z' by multiplying u and v (using Schnhage-Strassen or another algorithm). The product will contain all pieces of a*b mod n+2.
            Pad the pieces of a and b from step 1 to 2^(n+1) bits.
            Perform a <a href="http://en.wikipedia.org/wiki/Discrete_Fourier_transform_%28general%29#Number-theoretic_transform">
            Discrete Fourier Transform</a> (DFT) on the padded pieces.
            Calculate all pieces of z" by multiplying the i-th piece of a by the i-th piece of b.
            Perform an Inverse Discrete Fourier Transform (IDFT) on z". z" will contain all pieces of a*b mod Fn where Fn=2^2^n+1.
            Calculate all pieces of z such that each piece is congruent to z' modulo n+2 and congruent to z" modulo Fn. This is done using the
            <a href="http://en.wikipedia.org/wiki/Chinese_remainder_theorem">Chinese remainder theorem</a>.
            Calculate c by adding z_i * 2^(i*2^(n-1)) for all i, where z_i is the i-th piece of z.
            Return c reduced modulo 2^2^m+1.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.ShouldUseSchonhageStrassen(System.Int32)">
            <remarks>
            Estimates whether SS or Karatsuba will be more efficient when multiplying two numbers of a given length in bits.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SplitBits(System.Int32[],System.Int32)">
            <remarks>
            Divides an int array into pieces BitLength bits long.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SplitInts(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <remarks>
            Splits an int array into pieces of pieceSize ints each, and
            pads each piece to TargetPieceSize ints.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SubExpand(System.Int32[],System.Int32[])">
            <remarks>
            Subtracts two positive numbers (meaning they are interpreted as unsigned) that are given as
            int arrays and returns the result in a new array.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.SchonhageStrassen.SubModFn(System.Int32[],System.Int32[],System.Int32)">
            <remarks>
            Subtracts two positive numbers (meaning they are interpreted as unsigned) modulo 2^2^n+1,
            where n is a.Length*32/2; in other words, n is half the number of bits in A.
            Both input values are given as int arrays; they must be the same length.
            The result is returned in the first argument.
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean">
            <summary>
            Extended Euclidean Algorithm in integers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.X">
            <summary>
            Coefficient X
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.Y">
            <summary>
            Coefficient Y
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.GCD">
            <summary>
            Greatest Common Divisor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.IntEuclidean.Calculate(System.Int32,System.Int32)">
            <summary>
            Runs the EEA on two BigIntegers
            </summary>
            <param name="A">Quotient A</param>
            <param name="B">Quotient B</param>
            <returns>Return a BigIntEuclidean object that contains the result in the variables X, Y, and GCD</returns>
            
            <remarks>
            Implemented from pseudocode on <a href="http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm"/>Wikipedia
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs">
            <summary>
            An event arguments class containing the error state information.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs.Message">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags">Exchange State</see> (Auth or Primary), from which this message originated
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs.Severity">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity"/> flag indicating the operational impact of the error
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs.Cancel">
            <summary>
            The Cancel token; setting this value to true instructs the server to shutdown the exchange (Terminate)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs.#ctor(System.Exception,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity)">
            <summary>
            The DTM error event args constructor; contains the current error state
            </summary>
            
            <param name="Message">The <see cref="T:System.Exception"/></param>
            <param name="Severity">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity"/> flag indicating the operational impact of the error</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign">
            <summary>
            The Asymmetric cipher interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the Key for Sign (Private) or Verify (Public)
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the Public (verify) or Private (sign) key</param>
            
            <exception>CryptoAsymmetricSignException Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Reset">
            <summary>
            Reset the underlying engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Sign(System.IO.Stream)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="InputStream">The stream containing the data</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception>CryptoAsymmetricSignException Thrown if an invalid key is used, or signer has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Sign(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="Input">The byte array contining the data</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception>CryptoAsymmetricSignException Thrown if input array is too short, signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Verify(System.IO.Stream,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="InputStream">The stream containing the data to test</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception>CryptoAsymmetricSignException Thrown if signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Verify(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="Input">The stream containing the data to test</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception>CryptoAsymmetricSignException Thrown if input array is too short, signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.IsSigner">
            <summary>
            Get: This class is initialized for Signing with the Private key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign.Name">
            <summary>
            Get: The Signer name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags">
            <summary>
            This enum represents the DTM KEX exchange state flags
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.Connect">
            <summary>
            Public id fields exchange
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.Init">
            <summary>
            Exchange full Public Identity
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.PreAuth">
            <summary>
            Exchange Asymmetric Public keys
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.AuthEx">
            <summary>
            Exchange Symmetric KeyParams
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.Auth">
            <summary>
            Exchange Private Id's
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.Sync">
            <summary>
            Exchange Primary Asymmetric parameter OId's
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.PrimeEx">
            <summary>
            Exchange Primary Public Keys
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.Primary">
            <summary>
            Exchange Primary Symmetric keys
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags.Established">
            <summary>
            The VPN is established
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.FileTools">
            <summary>
            File methods wrapper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.JoinPaths(System.String,System.String)">
            <summary>
            Safely create a full path
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            <param name="FileName">File name</param>
            
            <returns>Full path to file</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.HasPermission(System.String,System.Security.AccessControl.FileSystemRights)">
            <summary>
            Test a file for create file access permissions
            </summary>
            
            <param name="FilePath">Full path to file</param>
            <param name="AccessRight">File System right tested</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.GetSize(System.String)">
            <summary>
            Get the size of  file
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>File length</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.GetUniqueName(System.String)">
            <summary>
            Adds an extension to a file unique to the directory
            </summary>
            
            <param name="FullPath">Full file path</param>
            
            <returns>Unique filename in original path</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.IsReadable(System.String)">
            <summary>
            File is readable
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.IsReadOnly(System.String)">
            <summary>
            Test a file to see if it is readonly
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Read only</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.IsValidName(System.String)">
            <summary>
            Test if file name is valid [has extension]
            </summary>
            
            <param name="FileName">File name</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.IsValidPath(System.String)">
            <summary>
            Test path to see if directory exists and file name has proper format
            </summary>
            
            <param name="FilePath">Full path to file</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.SetOwner(System.String,System.Security.Principal.NTAccount)">
            <summary>
            Set the ownership of a file
            </summary>
            
            <param name="FilePath">Full path to file</param>
            <param name="Account">The account taking ownership</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.FormatBytes(System.Int64)">
            <summary>
            Format bytes into larger sizes
            </summary>
            
            <param name="bytes">Length in bytes</param>
            
            <returns>Size string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.FileTools.GetLocalProfile">
            <summary>
            Get the local profile path
            </summary>
            
            <returns>Profile path</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigEndian">
            <summary>
            This is a utility class containing data type conversions using big-endian byte order
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4 according to IEEE 1363, Section 5.5.3
            </summary>
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Int32)">
            <summary>
            Convert an integer to an octet string according to IEEE 1363, Section 5.5.3. Length checking is performed
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Length">The desired length of the octet string</param>
            
            <returns>Returns an octet string of length <c>OctLength</c> representing the integer <c>X</c>, or <c>null</c> if the integer is negative</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.LongToOctets(System.Int64)">
            <summary>
            Convert an integer to an octet string of length 8 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">he integer to convert</param>
            
            <returns>The converted long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.IntToOctets(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an integer to an octet string of the specified length according to IEEE 1363, Section 5.5.3.
            <para>No length checking is performed (i.e., if the integer cannot be encoded into <c>length</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
            <param name="Length">The length of the encoding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.LongToOctets(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to an octet string of length 8 according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array holding the output</param>
            <param name="OutOffset">The starting offset in the output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[])">
            <summary>
            Convert an octet string to an integer according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">he byte array holding the octet string</param>
            
            <returns>Returns an integer representing the octet string <c>Input</c>, or <c>0</c> if the represented integer is negative or too large or the byte array is empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 4 beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="InOffset">The offset into the byte array</param>
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToInt(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an octet string to an integer according to IEEE 1363, Section 5.5.3
            </summary>
            
            <param name="Input">The byte array holding the octet string</param>
            <param name="InOffset">The offset in the input byte array where the octet string starts</param>
            <param name="Length">The length of the encoded integer</param>
            
            <returns>Returns an integer representing the octet string <c>bytes</c>, or <c>0</c> if the represented integer is negative or too large or the byte array is empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.OctetsToLong(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 8 beginning at <c>inOff</c> into a long integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="InOffset">The offset into the byte array</param>
            
            <returns>The resulting long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToByteArray(System.Int32[])">
            <summary>
            Convert an int array into a byte array
            </summary>
            
            <param name="Input">The int array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToByteArray(System.Int32[],System.Int32)">
            <summary>
            Convert an int array into a byte array of the specified length.
            <para>No length checking is performed (i.e., if the last integer cannot be encoded into <c>length % 4</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The int array</param>
            <param name="Length">The length of the converted array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigEndian.ToIntArray(System.Byte[])">
            <summary>
            Convert a byte array into an int array
            </summary>
            
            <param name="Input">The byte array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2">
            <summary>
            <h3>An implementation of a Quadratic Congruential Generator II random number generator : QCG-II.</h3>
            <para>Implements QCGII as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.3</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new QCG2())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">QuadraidResidue2Prng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations; must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Reset">
            <summary>
            Resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG2.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG">
            <summary>
            <h3>An implementation of the Modular Exponentiation Generator random number generator: MODEXPG</h3>
            <para>Implements MODEXPG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.6</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new MODEXPG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">ModulusExponentPrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime</param>
            <param name="G">Random Generator State</param>
            <param name="Y">Random Generator Seed</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.MODEXPG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC">
            <summary>
            <h3>An implementation of a Cipher based Message Authentication Code: CMAC.</h3>
            <para>A CMAC as outlined in the NIST document: SP800-38B<cite>SP800-38B</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new CMAC(new RDX(), [DisposeEngine]))
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>MAC return size must be a divisible of 8.</description></item>
            <item><description>MAC return size can be no longer than the Cipher Block size.</description></item>
            <item><description>Valid Cipher block sizes are 8 and 16 byte wide.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Int32,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Cipher engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-38B: <see href="http://csrc.nist.gov/publications/nistpubs/800-38B/SP_800-38B.pdf">The CMAC Mode for Authentication</see>.</description></item>
            <item><description>RFC 4493: <see href="http://tools.ietf.org/html/rfc4493">The AES-CMAC Algorithm</see>.</description></item>
            <item><description>RFC 4494: <see href="http://tools.ietf.org/html/rfc4494">The AES-CMAC-96 Algorithm and Its Use with IPsec</see>.</description></item>
            <item><description>RFC 4493: <see href="http://tools.ietf.org/html/rfc4615">The AES-CMAC-PRF-128 Algorithm for the Internet Key Exchange Protocol (IKE)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac">
            <summary>
            Message Authentication Code (MAC) Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.ComputeMac(System.Byte[])">
            <summary>
            Get the Mac hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="Offset">The offset in the data</param>
            
            <returns>bytes processed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the MAC
            </summary>
            
            <param name="KeyParam">MAC key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Int32,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            <param name="Cipher">Instance of the block cipher</param>
            <param name="MacBits">Expected MAC return size in Bits; must be less or equal to Cipher Block size in bits</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if an invalid Mac or block size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Mac hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="OutOffset">The offset in the data</param>
            
            <returns>The number of bytes processed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher MAC.
            <para>Uses the Key field, and optionally the IV field of the KeyParams class.</para>
            </summary>
            
            <param name="KeyParam">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> containing the cipher Key and optional IV. 
            <para>Uses the Key field of the KeyParams parameter, and optionally the IV.
            Key size must be one of the <c>LegalKeySizes</c> of the underlying cipher.
            IV size must be the ciphers blocksize.
            </para>
            </param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.CMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">
            <summary>
            Wraps exceptions thrown within a Cryptographic Hash operational context.
            <para>This exception is used throughout the Digest classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators">
            <summary>
            Random Generator Digest KDFs
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators.DGCDRBG">
            <summary>
            An implementation of a Digest Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators.HKDF">
            <summary>
            A Hash based Key Derivation Function HKDF
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators.KDF2">
            <summary>
            An implementation of the Hash based KDF KDF2 DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KdfGenerators.PKCS5">
            <summary>
            An implementation of PKCS5 Version 2
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512">
            <summary>
            <h3>SHA512: An implementation of the SHA-2 digest with a 512 bit digest return size.</h3>
            <para>The SHA-2<cite>Fips 180-4</cite> 512 digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA-2 <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.#ctor">
            <summary>
            Initialize the digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value [64 bytes]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value, Always 64 bytes</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters">
            <summary>
            Creates, reads and writes parameter settings for Rainbow.
            <para>Predefined parameter sets are available through the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets"/> class.</para>
            </summary>
            
            <example>
            <description>Create a parameter set and write to stream:</description>
            <code>
            MemoryStream ks = new MemoryStream();
            using (RNBWParameters mp = new RNBWParameters(new byte[] { 4, 1, 2, 1 }, new int[] { 19, 26, 32, 38, 49 }))
               mp.WriteTo(ks);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/07" version="1.0.1.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWSign Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Rainbow Parameter Description:</h4></description>
            <list type="table">
            <item><description>OId - Three bytes that uniquely identify the parameter set.</description></item>
            <item><description>Vi - An array containing the number of vinegar variables per layer.</description></item>
            <item><description>Engine - The Prng engine.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Selecting Parameters for the Rainbow Signature Scheme<cite>Rainbow Parameters</cite>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters">
            <summary>
            The Asymmetric parameters interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.ToBytes">
            <summary>
            Returns the current parameter set as an ordered byte array
            </summary>
            
            <returns>Parameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.ToStream">
            <summary>
            Returns the current parameter set as a MemoryStream
            </summary>
            
            <returns>Parameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the parameter set to an output byte array
            </summary>
            
            <param name="Output">Parameters as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the parameter set to an output byte array
            </summary>
            
            <param name="Output">Parameters as a byte array; array must be initialized and of sufficient length</param>
            <param name="Offset">The starting position within the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the parameter set to an output stream
            </summary>
            
            <param name="Output">Output stream</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters.Name">
            <summary>
            Get: The parameters name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.#ctor(System.Byte[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The Rainbow family must be <c>4</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="Vi">An array containing the number of vinegar variables per layer</param>
            <param name="Engine">The PRNG engine used to power SecureRandom</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the Vi or Oid settings are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.#ctor(System.IO.Stream)">
            <summary>
            Reconstructs a RNBWParameters from its <c>byte</c> array representation.
            </summary>
            
            <param name="ParamStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Stream is unreadable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.#ctor(System.Byte[])">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="ParamArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.From(System.Byte[])">
            <summary>
            Read an encoded Parameter set from a byte array
            </summary>
            
            <param name="ParamArray">The byte array containing the parameters</param>
            
            <returns>An initialized RNBWParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.From(System.IO.Stream)">
            <summary>
            Read an encoded Parameters set from a Stream
            </summary>
            
            <param name="ParamStream">The Stream containing the encoded Parameter set</param>
            
            <returns>An initialized RNBWParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.ToBytes">
            <summary>
            Converts the current Parameter set to an encoded byte array
            </summary>
            
            <returns>RNBWParameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.ToStream">
            <summary>
            Converts the current Parameter set to an encoded Stream
            </summary>
            
            <returns>RNBWParameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the RNBWParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the RNBWParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if The output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the RNBWParameters to a Stream
            </summary>
            
            <param name="Output">The Output stream receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.Clone">
            <summary>
            Create a shallow copy of this RNBWParameters instance
            </summary>
            
            <returns>The RNBWParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.DeepCopy">
            <summary>
            Create a deep copy of this RNBWParameters instance
            </summary>
            
            <returns>The RNBWParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.Name">
            <summary>
            Get: Parameters name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.OId">
            <summary>
            Get: Four bytes that uniquely identify the parameter set
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.Vi">
            <summary>
            Get: The number of vinegar vars per layer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.NumLayers">
            <summary>
            Get: The number of layers
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.DocLength">
            <summary>
            Get: The number of all the polynomials in Rainbow
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters.RandomEngine">
            <summary>
            The random engine used by SecureRandom
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyPair">
            <summary>
            An Rainbow Key-Pair container
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">
            <summary>
            Asymmetric key pair interface
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair.Name">
            <summary>
            Get: The key pair name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair.PublicKey">
            <summary>
            The Public key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair.PrivateKey">
            <summary>
            The Private Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="PublicKey">The public key</param>
            <param name="PrivateKey">The corresponding private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Key">The public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyPair.Clone">
            <summary>
            Create a copy of this key pair instance
            </summary>
            
            <returns>The IAsymmetricKeyPair copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyPair.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyPair.Name">
            <summary>
            Get: KeyPair name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyPair.PublicKey">
            <summary>
            Get: Returns the public key parameters
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyPair.PrivateKey">
            <summary>
            Get: Returns the private key parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSignature">
            <summary>
            This class implements key pair generation and signature generation of the
            Winternitz one-time signature scheme (OTSS), described in C.Dods, N.P. Smart,
            and M. Stam, "Hash Based Digital Signature Schemes", LNCS 3796, pages
            96&#8211;115, 2005. The class is used by the GMSS classes.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSignature.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32)">
            <summary>
            The constructor generates an OTS key pair, using <c>seed0</c> and the PRNG
            </summary>
            
            <param name="Seed">The seed for the PRGN</param>
            <param name="Digest">The used hash function</param>
            <param name="W">The Winternitz parameter</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSignature.GetPrivateKey">
            <summary>
            The private OTS key
            </summary>
            
            <returns>The private key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSignature.GetPublicKey">
            <summary>
            The public OTS key
            </summary>
            
            <returns>The public key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSignature.GetSignature(System.Byte[])">
            <summary>
            The one-time signature of the message, generated with the private key
            </summary>
            
            <param name="Message">The message</param>
            
            <returns>The signature code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSignature.GetLog(System.Int32)">
            <summary>
            This method returns the least integer that is greater or equal to the logarithm to the base 2 of an integer <c>Value</c>
            </summary>
            
            <param name="Value">An integer</param>
            
            <returns>The least integer greater or equal to the logarithm to the base 2 of <c>Value</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyPair">
            <summary>
            An Generalized Merkle Signature Scheme Key-Pair container
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="PublicKey">The public key</param>
            <param name="PrivateKey">The corresponding private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Key">The public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyPair.Clone">
            <summary>
            Create a copy of this key pair instance
            </summary>
            
            <returns>The IAsymmetricKeyPair copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyPair.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyPair.Name">
            <summary>
            Get: KeyPair name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyPair.PublicKey">
            <summary>
            Get: Returns the public key parameters
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyPair.PrivateKey">
            <summary>
            Get: Returns the private key parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator">
            <summary>
            An implementation of the Index Generation Function IGF-2 in IEEE P1363.1 section 8.4.2.1.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters)">
            <summary>
            Constructs a new index generator
            </summary>
            
            <param name="Seed">A seed of arbitrary length to initialize the index generator</param>
            <param name="EncParam">NtruEncrypt parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.NextIndex">
            <summary>
            Returns a number
            </summary>
            
            <returns>The next pseudo-random index</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Engine">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString">
            <summary>
            Represents a string of bits and supports appending, reading the head, and reading the tail
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.AppendBits(System.Byte[])">
            <summary>
            Append bits to an array
            </summary>
            
            <param name="Data">Array to write to</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.AppendBits(System.Byte)">
            <summary>
            Appends all bits in a byte to the end of the bit string
            </summary>
            
            <param name="Value">The byte to append</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.GetTrailing(System.Int32)">
            <summary>
            Returns the last <c>NumBits</c> bits from the end of the bit string
            </summary>
            
            <param name="NumBits">Number of bits to return</param>
            
            <returns>A new <c>BitString</c> of length <c>numBits</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.Pop(System.Int32)">
            <summary>
            Returns up to 32 bits from the beginning of the bit string, and removes those bits from the bit string.
            </summary>
            
            <param name="NumBits">Number of bits to return</param>
            
            <returns>An <c>int</c> whose lower <c>NumBits</c> bits are the beginning of the bit string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.GetLeadingAsInt(System.Int32)">
            <summary>
            Returns up to 32 bits from the beginning of the bit string
            </summary>
            
            <param name="NumBits">The number of bits</param>
            
            <returns>An <c>int</c> whose lower <c>NumBits</c> bits are the beginning of the bit string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.Truncate(System.Int32)">
            <summary>
            Removes a given number of bits from the end of the bit string
            </summary>
            
            <param name="NumBits">The number of bits to remove</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator.BitString.Bytes">
            <summary>
            Bit string state array
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM">
            <summary>
            This class describes operations with polynomials from the ring R = GF(2^m)[X], where 2 &lt;= m &lt;=31
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.RANDOM_IRREDUCIBLE_POLYNOMIAL">
            <summary>
            Constant used for polynomial construction
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Construct the zero polynomial over the finite field GF(2^m)
            </summary>
            
            <param name="Field">The finite field GF(2^m)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,System.Int32,System.Char,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Construct a polynomial over the finite field GF(2^m)
            </summary>
            
            <param name="Field">The finite field GF(2^m)</param>
            <param name="Degree">The  degree of polynomial</param>
            <param name="PolynomialType">The  type of polynomial</param>
            <param name="Rand">The IRandom instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,System.Int32)">
            <summary>
            Construct a monomial of the given degree over the finite field GF(2^m)
            </summary>
            
            <param name="Field">The finite field GF(2^m)</param>
            <param name="Degree">The degree of the monomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,System.Int32[])">
            <summary>
            Construct the polynomial over the given finite field GF(2^m) from the given coefficient vector
            </summary>
            
            <param name="Field">The finite field GF2m</param>
            <param name="Coeffs">The coefficient vector</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,System.Byte[])">
            <summary>
            Create a polynomial over the finite field GF(2^m)
            </summary>
            
            <param name="Field">The finite field GF(2^m)</param>
            <param name="Encoded">The polynomial in byte array form</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Copy constructor
            </summary>
            
            <param name="Gf">The PolynomialGF2mSmallM to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector)">
            <summary>
            Create a polynomial over the finite field GF(2^m) out of the given coefficient vector
            <para>The finite field is also obtained from the GF2mVector</para>
            </summary>
            
            <param name="Vect"></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Compute the sum of this polynomial and the given polynomial
            </summary>
            
            <param name="Addend">he addend</param>
            
            <returns>Return <c>this + a</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.AddMonomial(System.Int32)">
            <summary>
            Compute the sum of this polynomial and the monomial of the given degree
            </summary>
            
            <param name="Degree">The degree of the monomial</param>
            
            <returns>Return <c>this + X^k</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.AddToThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Add the given polynomial to this polynomial (overwrite this).
            </summary>
            
            <param name="Addend">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Clear">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Divide(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Divide this polynomial by the given polynomial
            </summary>
            <param name="F">The polynomial</param>
            <returns>Returns polynomial pair = {q,r} where this = q*f+r and deg(r) &lt; deg(f)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.EvaluateAt(System.Int32)">
            <summary>
            Evaluate this polynomial <c>p</c> at a value <c>e</c> (in <c>GF(2^m)</c>) with the Horner scheme
            </summary>
            
            <param name="E">The element of the finite field GF(2^m)</param>
            
            <returns>Returns <c>this(e)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Gcd(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Return the greatest common divisor of this and a polynomial <c>F</c>
            </summary>
            
            <param name="F">The polynomial</param>
            
            <returns>Returns Gcd(this, f)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Gcd(System.Int32[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Return the greatest common divisor of two polynomials over the field <c>GF(2^m)</c>
            </summary>
            
            <param name="F">The first polynomial</param>
            <param name="G">The second polynomial</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Returns <c>Gcd(f, g)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.GetCoefficient(System.Int32)">
            <summary>
            Returns the coefficient with the given index
            </summary>
            
            <param name="Index">The index</param>
            
            <returns>Returns the coefficient with the given index</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.GetEncoded">
            <summary>
            Returns encoded polynomial, i.e., this polynomial in byte array form
            </summary>
            
            <returns>Returns the encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Mod(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Reduce this polynomial modulo another polynomial
            </summary>
            
            <param name="F">The reduction polynomial</param>
            
            <returns>Returns <c>this mod f</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModDivide(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Compute the result of the division of this polynomial by another polynomial modulo a third polynomial
            </summary>
            
            <param name="Divisor">The divisor</param>
            <param name="Modulus">The reduction polynomial</param>
            
            <returns>Returns <c>this * divisor^(-1) mod modulus</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModInverse(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Compute the inverse of this polynomial modulo the given polynomial
            </summary>
            
            <param name="A">The reduction polynomial</param>
            
            <returns>Returns <c>this^(-1) mod a</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Compute the product of this polynomial and another polynomial modulo a third polynomial
            </summary>
            
            <param name="A">The polynomial</param>
            <param name="B">The reduction polynomial</param>
            
            <returns>Returns <c>this * a mod b</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModPolynomialToFracton(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Compute a polynomial pair (a,b) from this polynomial and the given
            polynomial g with the property b*this = a mod g and deg(a)&lt;=deg(g)/2
            </summary>
            
            <param name="G">The reduction polynomial</param>
            
            <returns>Returns PolynomialGF2mSmallM[] {a,b} with b*this = a mod g and deg(a)&lt;= deg(g)/2</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModSquareMatrix(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM[])">
            <summary>
            Square this polynomial using a squaring matrix
            </summary>
            
            <param name="M">The squaring matrix</param>
            
            <returns>Returns <c>this^2</c> modulo the reduction polynomial implicitly given via the squaring matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModSquareRoot(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Compute the square root of this polynomial modulo the given polynomial
            </summary>
            
            <param name="A">The reduction polynomial</param>
            
            <returns>Returns <c>this^(1/2) mod A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModSquareRootMatrix(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM[])">
            <summary>
            Compute the square root of this polynomial using a square root matrix
            </summary>
            
            <param name="M">The matrix for computing square roots in <c>(GF(2^m))^t</c> the polynomial ring defining the square root matrix</param>
            
            <returns>Returns <c>this^(1/2)</c> modulo the reduction polynomial implicitly given via the square root matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Compute the product of this polynomial and the given factor using a Karatzuba like scheme
            </summary>
            
            <param name="Factor">the polynomial factor</param>
            
            <returns>Returns <c>this * factor</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.MultWithElement(System.Int32)">
            <summary>
            Compute the product of this polynomial with an element from GF(2^m)
            </summary>
            
            <param name="Element">An element of the finite field GF(2^m)</param>
            
            <returns>Return <c>this * element</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.MultThisWithElement(System.Int32)">
            <summary>
            Multiply this polynomial with an element from GF(2^m)
            </summary>
            
            <param name="Element">An element of the finite field GF(2^m)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.MultWithElement(System.Int32[],System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Compute the product of a polynomial a with an element from the finite field <c>GF(2^m)</c>
            </summary>
            
            <param name="A">The polynomial</param>
            <param name="Element">An element of the finite field GF(2^m)</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Return <c>a * element</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.MultWithMonomial(System.Int32)">
            <summary>
            Compute the product of this polynomial with a monomial X^k
            </summary>
            
            <param name="K">The degree of the monomial</param>
            
            <returns>Return <c>this * X^k</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Equals(System.Object)">
            <summary>
            Compare this element with another object
            </summary>
            
            <param name="Obj">The object for comprison</param>
            
            <returns>Returns <c>true</c> if the two objects are equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.GetHashCode">
            <summary>
            Returns the hash code of this element
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ToString">
            <summary>
            Returns a human readable form of the polynomial
            </summary>
            
            <returns>Returns a human readable form of the polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Add(System.Int32[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Compute the sum of two polynomials a and b over the finite field <c>GF(2^m)</c>
            </summary>
            
            <param name="A">The first polynomial</param>
            <param name="B">The second polynomial</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Return a + b</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ComputeDegree">
            <summary>
            Compute the degree of this polynomial. If this is the zero polynomial, the degree is -1
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ComputeDegree(System.Int32[])">
            <summary>
            Compute the degree of a polynomial
            </summary>
            
            <param name="A">The polynomial</param>
            
            <returns>Returns the degree of the polynomial <c>a</c>. If <c>a</c> is the zero polynomial, return -1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.CreateRandomIrreduciblePolynomial(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create an irreducible polynomial with the given degree over the field <c>GF(2^m)</c>
            </summary>
            
            <param name="Degree">The polynomial degree</param>
            <param name="SecRnd">The source of randomness</param>
            
            <returns>he generated irreducible polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.GetRandomElement(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Get a randome element over degree Gf2
            </summary>
            
            <param name="SecRnd">The source of randomness</param>
            <param name="GFM">The Gf2 field</param>
            
            <returns>A random element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Divide(System.Int32[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Compute the result of the division of two polynomials over the field <c>GF(2^m)</c>
            </summary>
            
            <param name="A">The first polynomial</param>
            <param name="F">The second polynomial</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Returns <c>int[][] {q,r}</c>, where <c>a = q*f+r</c> and <c>deg(r) &lt; deg(f)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.IsEqual(System.Int32[],System.Int32[])">
            <summary>
            Compare two polynomials given as int arrays
            </summary>
            
            <param name="A">The first polynomial</param>
            <param name="B">The second polynomial</param>
            
            <returns>Returns <c>true</c> if <c>a</c> and <c>b</c> represent the same polynomials, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.HeadCoefficient(System.Int32[])">
            <summary>
            Return the head coefficient of a polynomial
            </summary>
            
            <param name="A">he polynomial</param>
            
            <returns>Returns the head coefficient of <c>A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.IsIrreducible(System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Check a polynomial for irreducibility over the field <c>GF(2^m)</c>
            </summary>
            
            <param name="A">The polynomial to check</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Returns true if a is irreducible, false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Mod(System.Int32[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Reduce a polynomial modulo another polynomial
            </summary>
            
            <param name="A">The polynomial</param>
            <param name="F">The reduction polynomial</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Returns <c>a mod f</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModDiv(System.Int32[],System.Int32[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Compute the result of the division of two polynomials modulo a third polynomial over the field <c>GF(2^m)</c>
            </summary>
            
            <param name="A">The first polynomial</param>
            <param name="B">The second polynomial</param>
            <param name="G">The reduction polynomial</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Returns <c>a * b^(-1) mod g</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.ModMultiply(System.Int32[],System.Int32[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Compute the product of two polynomials modulo a third polynomial over the finite field <c>GF(2^m)</c>
            </summary>
            
            <param name="A">The first polynomial</param>
            <param name="B">The second polynomial</param>
            <param name="G">The reduction polynomial</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Returns <c>a * b mod g</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Multiply(System.Int32[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Compute the product of two polynomials over the field <c>GF(2^m)</c> using a Karatzuba like multiplication
            </summary>
            
            <param name="A">The first polynomial</param>
            <param name="B">The second polynomial</param>
            <param name="GF2">The GF2 field</param>
            
            <returns>Returns <c>a * b</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.MultWithMonomial(System.Int32[],System.Int32)">
            <summary>
            Compute the product of a polynomial with a monomial X^k
            </summary>
            <param name="A">The polynomial</param>
            <param name="K">The degree of the monomial</param>
            <returns>Return <c>a * X^k</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.NormalForm(System.Int32[])">
            <summary>
            Strip leading zero coefficients from the given polynomial
            </summary>
            
            <param name="A">The polynomial</param>
            
            <returns>The reduced polynomial</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Degree">
            <summary>
            Get: Returns the degree of this polynomial
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Field">
            <summary>
            Get: Returns the finite field GF(2^m)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM.Head">
            <summary>
            Get: Returns the head coefficient of this polynomial
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes">
            <summary>
            The flag sets the size of the Tcp/ip and internal buffers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.Auto">
            <summary>
            Buffer size is calculated automatically
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB1">
            <summary>
            Buffer is 1 Kib in length (1024 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB2">
            <summary>
            Buffer is 2 Kib in length (2048 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB4">
            <summary>
            Buffer is 4 Kib in length (4096 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB8">
            <summary>
            Buffer is 8 Kib in length (8192 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB16">
            <summary>
            Buffer is 16 Kib in length (16384 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB32">
            <summary>
            Buffer is 32 Kib in length (32768 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB64">
            <summary>
            Buffer is 64 Kib in length (65536 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB128">
            <summary>
            Buffer is 128 Kib in length (131072 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB256">
            <summary>
            Buffer is 256 Kib in length (262144 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB512">
            <summary>
            Buffer is 512 Kib in length (524288 bytes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmBufferSizes.KB1024">
            <summary>
            Buffer is 1024 Kib in length (1048576 bytes)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity">
            <summary>
            The flag indicating the severity of an error condition
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity.Information">
            <summary>
            An information message
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity.Warning">
            <summary>
            An error has been handled
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity.Connection">
            <summary>
            The network connection has experienced an error
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity.DataLoss">
            <summary>
            Data has been lost, but might be recovered
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorSeverity.Critical">
            <summary>
            A critical error has occured, haltin operations
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer">
            <summary>
            A class that can store an asymmetric key or key-pair, a parameters set, and an optional tag value.
            </summary>
            
            <remarks>
            <para>Use this class to store a ciphers keys and settings.
            The optional Tag value can be any length, is stored at the start of a serialized structure 
            (int: tag size, byte[]: tag value), and can be used to uniquely identify a container.
            Use the ToBytes() or ToStream() methods to serialize a container, and the 
            corresponding constructors to deserialize a stream or byte array.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,System.Byte[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Parameters">The cipher Parameters</param>
            <param name="AsmKey">The Public or Private asymmetric key</param>
            <param name="Tag">An identity field</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair,System.Byte[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Parameters">The cipher Parameters</param>
            <param name="KeyPair">The public or private key</param>
            <param name="Tag">An identity field</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.#ctor(System.IO.MemoryStream)">
            <summary>
            Reads the key container from an input stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key container</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.#ctor(System.Byte[])">
            <summary>
            Reads the key container from a byte array
            </summary>
            
            <param name="KeyArray">An byte array containing an encoded key container</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.ToBytes">
            <summary>
            Converts the Public key to an encoded byte array
            </summary>
            
            <returns>The encoded RLWEPublicKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.ToStream">
            <summary>
            Converts the Public key to an encoded MemoryStream
            </summary>
            
            <returns>The Public Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.EngineType">
            <summary>
            Get: Returns the asymmetric cipher family
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.Parameters">
            <summary>
            Get: Returns the parameters
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.PublicKey">
            <summary>
            Get: Returns the public key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.PrivateKey">
            <summary>
            Get: Returns the private key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricContainer.Tag">
            <summary>
            Get: Returns the identity tag
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ByteUtils">
            <summary>
            This class is a utility class for manipulating byte arrays
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Clone(System.Byte[])">
            <summary>
            Return a clone of the given byte array (performs null check beforehand).
            </summary>
            
            <param name="A">The array to clone</param>
            
            <returns>Returns the clone of the given array, or <c>null</c> if the array is <c>null</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Concatenate(System.Byte[][])">
            <summary>
            Convert a 2-dimensional byte array into a 1-dimensional byte array by concatenating all entries
            </summary>
            
            <param name="A">A 2-dimensional byte array</param>
            
            <returns>Returns the concatenated input array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Concatenate(System.Byte[],System.Byte[])">
            <summary>
            Concatenate two byte arrays. No null checks are performed
            </summary>
            
            <param name="A">The first array</param>
            <param name="B">The second array</param>
            
            <returns>Returns (x2||x1) (little-endian order, i.e. x1 is at lower memory addresses)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.DeepHashCode(System.Byte[])">
            <summary>
            Computes a hashcode based on the contents of a one-dimensional byte array rather than its identity
            </summary>
            
            <param name="A">The array to compute the hashcode of</param>
            
            <returns>The hashcode</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.DeepHashCode(System.Byte[][])">
            <summary>
            Computes a hashcode based on the contents of a two-dimensional byte array rather than its identity
            </summary>
            
            <param name="A">The array to compute the hashcode of</param>
            
            <returns>The hashcode</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.DeepHashCode(System.Byte[][][])">
            <summary>
            Computes a hashcode based on the contents of a three-dimensional byte array rather than its identity
            </summary>
            
            <param name="A">The array to compute the hashcode of</param>
            
            <returns>The hashcode</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Equals(System.Byte[],System.Byte[])">
            <summary>
            Compare two byte arrays (perform null checks beforehand).
            </summary>
            
            <param name="A">The first byte array</param>
            <param name="B">The second byte array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Equals(System.Byte[][],System.Byte[][])">
            <summary>
            Compare two two-dimensional byte arrays; No null checks are performed.
            </summary>
            
            <param name="A">The first byte array</param>
            <param name="B">The second byte array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Equals(System.Byte[][][],System.Byte[][][])">
            <summary>
            Compare two three-dimensional byte arrays; No null checks are performed.
            </summary>
            
            <param name="A">The first byte array</param>
            <param name="B">The second byte array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.FromHexString(System.String)">
            <summary>
            Convert a string containing hexadecimal characters to a byte-array
            </summary>
            
            <param name="S">A hex string</param>
            
            <returns>Returns a byte array with the corresponding value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Split(System.Byte[],System.Int32)">
            <summary>
            Split a byte array <c>Input</c> into two arrays at <c>Index</c>.
            <para>The first array will have the lower <c>Index</c> bytes, the second one the higher <c>Input.Length - index</c> bytes.</para>
            </summary>
            
            <param name="Input">The byte array to be split</param>
            <param name="Index">The index where the byte array is split</param>
            
            <returns>Returns the split input array as an array of two byte arrays</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.SubArray(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate a subarray of a given byte array
            </summary>
            
            <param name="Input">The input byte array</param>
            <param name="Start">The start index</param>
            <param name="End">The end index</param>
            
            <returns>Returns a subarray of <c>Input</c>, ranging from <c>Start</c> (inclusively) to <c>End</c> (exclusively)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.SubArray(System.Byte[],System.Int32)">
            <summary>
            Generate a subarray of a given byte array
            </summary>
            
            <param name="Input">The input byte array</param>
            <param name="Start">The start index</param>
            
            <returns>Returns a subarray of <c>Input</c>, ranging from <c>Start</c> to the end of the array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.ToBinaryString(System.Byte[])">
            <summary>
            Convert a byte array to the corresponding bit string
            </summary>
            
            <param name="Input">The byte array to be converted</param>
            
            <returns>The corresponding bit string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.ToCharArray(System.Byte[])">
            <summary>
            Rewrite a byte array as a char array
            </summary>
            
            <param name="Input">The byte array to convert</param>
            
            <returns>Returns the bytes represented as a char array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.ToHexString(System.Byte[])">
            <summary>
            Convert a byte array to the corresponding hexstring
            </summary>
            
            <param name="Input">The byte array to be converted</param>
            
            <returns>Returns the corresponding hexstring</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.ToHexString(System.Byte[],System.String,System.String)">
            <summary>
            Convert a byte array to the corresponding hex string
            </summary>
            
            <param name="Input">The byte array to be converted</param>
            <param name="Prefix">The prefix to put at the beginning of the hex string</param>
            <param name="Seperator">A separator string</param>
            
            <returns>The corresponding hex string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ByteUtils.Xor(System.Byte[],System.Byte[])">
            <summary>
            Compute the bitwise XOR of two arrays of bytes.
            <para>The arrays have to be of same length. No length checking is performed.</para>
            </summary>
            
            <param name="A">The first array</param>
            <param name="B">The second array</param>
            
            <returns>Returns <c>A^B</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.Compress">
            <summary>
            File and Folder Archiving and Compression
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.#ctor(VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats,System.IO.SearchOption)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Format">Compression engine</param>
            <param name="FolderOption">Compression all folders or top directory only</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CompressArchive(System.String)">
            <summary>
            Compress and archive a folder
            </summary>
            
            <param name="InputPath">Folder path</param>
            
            <returns>A stream containing the compressed bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CompressArchive(System.String,System.String)">
            <summary>
            Compress and archive a folder
            </summary>
            
            <param name="InputPath">Folder path</param>
            <param name="OutputFile">The full path to new archive file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.DeCompressArchive(System.IO.Stream,System.String)">
            <summary>
            Decompress an archive
            </summary>
            
            <param name="InputStream">The stream containing the compressed archive</param>
            <param name="OutputPath">Destination directory for expanded files</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.DeCompressArchive(System.String,System.String)">
            <summary>
            Decompress an archive
            </summary>
            
            <param name="InputFile">The full path to new archive file</param>
            <param name="OutputPath">Destination directory for expanded files</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CompressFile(System.String)">
            <summary>
            Compress a file to a stream
            </summary>
            
            <param name="InputFile">The full path to the compressed file</param>
            
            <returns>A stream containing the compressed bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CompressFile(System.String,System.String)">
            <summary>
            Compress a file
            </summary>
            
            <param name="InputFile">File to compress</param>
            <param name="OutputFile">Full path to destination file</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.DeCompressFile(System.String)">
            <summary>
            Decompress a file to a stream
            </summary>
            
            <param name="InputFile">The full path to the compressed file</param>
            
            <returns>The decompressed stream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.DeCompressFile(System.String,System.String)">
            <summary>
            Decompress a file
            </summary>
            
            <param name="InputFile">Compressed file</param>
            <param name="OutputPath">Directory path destination</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CompressStream(System.IO.Stream)">
            <summary>
            Compress a stream
            </summary>
            
            <param name="InputStream">The stream to compress</param>
            
            <returns>The compressed stream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.DeCompressStream(System.IO.Stream)">
            <summary>
            Decompress a stream
            </summary>
            
            <param name="InputStream">The stream to decompress</param>
            
            <returns>The decompressed stream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CreateFileHeader(VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats)">
            <summary>
            Create an empty Compression header
            </summary>
            
            <param name="Format">The compression format</param>
            
            <returns>An initialized CompressionHeader structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CreateFileHeader(System.String,VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats)">
            <summary>
            Create a Compression header from a file path
            </summary>
            
            <param name="InputFile">The file to compress</param>
            <param name="Format">The compression format</param>
            
            <returns>An initialized CompressionHeader structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CreateFolderHeader(System.String,VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats,System.IO.SearchOption)">
            <summary>
            Create a Compression header from a folder path
            </summary>
            
            <param name="InputPath">The file to compress</param>
            <param name="Format">The compression format</param>
            <param name="FolderOption">The scope of the folder compression; top level or all sub-folders</param>
            
            <returns>An initialized CompressionHeader structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.GetDeCompressedSize(System.IO.Stream)">
            <summary>
            Get the decompressed size from a compressed file
            </summary>
            
            <param name="InputStream">The stream containing the compressed file</param>
            
            <returns>The total size in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.GetDeCompressedSize(System.String)">
            <summary>
            Get the decompressed size from a compressed file
            </summary>
            
            <param name="InputFile">The full path to the compressed file</param>
            
            <returns>The total size in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.GetCompressionFormat(System.IO.Stream)">
            <summary>
            Get the compression format from a compressed file
            </summary>
            
            <param name="InputStream">The stream containing the compressed file</param>
            
            <returns>The compression format type</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.GetCompressionFormat(System.String)">
            <summary>
            Get the compression format from a compressed file
            </summary>
            
            <param name="InputFile">The full path to the compressed file</param>
            
            <returns>The compression format type</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.GetFileNames(System.IO.Stream)">
            <summary>
            Get the names of files contained in the compressed archive
            </summary>
            
            <param name="InputStream">The stream containing the compressed file</param>
            
            <returns>A string containing the file names</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.GetFileNames(System.String)">
            <summary>
            Get the names of files contained in the compressed archive
            </summary>
            
            <param name="InputFile">The full path to the compressed file</param>
            
            <returns>A string containing the file names</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.GetHeaderLength(System.IO.Stream)">
            <summary>
            Get the byte length of the header file
            </summary>
            
            <param name="InputStream">The stream containing the compressed file</param>
            
            <returns>The header size in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.GetHeaderLength(System.String)">
            <summary>
            Get the byte length of the header file
            </summary>
            
            <param name="InputFile">The full path to the compressed file</param>
            
            <returns>The header size in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.DeSerializeHeader(System.IO.Stream)">
            <summary>
            Read a compression header from a stream
            </summary>
            
            <param name="InputStream">The data stream</param>
            
            <returns>An initialized CompressionHeaderStruct</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.DeSerializeHeader(System.String)">
            <summary>
            Read a compression header from a file path
            </summary>
            
            <param name="InputFile">The full path to the input file</param>
            
            <returns>An initialized CompressionHeaderStruct</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.SerializeHeader(VTDev.Libraries.CEXEngine.Tools.Compress.CompressionHeader)">
            <summary>
            Serialize a CompressionHeaderStruct
            </summary>
            
            <param name="Header">The initialized CompressionHeaderStruct</param>
            
            <returns>The struct as a stream of bytes</returns>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Tools.Compress.ProgressCounter">
            <summary>
            Progress counter event
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Tools.Compress.ArchiveHeader">
            <summary>
            Get: The working archive header
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormat">
            <summary>
            Get: The compression algorithm used to compress a file
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Tools.Compress.FolderOption">
            <summary>
            Get: The working archive header
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionHeader">
            <summary>
            The compression header structure
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionHeader.Format">
            <summary>
            The compression format
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionHeader.FileCount">
            <summary>
            The number of compressed files
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionHeader.NameSize">
            <summary>
            Length of an array of file names
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionHeader.FileSizes">
            <summary>
            An array containing the size of each file in the archive
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionHeader.FileNames">
            <summary>
            An array containing the nameand subfolder path of each file in the archive
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionHeader.#ctor(System.Int32,System.Int32,System.Int64[],System.Char[],VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats)">
            <summary>
            Initialize the CompressionHeader structure
            </summary>
            
            <param name="FileCount">The number of compressed files</param>
            <param name="NameSize">Length of an array of file names</param>
            <param name="FileSizes">An array containing the size of each file in the archive</param>
            <param name="FileNames">An array containing the name and subfolder path of each file in the archive</param>
            <param name="Format">The compression format</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats">
            <summary>
            Compression types
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats.None">
            <summary>
            No compression
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats.Deflate">
            <summary>
            Deflate algorithm
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Tools.Compress.CompressionFormats.GZip">
            <summary>
            Gzip algorithm
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.Compress.ProgressCounterDelegate">
            <summary>
            Progress counter delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress changed arguments</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC">
            <summary>
            <h3>SHA512 Hash based Message Authentication Code Wrapper using SHA-2 512.</h3>
            <para>A SHA512 HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new SHA512HMAC(), [DisposeEngine])
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>; 64 bytes, (512 bits).</description></item>
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 64 bytes, (512 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>NIST Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>NIST Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Boolean)">
            <summary>
            Initialize the class
            <para>When using this constructor, you must call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> before processing.</para>
            </summary>
            
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if a null Key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="OutOffset">The offset in the data</param>
            
            <returns>The number of bytes processed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the HMAC.
            <para>Uses the Key field of the KeyParams class.</para>
            </summary>
            
            <param name="KeyParam">KeyParams containing HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class.
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DigestSize"/></para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA512HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams">
            <summary>
            A Cipher Key and Vector Container class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.#ctor(System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key
            </summary>
            
            <param name="Key">Cipher Key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.#ctor(System.Byte[],System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key and IV.
            </summary>
            
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the class with a Cipher Key, IV, and IKM.
            </summary>
            
            <param name="Key">Cipher Key</param>
            <param name="IV">Cipher IV</param>
            <param name="IKM">IKM value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.DeSerialize(System.IO.Stream)">
            <summary>
            Deserialize a KeyParams class
            </summary>
            
            <param name="KeyStream">Stream containing the KeyParams data</param>
            
            <returns>A populated KeyParams class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.Serialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Serialize a KeyParams class
            </summary>
            
            <param name="KeyObj">A KeyParams class</param>
            
            <returns>A stream containing the KeyParams data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.Clone">
            <summary>
            Create a shallow copy of this KeyParams instance
            </summary>
            
            <returns>The KeyParams copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.DeepCopy">
            <summary>
            Create a deep copy of this KeyParams instance
            </summary>
            
            <returns>The KeyParams copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.IKM">
            <summary>
            Input Key Material
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.Key">
            <summary>
            Cipher Key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams.IV">
            <summary>
            Cipher Initialization Vector
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1">
            <summary>
            <h3>An implementation of a Quadratic Congruential Generator I random number generator: QCG-I</h3>
            <para>Implements QCGI as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.2</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new QCG1())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">QuadraidResidue1Prng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Prime and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="P">Random Prime with probability &lt; 2 ** -100</param>
            <param name="G">Random Generator State</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if P is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.QCG1.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG">
            <summary>
            <h3>An implementation of a Blum-Blum-Shub random number generator.</h3>
            <para>Implements BBSG as defined in the NIST document: SP800-22 1a<cite>SP800-22A</cite>, Section D.8</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new BBSG())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-22 1a, Section D.3: A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            <item><description>Cryptographic Secure Pseudo-Random Bits Generation: <cite>Blum-Blum-Shub</cite>The Blum-Blum-Shub Generator.</description></item>
            <item><description>Handbook of Applied Cryptography Chapter 5<cite>Handbook of Applied Cryptography</cite>: Pseudorandom Bits and Sequences.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>This code based on the excellent Java version by Zur Aougav: <see href="http://sourceforge.net/projects/jrandtest/">BBSPrng</see> class.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BitLength">Length of integers used in equations, must be at least 512 bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Initialize class with Primes, and State Seed values. Values must be probable primes.
            </summary>
            
            <param name="X">Random Generator State (X = X ** 2 mod N)</param>
            <param name="P">P Random Prime</param>
            <param name="Q">Q Random Prime</param>
            <param name="N">Random Prime (N = P * Q)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if P or Q is not a valid prime</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.BBSG.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">
            <summary>
            KeyPolicy enumeration flags stored in a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/> structure. 
            <para>Used to define how the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory"/> class manages access to a key package file.
            Values can be combined, and tested with the PackageKey HasPolicy(group, policy), SetPolicy(package, index, policy) and ClearPolicy(package, index, policy) methods.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.None">
            <summary>
            No change to policy is applied. Will not change an existing policy, to clear a policy flag use the ClearPolicy(group, policy) method in PackageKey
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.SingleUse">
            <summary>
            Key package subkeys are only valid for only one cycle of decryption, after which the key is locked out
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.Volatile">
            <summary>
            Key package is time sensitive. Expiration date (Ticks) of key is assigned to the OptionFlag in a PackageKey structure
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.PostOverwrite">
            <summary>
            Key package subkeys are valid for only one cycle of decryption, after which the sub-key set is erased in the key package file.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.NoNarrative">
            <summary>
            An operator may be able to decrypt a file with this key, but information within the key package header should be considered sensitive
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.DomainRestrict">
            <summary>
            Use of this key will be restricted to the domain id contained in the PackageKey structures DomainId parameter.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.IdentityRestrict">
            <summary>
            Domain id is set as the targets unique identity field, use is restricted to that node. Overrides the DomainRestrict flag.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.NoExport">
            <summary>
            The key package may only be used by the creator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.MasterAuth">
            <summary>
            Master authenticator; key packages created with this flag can be used for encryption by anyone. Should be combined with identity or domain restrict flags, 
            and only be used for centralized key generation within a secured network or group framework.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.PackageAuth">
            <summary>
            If this flag is set, the PackageKey.KeyAuthority:TargetId field is set to the targets OriginId, and used to authenticate the operator. This is an encryption flag.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX">
            <summary>
            <h3>TFX: An extended implementation of the Twofish encryption cipher.</h3>
            <para>TFX is an implementation of the Twofish<cite>Twofish</cite> block cipher, extended to use a 512 bit key.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new TFX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256 and 512 bits (16, 24, 32 and 64 bytes).</description></item>
            <item><description>Block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>TFX extends the original design allowing it to accept the longer key length (512 bits).</para>
            
            <para>The number of diffusion rounds processed in the ciphers transformation method has also been extended, and is user configurable; 
            from the original 16 rounds, to a full 32 rounds of transformation. 
            This increase in key size eliminates brute force attacks, and the increase in the number of diffusion rounds makes cryptanalysis far more difficult.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">A 128-Bit Block Cipher</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher">
            <summary>
            Block Cipher Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. The LegalKeySizes property contains valid sizes</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalRounds"/> property contains available sizes. Default is 16 rounds.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TFX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX">
            <summary>
            <h3>RDX: An extended implementation of the Rijndael encryption cipher.</h3>
            <para>RDX is an implementation of the Rijndael<cite>Rijndael</cite> encryption algorithm, extended to use a 512 bit key</para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RDX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/10" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256, and 512 bit.</description></item>
            <item><description>Valid block sizes are 16 and 32 bytes wide.</description></item>
            </list>
            
            <para>RDX is an implementation of the Rijndael<cite>Rijndael</cite> encryption algorithm, the same one used in the AES<cite>Fips 197</cite> standard. 
            What has been done is to extend Rijndael so that it now accepts the longer key length (512 bits). 
            The extended key length provides more security against attacks that attempt to brute force the key, and also adds eight more rounds of diffusion.</para>
            
            <para>The increased number of rounds brings the total from 14 rounds with a 256 bit key, to 22 rounds with the 512 bit key size. 
            These added passes through the rounds function further disperse the input through row and column transpositions, and XORs with a longer expanded key array.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>AES Proposal: <see href="http://csrc.nist.gov/archive/aes/rijndael/Rijndael-ammended.pdf">Rijndael</see>.</description></item>
            <item><description>Fips 197: Announcing the <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">Advanced Encryption Standard (AES)</see></description></item>
            </list> 
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.#ctor(System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalBlockSizes"/> property contains available sizes. Default is 16 bytes.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid block size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RDX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion">
            <summary>
            <h3>Fusion: An implementation of the Twofish and Rijndael Merged ciphers, extended with an HKDF powered Key Schedule.</h3>
            <para>Fusion is a parallelized stream cipher; it encrypts a random 128 bit counter to create a key stream, used to transform the input data.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new Fusion())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/05/14" version="1.3.5.0">Added the IV property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>The pseudo random generator used to create the key stream is a combination of the Rijndael<cite>Rijndael</cite> and Twofish<cite>Twofish</cite> ciphers:
            In the Transform functions rounds loop, a round of Twofish is processed; the permuted product of that transformation is then transformed again by a full round of Rijndael.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and creates a cipher 
            that is very resistant to cryptanalysis.</para>
            
            <para>The key schedule in Fusion powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RHX is capable of processing up to thirty-two rounds, that is eighteen rounds more than the fourteen rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalRounds"/> property contains available sizes. Default is 16 rounds.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalKeySizes"/> property contains valid sizes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid key or iv is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offsets and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Generate(System.Int32,System.Byte[])">
            <remarks>
            Generate an array of pseudo random bytes
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Increment(System.Byte[])">
            <remarks>
            Incremental counter with carry
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Increase(System.Byte[],System.Int32)">
            <remarks>
            Increase a byte array by a numerical value
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key
            <para>Default is the digest return size; can only be a multiple of that length</para>
            </summary>
            
            <remarks>
            This is an advanced option, hidden for that reason
            </remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.IsParallel">
            <summary>
            Get/Set: Enable processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Fusion.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSUtil">
            <summary>
            This class provides several methods that are required by the GMSS classes
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSUtil.IntToBytesLittleEndian(System.Int32)">
            <summary>
            Converts a 32 bit integer into a byte array beginning at <c>offset</c> (little-endian representation)
            </summary>
            
            <param name="Value">The value the integer to convert</param>
            
            <returns>Converted value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSUtil.BytesToIntLittleEndian(System.Byte[])">
            <summary>
            Converts a byte array beginning at <c>offset</c> into a 32 bit integer (little-endian representation)
            </summary>
            
            <param name="Bytes">The byte array</param>
            
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSUtil.BytesToIntLittleEndian(System.Byte[],System.Int32)">
            <summary>
            Converts a byte array beginning at <c>offset</c> into a 32 bit integer (little-endian representation)
            </summary>
            
            <param name="Bytes">The byte array</param>
            <param name="Offset">The integer offset into the byte array</param>
            
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSUtil.ConcatenateArray(System.Byte[][])">
            <summary>
            This method concatenates a 2-dimensional byte array into a 1-dimensional byte array
            </summary>
            
            <param name="Arraycp">A 2-dimensional byte array.</param>
            
            <returns>Returns 1-dimensional byte array with concatenated input array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSUtil.TestPowerOfTwo(System.Int32)">
            <summary>
            This method tests if an integer is a power of 2
            </summary>
            
            <param name="Value">An integer</param>
            
            <returns>Return <c>true</c> if <c>testValue</c> is a power of 2, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSUtil.GetLog(System.Int32)">
            <summary>
            This method returns the least integer that is greater or equal to the logarithm to the base 2 of an integer <c>intValue</c>.
            </summary>
            
            <param name="Value">an integer</param>
            
            <returns>return The least integer greater or equal to the logarithm to the base 2 of <c>Value</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator">
            <summary>
            This class implements key pair generation of the Ring-LWE Public Key Cryptosystem
            </summary>
            <example>
            <description>Example of creating a keypair:</description>
            <code>
            RLWEParameters ps = RLWEParamSets.RLWEN512Q12289;
            RLWEKeyGenerator gen = new RLWEKeyGenerator(ps);
            IAsymmetricKeyPair kp = gen.GenerateKeyPair();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/07" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE RLWEEncrypt Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE RLWEPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE RLWEPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Efficient Software Implementation of Ring-LWE Encryption<cite>Ring-LWE Encryption</cite>.</description></item>
            <item><description>Compact Ring-LWE Cryptoprocessor<cite>Ring-LWE Cryptoprocessor</cite>.</description></item>
            <item><description>A Simple Provably Secure Key Exchange Scheme Based on the Learning with Errors Problem<cite>RLWE Scheme</cite>.</description></item>
            <item><description>The Knuth-Yao Quadrangle-Inequality Speedup is a Consequence of Total-Monotonicity<cite>Knuth-Yao Quadrangle-Inequality Speedup</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Ring-LWE-Encryption C version: <see href="https://github.com/ruandc/Ring-LWE-Encryption">ruandc/Ring-LWE-Encryption</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricGenerator">
            <summary>
            The Asymmertic Generator interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricGenerator.GenerateKeyPair">
            <summary>
            Generate an asymmetric Key pair
            </summary>
            
            <returns>An asymmetric containing public and private keys</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricGenerator.Name">
            <summary>
            Get: The generators name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters,System.Boolean)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The RLWEParameters instance containing the cipher settings</param>
            <param name="Parallel">Use parallel processing when generating a key; set to false if using a passphrase type generator (default is true)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if a Prng that requires pre-initialization is specified; (wrong constructor)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,System.Boolean)">
            <summary>
            Use an initialized prng to generate the key; use this constructor with an Rng that requires pre-initialization, i.e. PBPrng
            </summary>
            
            <param name="CipherParams">The RLWEParameters instance containing the cipher settings</param>
            <param name="RngEngine">An initialized Prng instance</param>
            <param name="Parallel">Use parallel processing when generating a key; set to false if using a passphrase type generator (default is true)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.GenerateKeyPair">
            <summary>
            Generate an encryption Key pair
            </summary>
            
            <returns>A RLWEKeyPair containing public and private keys</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.GenerateKeyPair(System.Byte[],System.Byte[])">
            <summary>
            Generates an encryption key pair using a passphrase based prng.
            <para>Invoking this method with the same passphrase and salt will always return the same key pair.</para>
            </summary>
            
            <param name="Passphrase">The passphrase</param>
            <param name="Salt">Salt for the passphrase; can be <c>null</c> but this is strongly discouraged</param>
            
            <returns>A populated IAsymmetricKeyPair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyGenerator.Name">
            <summary>
            Get: Generator name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2">
            <summary>
            This class describes operations with polynomials over finite field GF(2), i e polynomial ring R = GF(2)[X].
            <para>All operations are defined only for polynomials with degree &lt;=32.
            For the polynomial representation the map f: R-&gt;Z, poly(X)-&gt;poly(2) is used,
            where integers have the binary representation.
            For example: X^7+X^3+X+1 -&gt; (00...0010001011)=139 Also for polynomials type Integer is used.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.#ctor">
            <summary>
            Default constructor (private)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.Add(System.Int32,System.Int32)">
            <summary>
            Return sum of two polyomials
            </summary>
            
            <param name="P">The P polynomial</param>
            <param name="Q">The Q polynomial</param>
            
            <returns>Returns <c>P+Q</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.Degree(System.Int32)">
            <summary>
            Return the degree of a polynomial
            </summary>
            
            <param name="P">The polynomial</param>
            
            <returns>Returns Degree(p)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.Degree(System.Int64)">
            <summary>
            Return the degree of a long polynomial
            </summary>
            
            <param name="P">The polynomial</param>
            
            <returns>Returns Degree(p)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.Gcd(System.Int32,System.Int32)">
            <summary>
            Return the greatest common divisor of two polynomials
            </summary>
            
            <param name="P">The P polynomial</param>
            <param name="Q">The Q polynomial</param>
            
            <returns>Returns Gcd(p, q)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.GetIrreduciblePolynomial(System.Int32)">
            <summary>
            Creates irreducible polynomial with Degree
            </summary>
            
            <param name="Degree">The polynomial degree</param>
            
            <returns>Returns the irreducible polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.IsIrreducible(System.Int32)">
            <summary>
            Checking polynomial for irreducibility
            </summary>
            
            <param name="P">The polinomial</param>
            
            <returns>Returns true if p is irreducible and false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.ModMultiply(System.Int32,System.Int32,System.Int32)">
            <summary>
            Compute the product of two polynomials modulo a third polynomial
            </summary>
            
            <param name="A">The first polynomial</param>
            <param name="B">The second polynomial</param>
            <param name="R">The reduction polynomial</param>
            
            <returns>Returns <c>a * b mod r</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.Multiply(System.Int32,System.Int32)">
            <summary>
            Return product of two polynomials
            </summary>
            
            <param name="P">The P polynomial</param>
            <param name="Q">The Q polynomial</param>
            
            <returns>Returns <c>P*Q</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.Remainder(System.Int32,System.Int32)">
            <summary>
            Return the remainder of a polynomial division of two polynomials
            </summary>
            
            <param name="P">The dividend</param>
            <param name="Q">The divisor</param>
            
            <returns>Returns <c>P mod Q</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2.Rest(System.Int64,System.Int32)">
            <summary>
            Return the resultant of division two polynomials
            </summary>
            
            <param name="P">The P polynomial</param>
            <param name="Q">The Q polynomial</param>
            
            <returns>The rest value</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage">
            <summary>
            The DtmMessage structure.
            <para>The DtmMessage structure is a header that encapsulates encrypted messages; it contains describe the payload and padding.</para>
            </summary>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmParameters class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmClient structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmIdentity structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmPacket structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmSession structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmKex class</seealso>
            
            <revisionHistory>
            <revision date="2015/05/23" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.MessageAppend">
            <summary>
            The maximum number of pseudo-random bytes to append to a message before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.MessagePrePend">
            <summary>
            The maximum number of pseudo-random bytes to prepend to a message before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.OptionsFlag">
            <summary>
            Flag used to identify the type of payload and options
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.#ctor(System.Int32,System.Int32,System.Int64)">
            <summary>
            The DtmMessage primary constructor
            </summary>
            
            <param name="MessageAppend">The number of pseudo-random bytes to append to a message before encryption</param>
            <param name="MessagePrePend">The number of pseudo-random bytes to prepend to a message before encryption</param>
            <param name="OptionsFlag">Flag used to identify the type of payload and options</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.#ctor(System.Byte[])">
            <summary>
            Constructs a DtmMessage from a byte array
            </summary>
            
            <param name="MessageArray">The byte array containing the DtmMessage structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.#ctor(System.IO.Stream)">
            <summary>
            Constructs a DtmIdentity from a stream
            </summary>
            
            <param name="MessageStream">Stream containing a serialized DtmMessage</param>
            
            <returns>A populated DtmMessage</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.DeSerialize(System.IO.Stream)">
            <summary>
            Deserialize an DtmMessage
            </summary>
            
            <param name="MessageStream">Stream containing a serialized DtmMessage</param>
            
            <returns>A populated DtmMessage</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.Serialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage)">
            <summary>
            Serialize an DtmMessage structure
            </summary>
            
            <param name="Message">A DtmMessage structure</param>
            
            <returns>A stream containing the DtmMessage data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.ToBytes">
            <summary>
            Returns the DtmMessage as an encoded byte array
            </summary>
            
            <returns>The serialized DtmMessage</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage.ToStream">
            <summary>
            Returns the DtmMessage as an encoded MemoryStream
            </summary>
            
            <returns>The serialized DtmMessage</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs">
            <summary>
            An event arguments class containing the identity of a client.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs.Message">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags"/> (Auth or Primary), from which this message originated
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs.Flag">
            <summary>
            The option flag containing the clients proposed Asymmetric parameters OId
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs.DtmID">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/> containing identity and session parameters
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs.Cancel">
            <summary>
            The Cancel token; setting this value to true instructs the server to shutdown the exchange (Terminate)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmExchangeFlags,System.Int64,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity)">
            <summary>
            The identity exchanged event args constructor; contains the identity and Asymmetric parameters OId from an Identity structure
            </summary>
            
            <param name="Message">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags"/> (Auth or Primary), from which this message originated</param>
            <param name="Flag">An option flag that contains the clients Asymmetric parameters OId</param>
            <param name="DtmID">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/> containing identity and session parameters</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ParallelUtils">
            <summary>
            A utility class for parallel processing
            <para>Portions based on: http://blogs.msdn.com/b/pfxteam/archive/2009/08/12/9867246.aspx</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.Loop(System.Threading.Tasks.ParallelOptions,System.Func{System.Boolean},System.Action{System.Threading.Tasks.ParallelLoopState})">
            <summary>
            An infinite parallel loop function
            </summary>
            
            <param name="Options">The parallel options</param>
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.While(System.Threading.Tasks.ParallelOptions,System.Func{System.Boolean},System.Action{System.Threading.Tasks.ParallelLoopState})">
            <summary>
            A parallel While function
            </summary>
            
            <param name="Options">The parallel options</param>
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.While(System.Func{System.Boolean},System.Action)">
            <summary>
            A parallel While function
            </summary>
            
            <param name="Condition">The while conditional</param>
            <param name="Body">The functions body</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.ForceLinear">
            <summary>
            Get/Set: Force uni-processing (IsParallel returns false)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Utility.ParallelUtils.IsParallel">
            <summary>
            Get: Returns true for multi processor system
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.HexConverter">
            <summary>
            A Hexadecimal conversion helper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.ToString(System.Byte[])">
            <summary>
            Convert an array into a hex string
            </summary>
            
            <param name="Data">Data to convert</param>
            
            <returns>Data as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.Encode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Encode an array of bytes in hexadecimal format
            </summary>
            
            <param name="Data">The bytes to encode</param>
            <param name="Offset">The starting offset within the Data array</param>
            <param name="Length">The number of bytes to encode</param>
            
            <returns>Encode bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.HexConverter.Decode(System.String)">
            <summary>
            Decode a Hex encoded string and return the output
            </summary>
            
            <param name="Data">Hex string</param>
            
            <returns>Decoded bytes</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Primality">
            <summary>
            Provides primality probabilistic methods
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            It uses the sieve of Eratosthenes to discard several composite numbers in 
            some appropriate range (at the moment [this, this + 1024]).
            <para>After this process it applies the Miller-Rabin test to the numbers that were not discarded in the sieve.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.ConsBigInteger(System.Int32,System.Int32,System.Random)">
            <summary>
            A random number is generated until a probable prime number is found
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.ConsBigInteger(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            A random number is generated until a probable prime number is found
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Primality.IsProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Tests whether this BigInteger is probably prime.
            <para>If true is returned, then this is prime with a probability beyond <c>(1-1/2^certainty)</c>.
            If false is returned, then this is definitely composite.
            If the argument Certainty &lt;= 0, then this method returns true.</para>
            </summary>
            
            <param name="X">BigInteger to test</param>
            <param name="Certainty">Tolerated primality uncertainty</param>
            
            <returns>Returns true, if this is probably prime, false  otherwise</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">
            <summary>
            Wraps exceptions thrown within a Symmetric cipher operational context.
            <para>This exception is used throughout the Block and Stream cipher domain, including Mode and Padding classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">
            <summary>
            Wraps exceptions thrown within a Cryptographic Generator operational context.
            <para>This exception is used throughout the Generator classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg">
            <summary>
            Generates seed material for a CSPrng using various processed system counters passed through an XorShift+ generator.
            <para>An original construct (experimental) meant to provide an alternative to the RNGCryptoServiceProvider as a source of pseudo random seeding material.
            This class is suitable for generating seeds for a Prng or Drbg implementation.</para>
            </summary>
            
            
            <example>
            <description>Example of getting a seed value:</description>
            <code>
            byte[] seed;
            using (XSPRsg rnd = new XSPRsg())
                seed = rnd.GetSeed(48);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Prng">VTDev.Libraries.CEXEngine.Crypto Prng Classes</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <para>The seed generator uses system counters and state information, that are pre-processed via modular arithmetic, 
            converted to a byte array, and then processed with an XorShift+ random generator.
            The maximum allocation size is 1024 bytes.</para>
            
            <description>XSPGenerator uses the following state values as initial entropy sources:</description>
            <list type="bullet">
            <item><description>Network: Combined interface values for the BytesSent, UnicastPacketsSent, NonUnicastPacketsSent, BytesReceived, UnicastPacketsReceived and NonUnicastPacketsReceived values.</description></item>
            <item><description>Current Process: Handle, StartTime ticks, PeakWorkingSet64, NonpagedSystemMemorySize64, PagedSystemMemorySize64, HandleCount, and Id.</description></item>
            <item><description>Combined running processes and threads: WorkingSet64, VirtualMemorySize64, StartAddress, Id, and CurrentPriority.</description></item>
            <item><description>Environment: Ticks since startup, the Time in Ticks.</description></item>
            <item><description>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed">
            <summary>
            The Seed Generator interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed.GetSeed(System.Int32)">
            <summary>
            Get a pseudo random seed byte array
            </summary>
            
            <param name="Size">The size of the seed returned; up to a maximum of 1024 bytes</param>
            
            <returns>A pseudo random seed</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.ISeed.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Initialize">
            <summary>
            Re-initializes the generator with new state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.GetSeed(System.Int32)">
            <summary>
            Get a pseudo random seed byte array
            </summary>
            
            <param name="Size">The size of the seed returned; up to a maximum of 1024 bytes</param>
            
            <returns>A pseudo random seed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if the requested size exceeds maximum allowable allocation (1024 bytes)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.XSPRsg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes">
            <summary>
            Cipher Modes
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes.CBC">
            <summary>
            Cipher Block Chaining Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes.CFB">
            <summary>
            Cipher FeedBack Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes.CTR">
            <summary>
            SIC Counter Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes.OFB">
            <summary>
            Output FeedBack Mode
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes">
            <summary>
            <para>Block cipher sizes in bits. Can be cast as Block byte size integers, 
            i.e. (int sz = BlockSizes.B512) is equal to 64.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes.B128">
            <summary>
            128 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes.B256">
            <summary>
            256 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes.B512">
            <summary>
            512 bit block size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes.B1024">
            <summary>
            1024 bit block size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType">
            <summary>
            Specifies the Skein initialization type.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.Normal">
            <summary>
            Identical to the standard Skein initialization.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ZeroedState">
            <summary>
            Creates the initial state with zeros instead of the configuration block, then initializes the hash.
            This does not start a new UBI block type, and must be done manually.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ChainedState">
            <summary>
            Leaves the initial state set to its previous value, which is then chained with subsequent block transforms.
            This does not start a new UBI block type, and must be done manually.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType.ChainedConfig">
            <summary>
            Creates the initial state by chaining the previous state value with the config block, then initializes the hash.
            This starts a new UBI block type with the standard Payload type.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType">
            <summary>
            The Unique Block Iteration (UBI) options
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Key">
            <summary>
            A key that turns Skein into a MAC or KDF function.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Config">
            <summary>
            The configuration block.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Personalization">
            <summary>
            A string that applications can use to create different functions for different uses.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.PublicKey">
            <summary>
            Used to hash the public key when hashing a message for signing.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.KeyIdentifier">
            <summary>
            Used for key derivation.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Nonce">
            <summary>
            Nonce value for use in stream cipher mode and randomized hashing.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Message">
            <summary>
            The normal message input of the hash function.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType.Out">
            <summary>
            The output transform.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak">
            <summary>
            <para>The Unique Block Iteration (UBI) implementations, <see href="https://www.schneier.com/skein1.3.pdf">section 2.3</see>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.StartNewBlockType(VTDev.Libraries.CEXEngine.Crypto.Digest.UbiType)">
            <summary>
            Starts a new UBI block type by setting BitsProcessed to zero, setting the first flag, and setting the block type.
            </summary>
            <param name="type">The UBI block type of the new block</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.IsFirstBlock">
            <summary>
            Gets or sets the first block flag.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.IsFinalBlock">
            <summary>
            Gets or sets the final block flag.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.TreeLevel">
            <summary>
            Gets or sets the current tree level.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.BitsProcessed">
            <summary>
            Gets or sets the number of bits processed so far, inclusive.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.BlockType">
            <summary>
            Gets or sets the current UBI block type.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.UbiTweak.Tweak">
            <summary>
            The current Threefish tweak value.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256">
            <summary>
            <h3>Skein256: An implementation of the Skein digest with a 256 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/03/10" version="1.3.0.0">Added Initialize call to Ctor</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 32 bytes, (256 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> to reinitialize.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance.
            </summary>
            
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value.
            <para>Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Used to re-initialize the digest state.
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ConfigValue">
            <summary>
            The post-chain configuration value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.ConfigString">
            <summary>
            The pre-chain configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein256.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512">
            <summary>
            <h3>Keccak512: An implementation of the SHA-3 Keccak digest.</h3>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak512())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 48 and 64 bytes (384 and 512 bits).</description></item>
            <item><description>Block sizes are 104, and 72 bytes (832, 576 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak512.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256">
            <summary>
            <h3>Blake256: An implementation of the Blake digest with a 256 bit return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Blake<cite>Blake</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Blake256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 32 bytes, (256 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 Proposal <see href="https://131002.net/blake">Blake</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            <item><description>SHA3 Submission in C: <see href="https://131002.net/blake/blake_ref.c">blake_ref.c</see>.</description></item>
            <item><description>The: <see href="http://hashlib.codeplex.com/">HashLib</see> Project (test vectors).</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent project by Dominik Reichl: <see href="http://www.codeproject.com/Articles/286937/BlakeSharp-A-Csharp-Implementation-of-the-BLAKE-Ha">Blake Sharp</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.#ctor">
            <summary>
            Initialize the class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Blake256.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc">
            <summary>
            This class computes a whole Merkle tree and saves the needed values for AuthPath computation.
            It is used for precomputation of the root of a following tree. 
            After initialization, 2^H updates are required to complete the root. 
            Every update requires one leaf value as parameter. 
            While computing the root all initial values for the authentication path algorithm 
            (treehash, auth, retain) are stored for later use.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[][],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash[],System.Collections.Generic.List{System.Byte[]}[])">
            <summary>
            This constructor regenerates a prior treehash object
            </summary>
            
            <param name="Digest">The hash function</param>
            <param name="StatByte">The status bytes</param>
            <param name="StatInt">The  status ints</param>
            <param name="TreeH">The tree hash</param>
            <param name="NodeRet">The retained nodes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest)">
            <summary>
            Inialize this class
            </summary>
            
            <param name="HeightOfTree"> maximal height of the tree</param>
            <param name="K">The K value</param>
            <param name="Digest">The hash function</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.Initialize(System.Collections.Generic.List{System.Byte[]})">
            <summary>
            Initializes the calculation of a new root
            </summary>
            
            <param name="SharedStack">The stack shared by all treehash instances of this tree</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.Update(System.Byte[],System.Byte[])">
            <summary>
            Updates the root with one leaf and stores needed values in retain,
            treehash or authpath. Additionally counts the seeds used. 
            This method is used when performing the updates for TREE++.
            </summary>
            
            <param name="Seed">The initial seed for treehash: seedNext</param>
            <param name="Leaf">The height of the treehash</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.Update(System.Byte[])">
            <summary>
            Updates the root with one leaf and stores the needed values in retain, treehash or authpath
            </summary>
            
            <param name="Leaf">The height of the treehash</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.InitializeTreehashSeed(System.Byte[],System.Int32)">
            <summary>
            Initializes the seeds for the treehashs of the tree precomputed by this class
            </summary>
            
            <param name="Seed">The initial seed for treehash: seedNext</param>
            <param name="Index">The height of the treehash</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.IsInitialized">
            <summary>
            Method to check whether the instance has been initialized or not
            </summary>
            
            <returns>Return true if treehash was already initialized</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.IsFinished">
            <summary>
            Method to check whether the instance has been finished or not
            </summary>
            
            <returns>Return true if tree has reached its maximum height</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.GetAuthPath">
            <summary>
            Returns the authentication path of the first leaf of the tree
            </summary>
            
            <returns>The authentication path of the first leaf of the tree</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.GetTreehash">
            <summary>
            Returns the initial treehash instances, storing value y_3(i)
            </summary>
            
            <returns>The initial treehash instances, storing value y_3(i)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.GetRetain">
            <summary>
            Returns the retain stacks storing all right nodes near to the root
            </summary>
            
            <returns>The retain stacks storing all right nodes near to the root</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.GetRoot">
            <summary>
            Returns the finished root value
            </summary>
            
            <returns>The finished root value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.GetStack">
            <summary>
            Returns the shared stack
            </summary>
            
            <returns>The shared stack</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.GetStatByte">
            <summary>
            Returns the status byte array used by the GMSSPrivateKeyASN.1 class
            </summary>
            
            <returns>The status bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.GetStatInt">
            <summary>
            Returns the status int array used by the GMSSPrivateKeyASN.1 class
            </summary>
            
            <returns>The status ints</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootCalc.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.Arithmetic.NTT512.#ctor(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Rand">The secure random number generator instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.Arithmetic.NTT512.Decrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey,System.Byte[])">
            <summary>
            Decrypt a ciphertext
            </summary>
            
            <param name="PrivateKey">The RLWE private key</param>
            <param name="Message">The encrypted message</param>
            
            <returns>The decrypted message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.Arithmetic.NTT512.Encrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey,System.Byte[])">
            <summary>
            Encrypt a message
            </summary>
            
            <param name="PublicKey">The RLWE public key</param>
            <param name="Message">The message array to encrypt</param>
            
            <returns>The encrypted message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.Arithmetic.NTT512.Generate">
            <summary>
            Generate a RLWE key pair
            </summary>
            
            <returns>An initialized RLWE KeyPair</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.PolynomialGenerator">
            <summary>
            Generates a sparse or dense mode polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.PolynomialGenerator.GenerateRandomTernary(System.Int32,System.Int32,System.Int32,System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a "sparse" or "dense" polynomial containing numOnes ints equal to 1,
            numNegOnes int equal to -1, and the rest equal to 0.
            </summary>
            
            <param name="N">Number of coeffeients</param>
            <param name="NumOnes">Number of ones</param>
            <param name="NumNegOnes">Number of negative ones</param>
            <param name="Sparse">Create a SparseTernaryPolynomial or DenseTernaryPolynomial</param>
            <param name="Rng">Random number generator</param>
            
            <returns>A ternary polynomial</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial">
            <summary>
            A polynomial with {@link BigInteger} coefficients.
            <para>Some methods (like <c>add</c>) change the polynomial, others (like <c>mult</c>) do not,
            but return the result as a new polynomial.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Coeffs">
            <summary>
            should be marked as internal
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.#ctor(System.Int32)">
            <summary>
            Constructs a new polynomial with <c>N</c> coefficients initialized to 0.
            </summary>
            
            <param name="N">The number of coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Constructs a new polynomial with a given set of coefficients.
            </summary>
            
            <param name="Coeffs">The coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>BigIntPolynomial</c> from a <c>IntegerPolynomial</c>. The two polynomials are
            independent of each other.
            </summary>
            
            <param name="P">The original polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Adds another polynomial which can have a different number of coefficients.
            </summary>
            
            <param name="B">The polynomial to add</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Clear">
            <summary>
            Clear the Coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Clone">
            <summary>
            Makes a copy of the polynomial that is independent of the original.
            </summary>
            <returns>The cloned polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Divide(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Divides each coefficient by a <c>BigInteger</c> and rounds the result to the nearest whole number.
            <para>Does not return a new polynomial but modifies this polynomial.</para>
            </summary>
            
            <param name="Divisor">The divisor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32)">
            <summary>
            Divides each coefficient by a <c>BigDecimal</c> and rounds the result to <c>decimalPlaces</c> places.
            </summary>
            
            <param name="Divisor">The divisor</param>
            <param name="DecimalPlaces">The number of fractional digits to round the result to</param>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.GetMaxCoeffLength">
            <summary>
            Returns the base10 length of the largest coefficient.
            </summary>
            
            <returns>Length of the longest coefficient</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Mod(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Takes each coefficient modulo a number.
            </summary>
            
            <param name="Modulus">The modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Multiplies each coefficient by a <c>BigInteger</c>. Does not return a new polynomial but modifies this polynomial.
            </summary>
            
            <param name="Factor">The polynomial factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.MultBig(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by another, taking the indices mod N.
            <para>Does not change this polynomial but returns the result as a new polynomial.
            Both polynomials must have the same number of coefficients.
            This method is designed for large polynomials and uses Schnhage-Strassen multiplication
            in combination with <a href="http://en.wikipedia.org/wiki/Kronecker_substitution">Kronecker substitution</a>.
            See <a href="http://math.stackexchange.com/questions/58946/karatsuba-vs-schonhage-strassen-for-multiplication-of-polynomials#58955">here</a> for details.</para>
            </summary>
            
            <param name="Factor">The polynomial to multiply by</param>
            
            <returns>The product polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.MultSmall(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by another, taking the indices mod N.
            <para>Does not change this polynomial but returns the result as a new polynomial.
            Both polynomials must have the same number of coefficients.
            This method is designed for smaller polynomials and uses 
            <a href="http://en.wikipedia.org/wiki/Karatsuba_algorithm">Karatsuba multiplication</a>.</para>
            </summary>
            
            <param name="Factor">he polynomial to multiply by</param>
            
            <returns>The product polynomial</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Throws if the two polynomials have a different number of coefficients</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Subtracts another polynomial which can have a different number of coefficients.
            </summary>
            
            <param name="B">The polynomial to subtract</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.GetHashCode">
            <summary>
            Get the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial.Equals(System.Object)">
            <summary>
            Compare this big integer polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey">
            <summary>
            A McEliece Private Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM[])">
            <summary>
            Initialize this class for CCA2 MPKCS
            </summary>
            
            <param name="N">Length of the code</param>
            <param name="K">The dimension of the code</param>
            <param name="Gf">The finite field <c>GF(2^m)</c></param>
            <param name="Gp">The irreducible Goppa polynomial</param>
            <param name="P">The permutation</param>
            <param name="H">The canonical check matrix</param>
            <param name="QInv">The matrix used to compute square roots in <c>(GF(2^m))^t</c></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.#ctor(System.Int32,System.Int32,System.Byte[],System.Byte[],System.Byte[],System.Byte[],System.Byte[][])">
            <summary>
            Initialize this class CCA2 MPKCS using encoded byte arrays
            </summary>
            
            <param name="N">Length of the code</param>
            <param name="K">The dimension of the code</param>
            <param name="Gf">Encoded field polynomial defining the finite field <c>GF(2^m)</c></param>
            <param name="Gp">Encoded irreducible Goppa polynomial</param>
            <param name="P">The encoded permutation</param>
            <param name="H">Encoded canonical check matrix</param>
            <param name="QInv">The encoded matrix used to compute square roots in <c>(GF(2^m))^t</c></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.#ctor(System.IO.Stream)">
            <summary>
            Reads a Private Key from a Stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.#ctor(System.Byte[])">
            <summary>
            Reads a Private Key from a byte array
            </summary>
            
            <param name="KeyArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.From(System.Byte[])">
            <summary>
            Read a Private key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized MPKCPrivateKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.From(System.IO.Stream)">
            <summary>
            Read a Private key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized MPKCPrivateKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.ToBytes">
            <summary>
            Converts the Private key to an encoded byte array
            </summary>
            
            <returns>The encoded MPKCPrivateKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.ToStream">
            <summary>
            Converts the MPKCPrivateKey to an encoded MemoryStream
            </summary>
            
            <returns>The Private Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the MPKCPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded MPKCPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded MPKCPrivateKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Private Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.Clone">
            <summary>
            Create a shallow copy of this MPKCPublicKey instance
            </summary>
            
            <returns>The MPKCPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.DeepCopy">
            <summary>
            Create a deep copy of this MPKCPublicKey instance
            </summary>
            
            <returns>The MPKCPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.GF">
            <summary>
            Get: Returns the finite field <c>GF(2^m)</c>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.GP">
            <summary>
            Get: Returns the irreducible Goppa polynomial
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.H">
            <summary>
            Get: Returns the canonical check matrix H
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.K">
            <summary>
            Get: Returns the dimension of the code
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.N">
            <summary>
            Get: Returns the length of the code
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.P1">
            <summary>
            Get: Returns the permutation used to generate the systematic check matrix
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.QInv">
            <summary>
            Get: Returns the matrix used to compute square roots in <c>(GF(2^m))^t</c>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey.T">
            <summary>
            Get: Returns the degree of the Goppa polynomial (error correcting capability)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt">
            <summary>
            A McEliece CCA2 Secure asymmetric cipher implementation
            </summary>
            
            <example>
            <description>Example of encrypting and decrypting an array:</description>
            <code>
            MPKCParameters ps = MPKCParamSets.MPKCFM11T40S256;
            MPKCKeyGenerator gen = new MPKCKeyGenerator(ps);
            IAsymmetricKeyPair kp = gen.GenerateKeyPair();
            
            byte[] data = new byte[48];
            byte[] enc, dec;
            
            // encrypt an array
            using (MPKCEncrypt cipher = new MPKCEncrypt(ps))
            {
                cipher.Initialize(kp.PublicKey);
                enc = cipher.Encrypt(data);
            }
            
            // decrypt the cipher text
            using (MPKCEncrypt cipher = new MPKCEncrypt(ps))
            {
                cipher.Initialize(kp.PrivateKey);
                dec = cipher.Decrypt(enc);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Enumeration AsymmetricEngines Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece MPKCPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece MPKCPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Uses the McEliece CCA2 variants; Fujisaki, KobriImai, or PointCheval ciphers.</description></item>
            <item><description>Use the MaxPlainText property to get max input size post initialization.</description></item>
            <item><description>The MaxCipherText property gives the max allowable ciphertext size post initialization.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>McEliece Handbook of Applied Cryptography: Chapter 8<cite>McEliece Handbook of Applied Cryptography</cite>.</description></item>
            <item><description>Selecting Parameters for Secure McEliece-based Cryptosystems<cite>McEliece Parameters</cite>.</description></item>
            <item><description>Weak keys in the McEliece public-key cryptosystem<cite>McEliece Weak keys</cite>.</description></item>
            <item><description>McBits: fast constant-time code-based cryptography<cite>McEliece McBits</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> versions McEliece implementation.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher">
            <summary>
            The Asymmetric cipher interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the Key for Encrypt (Public) or Decrypt (Private)
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the Public (encrypt) or Private (decryption) key</param>
            
            <exception>CryptoAsymmetricSignException Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.IsEncryption">
            <summary>
            Get: The cipher is initialized for encryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher.Name">
            <summary>
            Get: The ciphers name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The cipher engine</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the cipher is not initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the cipher is not initialized, or the input text is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.GetKeySize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Return the key size of the working key
            </summary>
            
            <param name="Key">The key</param>
            
            <returns>The size of the key</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the cipher is not initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey"/> for encryption, or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey"/> for decryption</para>
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the McEliece public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the cipher is not initialized or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.GetEngine(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="CipherParams">The cipher parameters</param>
            
            <returns>An initialized cipher</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.IsEncryption">
            <summary>
            Get: The cipher is initialized for encryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.MaxCipherText">
            <summary>
            Get: The maximum number of bytes the cipher can decrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the cipher is not initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the cipher is not initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode">
            <summary>
            This class describes decoding operations of an irreducible binary Goppa code.
            <para>A check matrix H of the Goppa code and an irreducible Goppa polynomial are used 
            the operations are worked over a finite field GF(2^m)</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.#ctor">
            <summary>
            Default constructor 
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.CreateCanonicalCheckMatrix(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Construct the check matrix of a Goppa code in canonical form from the irreducible Goppa polynomial over the finite field <c>GF(2^m)</c>.
            </summary>
            
            <param name="Field">The finite field</param>
            <param name="Gp">The irreducible Goppa polynomial</param>
            
            <returns>The new GF2Matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.ComputeSystematicForm(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Given a check matrix <c>H</c>, compute matrices <c>S</c>, <c>M</c>, and a random permutation <c>P</c> such that 
            <c>S*H*P = (Id|M)</c>. Return <c>S^-1</c>, <c>M</c>, and the systematic form of H
            </summary>
            
            <param name="H">The check matrix</param>
            <param name="SecRnd">The source of randomness</param>
            
            <returns>Returns the tuple <c>(S^-1, M, P)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.SyndromeDecode(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM[])">
            <summary>
            Find an error vector <c>E</c> over <c>GF(2)</c> from an input syndrome <c>S</c> over <c>GF(2^M)</c>
            </summary>
            
            <param name="SyndVec">The syndrome</param>
            <param name="Field">The finite field</param>
            <param name="Gp">The irreducible Goppa polynomial</param>
            <param name="SqRootMatrix">The matrix for computing square roots in <c>(GF(2M))<sup>T</sup></c></param>
            
            <returns>The error vector</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MaMaPe">
            <summary>
            This class is a container for two instances of {@link GF2Matrix} and one instance of Permutation. 
            <para>It is used to hold the systematic form <c>S*H*P = (Id|M)</c> of the check matrix <c>H</c> as
            returned by GoppaCode.ComputeSystematicForm(GF2Matrix, IRandom).</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MaMaPe.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Construct a new MaMaPe container with the given parameters
            </summary>
            
            <param name="S">The first matrix</param>
            <param name="H">The second matrix</param>
            <param name="P">The permutation</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MaMaPe.FirstMatrix">
            <summary>
            Get: Return the first matrix
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MaMaPe.SecondMatrix">
            <summary>
            Get: Return the second matrix
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MaMaPe.Permutation">
            <summary>
            Get: Return the permutation
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MatrixSet">
            <summary>
            This class is a container for an instance of GF2Matrix and one int[].
            <para>It is used to hold a generator matrix and the set of indices such that 
            the submatrix of the generator matrix consisting of the specified columns is the identity.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MatrixSet.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix,System.Int32[])">
            <summary>
            onstruct a new MatrixSet container with the given parameters
            </summary>
            
            <param name="G">The generator matrix</param>
            <param name="SetJ">The set of indices such that the submatrix of the generator matrix 
            consisting of the specified columns is the identity</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MatrixSet.G">
            <summary>
            Get: Return the generator matrix
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GoppaCode.MatrixSet.SetJ">
            <summary>
            Get: Returns the set of indices such that the submatrix of the generator 
            matrix consisting of the specified columns is the identity
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement">
            <summary>
            This abstract class implements an element of the finite field <c>GF(2)^n</c> in either 
            <c>optimal normal basis</c> representation (<c>ONB</c>) or in <c>polynomial</c> representation.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement">
            <summary>
            This interface defines a finite field element. It is implemented by the classes GFPElement and GF2nElement
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the sum of this element and the addend
            </summary>
            
            <param name="Addend">The addend</param>
            
            <returns>Returns <c>this + other</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.AddToThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the sum of this element and the addend, overwriting this element
            </summary>
            
            <param name="Addend">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.Clone">
            <summary>
            Returns a copy of this GFElement
            </summary>
            
            <returns>The element copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.Invert">
            <summary>
            Compute the multiplicative inverse of this element
            </summary>
            
            <returns>Returns <c>this<sup>-1</sup></c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.IsZero">
            <summary>
            Checks whether this element is zero
            </summary>
            
            <returns>Returns <c>true</c> if <c>this</c> is the zero element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.IsOne">
            <summary>
            Checks whether this element is one
            </summary>
            
            <returns>Returns <c>true</c> if <c>this</c> is the one element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the product of this element and <c>Factor</c>
            </summary>
            
            <param name="Factor">The factor</param>
            
            <returns>Returns <c>this * Factor</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.MultiplyThisBy(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute <c>this * Factor</c> (overwrite <c>this</c>)
            </summary>
            
            <param name="Factor">The factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the difference of this element and <c>Minuend</c>
            </summary>
            
            <param name="Minuend">he minuend</param>
            
            <returns>Returns <c>this - Minuend</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.SubtractFromThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the difference of this element and <c>minuend</c>, overwriting this element
            </summary>
            
            <param name="Minuend">The minuend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.ToByteArray">
            <summary>
            Returns this element as byte array. The conversion is <a href ="http://grouper.ieee.org/groups/1363/">P1363</a>-conform
            </summary>
            
            <returns>Returns this element as byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.ToFlexiBigInt">
            <summary>
            Returns this element as FlexiBigInt. The conversion is <a href="http://grouper.ieee.org/groups/1363/">P1363</a>-conform
            </summary>
            
            <returns>Returns this element as BigInt</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.ToString">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal radix in MSB-first order
            </summary>
            
            <returns>Returns a String representing this Bitstrings value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement.ToString(System.Int32)">
            <summary>
            Return a String representation of this element. <c>Radix</c> specifies the radix of the String representation
            </summary>
            
            <param name="Radix">Specifies the radix of the String representation</param>
            
            <returns>Returns String representation of this element with the specified radix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the sum of this element and <c>Addend</c>.
            </summary>
            
            <param name="Addend">The addend</param>
            
            <returns>Returns <c>this + other</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.AddToThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute <c>this + addend</c> (overwrite <c>this</c>)
            </summary>
            
            <param name="Addend">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.AssignZero">
            <summary>
            Assign the value 0 to this element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.AssignOne">
            <summary>
            Assigns the value 1 to this element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Clone">
            <summary>
            Return a copy of this GF2nElement
            </summary>
            
            <returns>The cloned copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Increase">
            <summary>
            Compute <c>this</c> element + 1
            </summary>
            
            <returns>Returns <c>this</c> + 1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.IncreaseThis">
            <summary>
            Increases this element by one
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Invert">
            <summary>
            Compute the multiplicative inverse of this element
            </summary>
            
            <returns>Returns <c>this^-1</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.IsOne">
            <summary>
            Tests if the GF2nPolynomialElement has 'one' as value
            </summary>
            
            <returns>Returns true if <c>this</c> equals one (this == 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.IsZero">
            <summary>
            Checks whether this element is zero
            </summary>
            
            <returns>Returns <c>true</c> if <c>this</c> is the zero element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the product of this element and <c>factor</c>
            </summary>
            
            <param name="Factor">he factor</param>
            
            <returns>Returns <c>this * factor</c> </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.MultiplyThisBy(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute <c>this * factor</c> (overwrite <c>this</c>).
            </summary>
            
            <param name="Factor">The factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.SolveQuadraticEquation">
            <summary>
            Solves a quadratic equation.
            <para>Let z^2 + z = <c>this</c>. Then this method returns z.</para>
            </summary>
            
            <returns>Returns z with z^2 + z = <c>this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Square">
            <summary>
            Compute <c>this</c> element to the power of 2
            </summary>
            
            <returns>Returns <c>this</c>^2</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.SquareRoot">
            <summary>
            Compute the square root of this element and return the result in a new GF2nElement
            </summary>
            
            <returns>Returns <c>this^1/2</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.SquareRootThis">
            <summary>
            Compute the square root of this element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.SquareThis">
            <summary>
            Squares <c>this</c> element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.TestBit(System.Int32)">
            <summary>
            Checks whether the indexed bit of the bit representation is set
            </summary>
            
            <param name="Index">The index of the bit to test</param>
            
            <returns>Returns <c>true</c> if the indexed bit is set</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.TestRightmostBit">
            <summary>
            Returns whether the rightmost bit of the bit representation is set. 
            This is needed for data conversion according to 1363.
            </summary>
            
            <returns>Returns true if the rightmost bit of this element is set</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.ToFlexiBigInt">
            <summary>
            Converts this GF2nPolynomialElement to an integer according to 1363
            </summary>
            
            <returns>Returns a BigInteger representing the value of this GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.ToByteArray">
            <summary>
            Converts this GF2nPolynomialElement to a byte[] according to 1363
            </summary>
            
            <returns>Returns a byte[] representing the value of this GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.ToString(System.Int32)">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal or binary radix in MSB-first order
            </summary>
            
            <param name="Radix">The radix to use (2 or 16, otherwise 2 is used)</param>
            
            <returns>Returns a String representing this Bitstrings value.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Trace">
            <summary>
            Computes the trace of this element
            </summary>
            
            <returns>Returns the trace of this element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Convert(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField)">
            <summary>
            Performs a basis transformation of this element to the given GF2nField <c>basis</c>
            </summary>
            
            <param name="Basis">The GF2nField representation to transform this element to</param>
            
            <returns>Returns this element in the representation of <c>basis</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.GetField">
            <summary>
            Returns the field of this element
            </summary>
            
            <returns>The field of this element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the difference of this element and <c>minuend</c>
            </summary>
            
            <param name="Minuend">The minuend</param>
            
            <returns>Returns <c>this - minuend</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.SubtractFromThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the difference of this element and <c>minuend</c>,  overwriting this element
            </summary>
            
            <param name="Minuend">The minuend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.Equals(System.Object)">
            <summary>
            Compare this element with another object
            </summary>
            
            <param name="Obj">The object for comprison</param>
            
            <returns>Returns <c>true</c> if the two objects are equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.GetHashCode">
            <summary>
            Returns the hash code of this element
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement.ToString">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal radix in MSB-first order
            </summary>
            
            <returns>Returns a String representing this Bitstrings value</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix">
            <summary>
            This class describes some operations with matrices over finite field <c>GF(2^m)</c> with small <c>m</c> (1&lt; m &lt;32)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix">
            <summary>
            This abstract class defines matrices.
            <para>It holds the number of rows and the number of columns of the matrix and defines some basic methods.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.MATRIX_TYPE_ZERO">
            <summary>
            Zero matrix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.MATRIX_TYPE_UNIT">
            <summary>
            Unit matrix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.MATRIX_TYPE_RANDOM_LT">
            <summary>
            Random lower triangular matrix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.MATRIX_TYPE_RANDOM_UT">
            <summary>
            Random upper triangular matrix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.MATRIX_TYPE_RANDOM_REGULAR">
            <summary>
            Random regular matrix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix._columnCount">
            <summary>
            Number of columns
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix._rowCount">
            <summary>
            Number of rows
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.ComputeInverse">
            <summary>
            Compute the inverse of this matrix
            </summary>
            
            <returns>Returns the inverse of this matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.GetEncoded">
            <summary>
            Get a copy of the encoded matrix as a byte array
            </summary>
            
            <returns>Returns this matrix in byte array form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.IsZero">
            <summary>
            Check if this is the zero matrix (i.e., all entries are zero).
            </summary>
            
            <returns>Returns <c>true</c> if this is the zero matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.LeftMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Compute the product of a vector and this matrix.
            <para>If the length of the vector is greater than the number of rows of this matrix, 
            the matrix is multiplied by each m-bit part of the vector.</para>
            </summary>
            
            <param name="V">A vector</param>
            
            <returns>Returns <c>V * this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix)">
            <summary>
            Compute the product of this matrix and another matrix
            </summary>
            
            <param name="M">The other matrix</param>
            
            <returns>Returns <c>this * M</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Compute the product of this matrix and a permutation
            </summary>
            
            <param name="P">The permutation</param>
            
            <returns>Returns <c>this * P</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Compute the product of this matrix and a vector
            </summary>
            
            <param name="V">A vector</param>
            
            <returns>Returns <c>this * V</c> </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.ToString">
            <summary>
            Return a human readable form of the matrix
            </summary>
            
            <returns>The matrix as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.Equals(System.Object)">
            <summary>
            Compare this matrix with another object.
            </summary>
            
            <param name="Obj">The object to compare this to</param>
            <returns>Returns <c>true</c> if object is equal and has the same values</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.GetHashCode">
            <summary>
            Computes the the hash code of this matrix
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.ColumnCount">
            <summary>
            Get: Returns the number of columns in the binary matrix
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix.RowCount">
            <summary>
            Get: Returns the number of rows in the matrix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.FieldG">
            <summary>
            The finite field GF(2^m)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.MatrixN">
            <summary>
            For the matrix representation the array of type int[][] is used, thus every element of the 
            array keeps one element of the matrix (element from finite field GF(2^m))
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,System.Byte[])">
            <summary>
            Initialze this class with an encoded matrix
            </summary>
            
            <param name="FieldG">The finite field GF(2^m)</param>
            <param name="Encoded">The matrix in byte array form</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix)">
            <summary>
            Create an instance using values from another GF2mMatrix instance
            </summary>
            
            <param name="G">The GF2mMatrix instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,System.Int32[][])">
            <summary>
            Create an instance using values from a field and matrix
            </summary>
            
            <param name="FieldG">A finite field GF(2^m)</param>
            <param name="MatrixN">The matrix as int array; only the reference is copied.</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.ComputeInverse">
            <summary>
            Compute the inverse of this matrix
            </summary>
            
            <returns>Returns the inverse of this matrix (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.Equals(System.Object)">
            <summary>
            Checks if given object is equal to this matrix. The method returns false whenever the given object is not a matrix over GF(2^m)
            </summary>
            
            <param name="Obj">The object to compare to this</param>
            
            <returns>Returns <c>true</c> if the object is equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.GetEncoded">
            <summary>
            Returns a byte array encoding of this matrix
            </summary>
            
            <returns>The encoded GF2mMatrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.GetHashCode">
            <summary>
            Computes the the hash code of this matrix
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.IsZero">
            <summary>
            Check if this is the zero matrix (i.e., all entries are zero).
            </summary>
            
            <returns>Returns <c>true</c> if this is the zero matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.LeftMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Not implemented
            </summary>
            
            <param name="V">Vector V</param>
            
            <returns>throws NotImplementedException</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix)">
            <summary>
            Not implemented
            </summary>
            
            <param name="M">Matrix M</param>
            
            <returns>throws NotImplementedException</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Not implemented
            </summary>
            
            <param name="P">Permutation P</param>
            
            <returns>throws NotImplementedException</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Not implemented
            </summary>
            
            <param name="V">Vector V</param>
            
            <returns>throws NotImplementedException</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mMatrix.ToString">
            <summary>
            Get a human readable form of the matrix
            </summary>
            
            <returns>Returns the matrix as a string</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmFileRequestEventArgs">
            <summary>
            An event arguments class containing the FileRequest state
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmFileRequestEventArgs.FilePath">
            <summary>
            Fires with the name of the file; returns the destination folder
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmFileRequestEventArgs.OptionFlag">
            <summary>
            The option flag containing optional state information
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmFileRequestEventArgs.Cancel">
            <summary>
            The Cancel token; setting this value to true instructs the server to refuse the file
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmFileRequestEventArgs.#ctor(System.String,System.Int64)" -->
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ArrayUtils">
            <summary>
            Extended array methods
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Byte[]@,System.Byte,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Int32[]@,System.Int32,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddAt(System.Int64[]@,System.Int64,System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Value">The new value</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Byte[]@,System.Byte[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Int32[]@,System.Int32[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AddRange(System.Int64[]@,System.Int64[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Compare Byte Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AreEqual(System.Char[],System.Char[])">
            <summary>
            Compare Char Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AreEqual(System.Int16[],System.Int16[])">
            <summary>
            Compare short integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AreEqual(System.Int32[],System.Int32[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AreEqual(System.Int64[],System.Int64[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AreEqual(System.Single[],System.Single[])">
            <summary>
            Compare float Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.AreEqual(System.Double[],System.Double[])">
            <summary>
            Compare double Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Clone(System.Byte[])">
            <summary>
            Create a deep copy of a byte array
            </summary>
            
            <param name="A">The array to copy</param>
            
            <returns>Returns the array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Clone(System.Int16[])">
            <summary>
            Create a deep copy of a Int16 array
            </summary>
            
            <param name="A">The array to copy</param>
            
            <returns>Returns the array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Clone(System.Int32[])">
            <summary>
            Create a deep copy of a Int32 array
            </summary>
            
            <param name="A">The array to copy</param>
            
            <returns>Returns the array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Clone(System.Int64[])">
            <summary>
            Create a deep copy of a Int64 array
            </summary>
            
            <param name="A">The array to copy</param>
            
            <returns>Returns the array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Byte[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Int32[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.UInt32[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.Int64[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Concat(System.UInt64[][])">
            <summary>
            Concatenate 2 arrays
            </summary>
            
            <param name="Arrays">Arrays to be joined</param>
            
            <returns>Joined array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.CreateJagged``1(System.Int32[])">
            <summary>
            Create and initialize a jagged array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Lengths">The arrays lengths</param>
            
            <returns>Initialized jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.InitializeJagged(System.Type,System.Int32,System.Int32[])">
            <summary>
            Initialize a jagged array
            </summary>
            
            <param name="Type">Type of array</param>
            <param name="Index">The first row index of the array outer array</param>
            <param name="Lengths">The arrays lengths</param>
            
            <returns>The initialized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.GetRange(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a range of elements from an array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">First element to copy</param>
            <param name="Length">The number of bytes to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.GetRange(System.Int16[],System.Int32,System.Int32)">
            <summary>
            Get a range of elements from an array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">First element to copy</param>
            <param name="Length">The number of bytes to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.GetRange(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Get a range of elements from an array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">First element to copy</param>
            <param name="Length">The number of bytes to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.GetRange(System.Int64[],System.Int64,System.Int64)">
            <summary>
            Get a range of elements from an array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">First element to copy</param>
            <param name="Length">The number of bytes to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Byte[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Int32[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveAt(System.Int64[]@,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Int32[]@,System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.RemoveRange(System.Int64[]@,System.Int64,System.Int64)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Byte[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Int32[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.UInt32[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.Int64[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.Split(System.UInt64[],System.Int32)">
            <summary>
            Split an array
            </summary>
            
            <param name="Data">The array to be split</param>
            <param name="Index">The starting position of the second array</param>
            
            <returns>A jagged array containing the split array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray16(System.Byte[])">
            <summary>
            Copy a byte array to a short array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Byte array converted to short</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToUArray16(System.Byte[])">
            <summary>
            Copy a byte array to a ushort array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Byte array converted to ushort</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray32(System.Byte[])">
            <summary>
            Copy a byte array to a int array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Byte array converted to int</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToUArray32(System.Byte[])">
            <summary>
            Copy a byte array to a uint array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Byte array converted to uint</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray64(System.Byte[])">
            <summary>
            Copy a byte array to a long array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Byte array converted to long</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToUArray64(System.Byte[])">
            <summary>
            Copy a byte array to a ulong array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Byte array converted to ulong</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray2x8(System.Byte[])">
            <summary>
            Convert a byte array to a 2 dimensional jagged byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>2 dimensional byte jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray2x16(System.Byte[])">
            <summary>
            Convert a byte array to a 2 dimensional Int16 jagged array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>2 dimensional Int16 jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray2x32(System.Byte[])">
            <summary>
            Convert a byte array to a 2 dimensional Int32 jagged array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>2 dimensional Int32 jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray2x64(System.Byte[])">
            <summary>
            Convert a byte array to a 2 dimensional Int64 jagged array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>2 dimensional Int64 jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray3x8(System.Byte[])">
            <summary>
            Convert a byte array to a 3 dimensional jagged byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>3 dimensional byte jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray3x16(System.Byte[])">
            <summary>
            Convert a byte array to a 3 dimensional Int16 jagged array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>3 dimensional Int16 jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray3x32(System.Byte[])">
            <summary>
            Convert a byte array to a 3 dimensional Int32 jagged array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>3 dimensional Int32 jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToArray3x64(System.Byte[])">
            <summary>
            Convert a byte array to a 3 dimensional Int64 jagged array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>3 dimensional Int64 jagged array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.SByte[])">
            <summary>
            Copy a sbyte array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Sbyte array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int16[])">
            <summary>
            Copy a int array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Int array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.UInt16[])">
            <summary>
            Copy a int array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Int array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int32[])">
            <summary>
            Copy a int array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Int array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.UInt32[])">
            <summary>
            Copy a uint array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Uint array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int64[])">
            <summary>
            Copy a long array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Long array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.UInt64[])">
            <summary>
            Copy a long array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>Long array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.String)">
            <summary>
            Copy a string to an ASCII byte array
            </summary>
            
            <param name="Value">String to copy</param>
            
            <returns>The byte array representation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Byte[][])">
            <summary>
            Copy a 2 dimensional jagged byte array to a one dimensional byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>2 dimensional byte jagged array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Byte[][][])">
            <summary>
            Copy a 3 dimensional jagged byte array to a one dimensional byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>3 dimensional byte jagged array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int16[][])">
            <summary>
            Copy a 2 dimensional Int16 jagged array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>2 dimensional Int16 jagged array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int32[][])">
            <summary>
            Copy a 2 dimensional Int32 jagged array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>2 dimensional Int32 jagged array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int64[][])">
            <summary>
            Copy a 2 dimensional Int64 jagged array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>2 dimensional Int64 jagged array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int16[][][])">
            <summary>
            Copy a 3 dimensional Int16 jagged array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>3 dimensional Int16 jagged array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int32[][][])">
            <summary>
            Copy a 3 dimensional Int32 jagged array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>3 dimensional Int16 jagged array converted to bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayUtils.ToBytes(System.Int64[][][])">
            <summary>
            Copy a 3 dimensional Int64 jagged array to a byte array
            </summary>
            
            <param name="Data">Array to convert</param>
            
            <returns>3 dimensional Int64 jagged array converted to bytes</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.PKCS7">
            <summary>
            <h3>The PKCS7 Padding Scheme.</h3>
            <para>PKCS7 as outlined in RFC 5652<cite>RFC 5652</cite></para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding">
            <summary>
            Padding Mode Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.PKCS7.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.PKCS7.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.PKCS7.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.PKCS7.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB">
            <summary>
            <h3>Implements an Electronic Cookbook Mode: ECB (Not Recommended).</h3>
            <para>ECB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new ECB(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">
            <summary>
            Cipher Mode Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key and Vector</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes within an array
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode.Name">
            <summary>
            Cipher name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">KeyParam containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes.
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters.
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ECB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC">
            <summary>
            <h3>Implements a Cipher Block Chaining Mode: CBC.</h3>
            <para>CBC as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CBC(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Parallel processing is enabled on decryption by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParam containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. Parallel capable in Decryption mode. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. Parallel capable in Decryption mode. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigMath">
            <summary>
            Class of number-theory related functions for use with integers represented as <c>int</c>'s or <c>BigInteger</c> objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Binomial(System.Int32,System.Int32)">
            <summary>
            Computes the binomial coefficient (n|t)
            </summary>
            
            <param name="X">The upper integer</param>
            <param name="T">The lower integer</param>
            
            <returns>Returns the binomialcoefficient (n|t) as BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.BitCount(System.Int32)">
            <summary>
            Get the number of ones in the binary representation of an integer <c>A</c>
            </summary>
            
            <param name="X">n integer</param>
            
            <returns>Returns the number of ones in the binary representation of an integer <c>A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the smallest integer that is greater than or equal to the logarithm to the base 2 of the given BigInteger
            </summary>
            
            <param name="X">The BigInteger</param>
            
            <returns>Returns <c>ceil[log(a)]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog(System.Int32)">
            <summary>
            Compute the smallest integer that is greater than or equal to the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns <c>ceil[log(a)]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog256(System.Int32)">
            <summary>
            Compute <c>ceil(log_256 n)</c>, the number of bytes needed to encode the integer <c>N</c>
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns the number of bytes needed to encode <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.CeilLog256(System.Int64)">
            <summary>
            Compute <c>ceil(log_256 n)</c>, the number of bytes needed to encode the long integer <c>N</c>
            </summary>
            
            <param name="X">The long integer</param>
            
            <returns>Returns the number of bytes needed to encode <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.DivideAndRound(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Divide two BigIntegers and return the rounded result
            </summary>
            
            <param name="A">The first BigInteger</param>
            <param name="B">The second BigInteger</param>
            
            <returns>The rounded result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.DivideAndRound(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Divide two BigInteger arrays and return the rounded result
            </summary>
            
            <param name="A">The first BigInteger array</param>
            <param name="B">The second BigInteger array</param>
            
            <returns>The rounded result</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ExtGcd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Extended euclidian algorithm (computes Gcd and representation)
            </summary>
            
            <param name="A">The first BigInteger</param>
            <param name="B">The second BigInteger</param>
            
            <returns>Returns <c>(d,u,v)</c>, where <c>d = Gcd(A,B) = ua + vb</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ExtGcd(System.Int32,System.Int32)">
            <summary>
            Extended euclidian algorithm (computes gcd and representation)
            </summary>
            
            <param name="A">The first integer</param>
            <param name="B">The second integer</param>
            
            <returns>Returns <c>(g,u,v)</c>, where <c>g = Gcd(Abs(A),Abs(B)) = ua + vb</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloatLog(System.Single)">
            <summary>
            Calculation of a logarithmus of a float param
            </summary>
            
            <param name="X">The float value</param>
            
            <returns>Returns <c>Log(A)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloatPow(System.Single,System.Int32)">
            <summary>
            Returns the int power of a base float, only use for small ints
            </summary>
            
            <param name="X">The float value</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloorLog(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the integer part of the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns floor[log(a)]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.FloorLog(System.Int32)">
            <summary>
            Compute the integer part of the logarithm to the base 2 of the given integer
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns floor[log(a)]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Gcd(System.Int32,System.Int32)">
            <summary>
            Computes the greatest common divisor of the two specified integers
            </summary>
            
            <param name="A">The first integer</param>
            <param name="B">The  second integer</param>
            
            <returns>Returns <c>Gcd(a, b)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IntRoot(System.Int32,System.Int32)">
            <summary>
            Takes an approximation of the root from an integer base, using newton's algorithm
            </summary>
            
            <param name="X">The base to take the root from</param>
            <param name="Root">The root, for example 2 for a square root</param>
            
            <returns>Returns the integers base root</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IntToOctets(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Convert a BigInteger to bytes
            </summary>
            
            <param name="X">The BigInteger</param>
            
            <returns>Returns the BigInteger as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsIncreasing(System.Int32[])">
            <summary>
            Tests if the integers are incrementing
            </summary>
            
            <param name="A">The array to test</param>
            
            <returns>Returns <c>true</c> if array values are incrementing</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsPower(System.Int32,System.Int32)">
            <summary>
            Tests whether an integer <c>a</c> is power of another integer <c>P</c>
            </summary>
            
            <param name="X">The first integer</param>
            <param name="P">The second integer</param>
            
            <returns>Returns n if A = P^n or -1 otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsPrime(System.Int32)">
            <summary>
            Miller-Rabin-Test, determines wether the given integer is probably prime or composite.
            <para>This method returns <c>true</c> if the given integer is prime with probability <c>1 - 2^-20</c>.</para>
            </summary>
            
            <param name="X">The integer to test for primality</param>
            
            <returns>Returns <c>true</c> if the given integer is prime with probability 2*-100, otherwise <c>false</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.IsSmallPrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Short trial-division test to find out whether a number is not prime.
            <para>This test is usually used before a Miller-Rabin primality test.</para>
            </summary>
            
            <param name="Candidate">he number to test</param>
            
            <returns>Returns <c>true</c> if the number has no factor of the tested primes, <c>false</c> if the number is definitely composite</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Jacobi(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the value of the Jacobi symbol (A|B). 
            </summary>
            
            <param name="A">The integer value</param>
            <param name="B">The integer value</param>
            
            <returns>Returns value of the jacobi symbol (A|B)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Lcm(VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Computation of the least common multiple of a set of BigIntegers
            </summary>
            
            <param name="Numbers">The set of numbers</param>
            
            <returns>Returns the lcm(Numbers)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.LeastDiv(System.Int32)">
            <summary>
            Find and return the least non-trivial divisor of an integer <c>A</c>
            </summary>
            
            <param name="X">The integer</param>
            
            <returns>Returns divisor p &gt;1 or 1 if A = -1,0,1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Log(System.Double)">
            <summary>
            Calculates the logarithm to the base 2
            </summary>
            
            <param name="X"> double value</param>
            
            <returns>Returns log_2(x)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Log(System.Int64)">
            <summary>
            Calculate the logarithm to the base 2
            </summary>
            
            <param name="X">Any long value &gt;=1</param>
            
            <returns>Returns <c>log_2(x)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.MaxPower(System.Int32)">
            <summary>
            Compute the largest <c>h</c> with <c>2^h | A</c> if <c>A!=0</c>
            </summary>
            
            <param name="X">An integer</param>
            
            <returns>Returns the largest <c>h</c> with <c>2^h | A</c> if <c>A!=0</c>, <c>0</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Mod(System.Int64,System.Int64)">
            <summary>
            Returns a long integer whose value is <c>(A mod M</c>). 
            <para>This method differs from <c>%</c> in that it always returns a <c>non-negative</c> integer.</para>
            </summary>
            
            <param name="X">The value on which the modulo operation has to be performed</param>
            <param name="M">The modulus.</param>
            
            <returns>Returns <c>A mod M</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModInverse(System.Int32,System.Int32)">
            <summary>
            Computes the modular inverse of an integer A
            </summary>
            
            <param name="X">The integer to invert</param>
            <param name="Mod">The modulus</param>
            
            <returns>Returns <c>A<sup>-1</sup> Mod n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModInverse(System.Int64,System.Int64)">
            <summary>
            Computes the modular inverse of an integer A
            </summary>
            
            <param name="X">The integer to invert</param>
            <param name="Mod">The modulus</param>
            
            <returns>Returns <c>A<sup>-1</sup> Mod n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ModPow(System.Int32,System.Int32,System.Int32)">
            <summary>
            Compute <c>A^E mod N</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            <param name="N">The modulus</param>
            
            <returns>Returns <c>A<sup>E</sup> mod N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextPrime(System.Int64)">
            <summary>
            Computes the next prime greater than N
            </summary>
            
            <param name="X">An integer number</param>
            
            <returns>Returns the next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Compute the next probable prime greater than <c>N</c> with the specified certainty
            </summary>
            
            <param name="X">An integer number</param>
            <param name="Certainty">The certainty that the generated number is prime</param>
            
            <returns>Returns the next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextProbablePrime(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compute the next probable prime greater than <c>N</c> with the default certainty (20)
            </summary>
            
            <param name="X">An integer number</param>
            
            <returns>The next prime greater than <c>N</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.NextSmallerPrime(System.Int32)">
            <summary>
            Returns the largest prime smaller than the given integer
            </summary>
            
            <param name="X"> upper bound</param>
            
            <returns>Returns the largest prime smaller than <c>N</c>, or <c>1</c> if <c>N &lt;= 2</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.OctetsToInteger(System.Byte[])">
            <summary>
            Create a BigInteger from a byte array
            </summary>
            
            <param name="Data">The source byte array</param>
            
            <returns>Returns the BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.OctetsToInteger(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a BigInteger from a byte array
            </summary>
            
            <param name="Data">The source byte array</param>
            <param name="Offset">The starting offset within the array</param>
            <param name="Length">The number of bytes used to create the BigInteger</param>
            
            <returns>Returns the BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Order(System.Int32,System.Int32)">
            <summary>
            Determines the order of G modulo P, P prime and 1 &lt; g &lt; p; This algorithm is only efficient for small P
            </summary>
            
            <param name="G">An integer with 1 &lt; G &lt; P</param>
            <param name="P">The prime</param>
            
            <returns>Returns the order k of g (that is k is the smallest integer with G^k = 1 mod P</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Pow(System.Int32,System.Int32)">
            <summary>
            Compute <c>A^E</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Pow(System.Int64,System.Int32)">
            <summary>
            Compute <c>A^E</c>
            </summary>
            
            <param name="X">The base</param>
            <param name="E">The exponent</param>
            
            <returns>Returns <c>A^E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Randomize(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Create a random BigInteger
            </summary>
            
            <param name="UpperBound">The upper bound</param>
            
            <returns>A random BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.ReduceInto(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Reduces an integer into a given interval
            </summary>
            
            <param name="X">The integer</param>
            <param name="Begin">Left bound of the interval</param>
            <param name="End">Right bound of the interval</param>
            
            <returns>Returns <c>N</c> reduced into <c>[Begin,End]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Ressol(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the square root of a BigInteger modulo a prime employing the Shanks-Tonelli algorithm
            </summary>
            
            <param name="X">The value out of which we extract the square root</param>
            <param name="P">The prime modulus that determines the underlying field</param>
            
            <returns>Returns a number <c>B</c> such that B^2 = A (mod P) if <c>A</c> is a quadratic residue modulo <c>P</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.Randomize(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Create a random BigInteger
            </summary>
            
            <param name="UpperBound">The upper bound</param>
            <param name="SecRnd">An instance of the SecureRandom class</param>
            
            <returns>A random BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.SquareRoot(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Extract the truncated square root of a BigInteger
            </summary>
            
            <param name="X">A value out of which we extract the square root</param>
            
            <returns>Returns the truncated square root of <c>a</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigMath.LogBKM(System.Double)">
            <summary>
            BKM Algorithm to calculate logarithms to the base 2
            </summary>
            
            <param name="X"> double value with 1&lt;= arg&lt;= 4.768462058</param>
            
            <returns>Returns log_2(arg)</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">
            <summary>
            Wraps exceptions thrown within a Network Socket operational context.
            <para>This exception is used in the TcpSocket class.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac">
            <summary>
            <h3>MAC stream helper class.</h3>
            <para>Wraps Message Authentication Code (MAC) stream functions in an easy to use interface.</para>
            </summary> 
            
            <example>
            <description>Example of hashing a Stream:</description>
            <code>
            byte[] hash;
            using (IMac mac = new SHA512HMAC())
            {
                mac.Initialize(new KeyParams(key));
                
                using (StreamMac mstrm = new StreamMac(mac, [false]))
                {
                    // assign the input stream
                    mstrm.Initialize(InputStream, [true]);
                    // get the digest
                    hash = mstrm.ComputeMac([Length], [InOffset]);
                }
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Mac">VTDev.Libraries.CEXEngine.Crypto Mac Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Macs Enumeration</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs">Macs</see> using the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac">interface</see>.</description></item>
            <item><description>Mac must be fully initialized before passed to the constructor.</description></item>
            <item><description>Mac can be Disposed when this class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.Dispose">Disposed</see>, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Input Stream can be Disposed when this class is Disposed, set the DisposeStream parameter in the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.Initialize(System.IO.Stream,System.Boolean)"/> call to true to dispose automatically.</description></item>
            <item><description>Implementation has a Progress counter that returns total sum of bytes processed per either <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.ComputeMac(System.Int64,System.Int64)">ComputeMac([InOffset], [OutOffset])</see> calls.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac,System.Boolean)">
            <summary>
            Initialize the class with a digest enumeration
            </summary>
            
            <param name="Mac">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.IMac"/> instance</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.Dispose"/> on this class is called; default is false</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if an uninitialized Mac is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.Initialize(System.IO.Stream,System.Boolean)">
            <summary>
            Initialize internal state
            </summary>
            
            <param name="InStream">The Source stream to be transformed</param>
            <param name="DisposeStream">Dispose of streams when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null Input stream is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.ComputeMac">
            <summary>
            Process the entire length of the Input Stream
            </summary>
            
            <returns>The Message Authentication Code</returns>
             
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if ComputeMac is called before Initialize(), or Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.ComputeMac(System.Int64,System.Int64)">
            <summary>
            Process a length within the Input stream using an Offset
            </summary>
            
            <param name="Length">The number of bytes to process</param>
            <param name="Offset">The Input Stream positional offset</param>
            
            <returns>The Message Authentication Code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if ComputeHash is called before Initialize(), or if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.IsConcurrent">
            <summary>
            Enable file reads and digest processing to run concurrently
            <para>The default is true, but will revert to false if the stream is not a FileStream, 
            or the file size is less that 65535 bytes in length.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamMac.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng">
            <summary>
            <h3>An implementation of a passphrase based PKCS#5 random number generator.</h3>
            <para>Implements PKCS#5 as defined in RFC 2898</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new PBPRng(new SHA512(), PassPhrase, Salt))
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/28/15" version="1.3.2.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[],System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Creates a new PassphrasePrng from a passphrase and salt,
            and seeds it with the output of PKCS5
            </summary>
            
            <param name="Digest">Digest engine</param>
            <param name="Passphrase">The passphrase</param>
            <param name="Salt">The salt value</param>
            <param name="Iterations">The number of transformation iterations performed by the digest with PKCS5 (default is 10,000)</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Dispose"/> on this class is called (default is true)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if a null Digest, Passphrase or Salt are used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.CreateBranch(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest)">
            <summary>
            Creates a new Passphrase rng whose output differs but is a
            function of this rng's internal state.
            </summary>
            
            <param name="Digest">The digest instance</param>
            
            <returns>Returns a PassphrasePrng instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Reset">
            <summary>
            Sets or resets the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.PBPRng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader">
            <summary>
            An encrypted message file header structure. 
            <para>Used in conjunction with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher"/> class.
            KeyID and Extension values must each be 16 bytes in length. Message MAC code is optional.</para>
            </summary>
            
            <revisionHistory>
            <revision date="2015/03/12" version="1.3.2.0">Initial release</revision>
            <revision date="2015/07/02" version="1.4.0.0">Changes to documentation and method structure</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">VTDev.Libraries.CEXEngine.Crypto.Processing StreamCipher class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory">VTDev.Libraries.CEXEngine.Crypto PackageFactory class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures PackageKey structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures KeyAuthority structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">VTDev.Libraries.CEXEngine.Crypto.Enumeration KeyPolicies Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates">VTDev.Libraries.CEXEngine.Crypto KeyStates Enumeration</seealso>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.KeyID">
            <summary>
            The 16 byte key identifier
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.Extension">
            <summary>
            The encrypted message file extension
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.MessageMac">
            <summary>
            The HMAC hash value of the encrypted file
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.#ctor(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            MessageHeader constructor
            </summary>
            
            <param name="KeyId">A unique 16 byte key ID</param>
            <param name="Extension">A 16 byte encrypted file extension</param>
            <param name="MessageHash">A message hash value, can be null</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Initialize the MessageHeader structure using a Stream
            </summary>
            
            <param name="HeaderStream">The Stream containing the MessageHeader</param>
            <param name="MacLength">Length in bytes of the Message Authentication Code; must align to MacLength property in <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the DataStream is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.#ctor(System.Byte[])">
            <summary>
            Initialize the MessageHeader structure using a byte array
            </summary>
            
            <param name="HeaderArray">The byte array containing the MessageHeader</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.Reset">
            <summary>
            Clear all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.ToBytes">
            <summary>
            Convert the MessageHeader structure as a byte array
            </summary>
            
            <returns>The byte array containing the MessageHeader</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.ToStream">
            <summary>
            Convert the MessageHeader structure to a MemoryStream
            </summary>
            
            <returns>The MemoryStream containing the MessageHeader</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.GetEncryptedExtension(System.String,System.Byte[])">
            <summary>
            Encrypt the file extension
            </summary>
            
            <param name="Extension">The message file extension</param>
            <param name="ExtKey">Random byte array used to encrypt the extension</param>
            
            <returns>Encrypted file extension</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.GetExtension(System.IO.Stream,System.Byte[])">
            <summary>
            Get decrypted file extension
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            <param name="ExtKey">Random byte array used to encrypt the extension</param>
            
            <returns>File extension</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.GetKeyId(System.IO.Stream)">
            <summary>
            Get the messages unique key identifier
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            
            <returns>The unique 16 byte ID of the key used to encrypt this message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.GetMessageMac(System.IO.Stream,System.Int32)">
            <summary>
            Get the MAC value for this file
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            <param name="MacSize">Size of the Message Authentication Code</param>
            
            <returns>64 byte Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.HasHeader(System.IO.Stream)">
            <summary>
            Test for valid header in file
            </summary>
            
            <param name="MessageStream">Stream containing a message header</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.SetExtension(System.IO.Stream,System.Byte[])">
            <summary>
            Set the messages 16 byte Key ID value
            </summary>
            
            <param name="MessageStream">The message stream</param>
            <param name="Extension">The message file extension</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.SetKeyId(System.IO.Stream,System.Byte[])">
            <summary>
            Set the messages 16 byte Key ID value
            </summary>
            
            <param name="MessageStream">The message stream</param>
            <param name="KeyID">The unique 16 byte ID of the key used to encrypt this message</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.SetMessageMac(System.IO.Stream,System.Byte[])">
            <summary>
            Set the messages MAC value
            </summary>
            
            <param name="MessageStream">The message stream</param>
            <param name="Mac">The Message Authentication Code</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.op_Equality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader)">
            <summary>
            Compare this object instance is equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.op_Inequality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader)">
            <summary>
            Compare this object instance is not equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Not equal</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.MessageHeader.GetHeaderSize">
            <summary>
            Get the size of a MessageHeader
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoKeyExchangeException">
            <summary>
            Wraps exceptions thrown within a Key Exchange operation.
            <para>This exception is used in the DtmKex class.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoKeyExchangeException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoKeyExchangeException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoKeyExchangeException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoKeyExchangeException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoKeyExchangeException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory">
            <summary>
            <h3>A helper class used to create and extract a VolumeKey file.</h3>
            
            <list type="bullet">
            <item><description>Constructors may use a fully qualified path to a key file, or the keys file stream.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)"/> method auto-generate keying material.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,System.Int32)"/> overload:</description>
            <code>
                string[] paths = DirectoryTools.GetFiles(InputDirectory);
            
                // set cipher paramaters
                CipherDescription desc = new CipherDescription(
                    Engines.RDX, 32,
                    IVSizes.V128,
                    CipherModes.CTR,
                    PaddingModes.X923,
                    BlockSizes.B128,
                    RoundCounts.R14,
                    Digests.Keccak512,
                    64,
                    Digests.Keccak512);
            
                // define the volume key
                VolumeKey vkey = new VolumeKey(desc, paths.Length);
                
                // key will be written to this stream
                MemoryStream keyStream = new MemoryStream();
            
                // create the volume key stream
                using (VolumeFactory vf = new VolumeFactory(keyStream))
                    vf.Create(vkey);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/05/22" version="1.3.6.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures VolumeKey Structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription Structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator">VTDev.Libraries.CEXEngine.Crypto.Processing.Factory KeyGenerator class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher">VTDev.Libraries.CEXEngine.Crypto.Processing VolumeCipher class</seealso>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.#ctor(System.String)">
            <summary>
            Initialize this class with a key file path; key will be written to the path
            </summary>
            
            <param name="KeyPath">The fully qualified path to the key file to be read or created</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the key path is invalid, the key file exists, or the path is read onle</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Initialize this class with a stream; key will be written to the stream
            </summary>
            
            <param name="KeyStream">The stream that receives the key</param>
            <param name="DisposeKey">Dispose of the key stream when this class is disposed; default is false</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null stream is passed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.Finalize">
            <summary>
            Finalizer: ensure resources are destroyed
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Create a volume key file using automatic key material generation.
            <para>The Key, and IV sets are generated automatically using the cipher description contained in the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/>.
            This overload creates keying material using the seed and digest engines specified with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator"/> class</para>
            </summary>
            
            <param name="Key">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey">VolumeKey</see> containing the cipher and key implementation details</param>
            <param name="SeedEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">Random Generator</see> used to create the stage I seed material during key generation.</param>
            <param name="HashEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest Engine</see> used in the stage II phase of key generation.</param>
            
            <exception cref="T:System.IO.FileLoadException">A key file exists at the path specified</exception>
            <exception cref="T:System.UnauthorizedAccessException">The key file path is read only</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,System.Int32)">
            <summary>
            Create a volume key file using a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> containing the cipher implementation details, and a key count size
            </summary>
            
            <param name="Description">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">Cipher Description</see> containing the cipher details</param>
            <param name="KeyCount">The number of key sets associated with this volume key</param>
            
            <exception cref="T:System.IO.FileLoadException">A key file exists at the path specified</exception>
            <exception cref="T:System.UnauthorizedAccessException">The key file path is read only</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.Create(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Create a volume key file using a manual description of the cipher parameters.
            </summary>
            
            <param name="KeyCount">The number of key sets associated with this volume key</param>
            <param name="EngineType">The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Engine</see> type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes">Initialization Vector</see></param>
            <param name="CipherType">The type of <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes">Cipher Mode</see></param>
            <param name="PaddingType">The type of cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes">Padding Mode</see></param>
            <param name="BlockSize">The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes">Block Size</see></param>
            <param name="Rounds">The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts">Rounds</see></param>
            <param name="KdfEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers</param>
            <param name="MacSize">The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key</param>
            <param name="MacEngine">The HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to authenticate a message file encrypted with this key</param>
            
            <exception cref="T:System.IO.FileLoadException">A key file exists at the path specified</exception>
            <exception cref="T:System.UnauthorizedAccessException">The key file path is read only</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.Extract(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription@,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams@)">
            <summary>
            Extract a KeyParams and CipherDescription
            </summary>
            
            <param name="Index">The index of the key set to extract</param>
            <param name="Description">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> that receives the cipher description</param>
            <param name="KeyParam">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> container that receives the key material from the file</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the key file could not be found</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.VolumeFactory.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg">
            <summary>
            <h3>SP20Drbg: A parallelized Salsa20 deterministic random byte generator implementation.</h3>
            <para>A Salsa20 key stream, parallelized and extended to use up to 30 rounds of diffusion.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new SP20Drbg())
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/14" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            <item><description>Parallel block size is 64,000 bytes by default; but is configurable.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator">
            <summary>
            Random Generator Interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Salt is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Salt does not contain enough material for Key and Vector creation</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Seed is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.IGenerator.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalRounds"/> property contains available sizes</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null or invalid salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if an invalid or null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if an invalid or null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Two state Seed paramater: 
            If Seed size is equal to cipher key size plus iv size, both are updated. 
            If Seed size is equal to counter size (8 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.KeySize">
            <summary>
            <para>The key size (in bytes) of the symmetric cipher</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalSeedSizes">
            <summary>
            Get: Available Seed Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if parallel block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.SP20Drbg.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256">
            <summary>
            <h3>SHA256: An implementation of the SHA-2 digest with a 256 bit digest return size</h3>.
            <para>The SHA-2<cite>Fips 180-4</cite> 256 digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new SHA256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA-2 <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.#ctor">
            <summary>
            Initialize the digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA256 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value [32 bytes]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value, Always 32 bytes</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BEToUInt32(System.Byte[],System.Int32)">
            <remarks>
            Big Endian to UInt32
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.UInt32ToBE(System.UInt32,System.Byte[],System.Int32)">
            <remarks>
            UInt32 to Big Endian
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.K1C">
            <remarks>
            the first 32 bits of the fractional parts of the cube roots of the first sixty-four prime numbers)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA256.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX">
            <summary>
            <h3>THX: A Twofish Cipher extended with an HKDF powered Key Schedule.</h3>
            <para>THX is an implementation of the Twofish<cite>Twofish</cite> block cipher combined with an HKDF powered Key Schedule.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new THX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 18, 20, 22, 24, 26, 28, 30 and 32, default is 16.</description></item>
            </list>
            
            <para>The number of transformation rounds processed is also user definable; from the standard 16 rounds, to a full 32 rounds of transformation.</para>
            
            <para>The key schedule in THX powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even the Twofish key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            THX is capable of processing up to 32 rounds, that is twice the number of rounds used in a standard implementation of Twofish. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">Fips 198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds"/> property contains available sizes. Default is 16 rounds.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.THX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSVerify">
            <summary>
            This class implements signature verification of the Winternitz one-time
            signature scheme (OTSS), described in C.Dods, N.P. Smart, and M. Stam, "Hash
            Based Digital Signature Schemes", LNCS 3796, pages 96&#8211;115, 2005. 
            The class is used by the GMSS classes.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSVerify.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Digest">The hash function used by the OTS and the provider</param>
            <param name="W">The Winternitz parameter</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSVerify.GetSignatureLength">
            <summary>
            The length of the one-time signature
            </summary>
            
            <returns>The signature length</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSVerify.Verify(System.Byte[],System.Byte[])">
            <summary>
            This method computes the public OTS key from the one-time signature of a message.
            This is *NOT* a complete OTS signature verification, but it suffices for usage with CMSS.
            </summary>
            
            <param name="Message">The message</param>
            <param name="Signature">The one-time signature</param>
            
            <returns>The public OTS key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.WinternitzOTSVerify.GetLog(System.Int32)">
            <summary>
            This method returns the least integer that is greater or equal to the 
            logarithm to the base 2 of an integer <c>Value</c>
            </summary>
            
            <param name="Value">An integer</param>
            
            <returns>Return The least integer greater or equal to the logarithm to the base 256 of <c>Value</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial">
            <summary>
            A <c>TernaryPolynomial</c> with a "high" number of nonzero coefficients.
            <para>Coefficients are represented as an array of length <c>N</c> containing ones, negative ones, and zeros.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial">
            <summary>
            A polynomial with <c>integer</c> coefficients.
            <para>Some methods (like <c>Add</c>) change the polynomial, others (like <c>Multiply</c>) do not,
            but return the result as a new polynomial.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial">
            <summary>
            Polynomial interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.Clear">
            <summary>
            Clear the state data
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by a <c>BigIntPolynomial</c>, taking the indices mod N. Does not
            change this polynomial but returns the result as a new polynomial.
            <para>Both polynomials must have the same number of coefficients.</para>
            </summary>
            
            <param name="Factor">The polynomial to multiply by</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the coefficient values mod <c>modulus</c> and the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            <param name="Modulus">The modulus to apply</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Coeffs">
            <summary>
            should be marked as internal
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.#cctor">
            <summary>
            Static Constructor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.#ctor(System.Int32)">
            <summary>
            Constructs a new polynomial with <c>N</c> coefficients initialized to 0
            </summary>
            
            <param name="N">The number of coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.#ctor(System.Int32[])">
            <summary>
            Constructs a new polynomial with a given set of coefficients
            </summary>
            
            <param name="Coeffs">The coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Constructs a <c>IntegerPolynomial</c> from a <c>BigIntPolynomial</c>. The two polynomials are independent of each other
            </summary>
            
            <param name="P">The original polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial)">
            <summary>
            Adds a <c>TernaryPolynomial</c> which must not have more coefficients than <c>this</c> polynomial.
            </summary>
            
            <param name="B">Another polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Adds another polynomial
            </summary>
            <param name="B">The polynomial to add</param> //p
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Adds another polynomial which must not have more coefficients than <c>this</c>
            polynomial, and takes the coefficient values mod <c>modulus</c>.
            </summary>
            
            <param name="B">The polynomial to add</param>
            <param name="Modulus">The modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Center0(System.Int32)">
            <summary>
            Shifts the values of all coefficients to the interval <c>[-q/2, q/2]</c>.
            </summary>
            
            <param name="Q">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.CenteredNormSq(System.Int32)">
            <summary>
            Computes the centered euclidean norm of the polynomial.
            </summary>
            
            <param name="Q">The Modulus</param>
            
            <returns>The centered norm</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Clear">
            <summary>
            Clear the coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Clone">
            <summary>
            Clone the polynomial
            </summary>
            <returns>The cloned polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Count(System.Int32)">
            <summary>
            Counts the number of coefficients equal to an integer
            </summary>
            
            <param name="Value">Value of an integer</param>
            
            <returns>The number of coefficients equal to <c>value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Divide(System.Int32)">
            <summary>
            Divides each coefficient by <c>k</c> and rounds to the nearest integer.
            <para>Does not return a new polynomial but modifies this polynomial.</para>
            </summary>
            
            <param name="Divisor">The divisor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.EnsurePositive(System.Int32)">
            <summary>
            Adds <c>modulus</c> until all coefficients are above 0.
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.EqualsOne">
            <summary>
            Tests if <c>p(x) = 1</c>.
            </summary>
            
            <returns>True iff all coefficients are equal to zero, except for the lowest coefficient which must equal 1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns a polynomial with N coefficients between <c>0</c> and <c>q-1</c>.
            </summary>
            
            <param name="Data">ata an encoded ternary polynomial</param>
            <param name="N"> number of coefficients</param>
            <param name="Q">Q value, must be a power of 2</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary(System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            Returns a polynomial with N coefficients between <c>0</c> and <c>q-1</c>.
            </summary>
            
            <param name="InputStream">An encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="Q">Q value, must be a power of 2</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary3Sves(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Decodes a byte array to a polynomial with <c>N</c> ternary coefficients.
            <para>Ignores any excess bytes.</para>
            </summary>
            
            <param name="Data">Data an encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="SkipFirst">Whether to leave the constant coefficient zero and start populating at the linear coefficient</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary3Tight(System.Byte[],System.Int32)">
            <summary>
            Converts a byte array produced by ToBinary3Tight() to a polynomial
            </summary>
            
            <param name="B">A byte array</param>
            <param name="N">The number of coefficients</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.FromBinary3Tight(System.IO.MemoryStream,System.Int32)">
            <summary>
            Reads data produced by ToBinary3Tight() from an input stream and converts it to a polynomial
            </summary>
            
            <param name="InputStream">An input stream</param>
            <param name="N">The number of coefficients</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.InvertF3">
            <summary>
            Computes the inverse mod 3.
            <para>Returns <c>null</c> if the polynomial is not invertible.
            The algorithm is described in <a href="http://www.securityinnovation.com/uploads/Crypto/NTRUTech014.pdf">
            Almost Inverses and Fast NTRU Key Generation</a>.</para>
            </summary>
            
            <returns>A new polynomial, or <c>null</c> if no inverse exists</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.InvertFq(System.Int32)">
            <summary>
            Computes the inverse mod <c>q; q</c> must be a power of 2.
            <para>Returns <c>null</c> if the polynomial is not invertible.
            The algorithm is described in <a href="http://www.securityinnovation.com/uploads/Crypto/NTRUTech014.pdf">
            Almost Inverses and Fast NTRU Key Generation</a>.</para>
            </summary>
            
            <param name="Q">The modulus</param>
            
            <returns>A new polynomial, or <c>null</c> if no inverse exists</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.IsInvertiblePow2">
            <summary>
            Tests if this polynomial is invertible modulo 2.
            <para>If a polynomial is invertible modulo 2, it is invertible modulo any power of 2.</para>
            </summary>
            
            <returns>Returns <c>true</c> if an inverse mod 2<sup>k</sup> for all k exists, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.IsReduced(System.Int32)">
            <summary>
            Tests whether all coefficients are between 0 and <c>modulus</c>
            </summary>
            
            <param name="Modulus">The Modulus</param>
            
            <returns>Returns <c>true</c> if <c>0 &lt; c &lt; modulus</c> for all coefficients</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.IsTernary">
            <summary>
            Tests id polynomial is ternary
            </summary>
            
            <returns>True if ternary</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mod(System.Int32)">
            <summary>
            Takes each coefficient modulo <c>modulus</c>.
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mod3">
            <summary>
            Takes each coefficient modulo 3 such that all coefficients are ternary.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ModCenter(System.Int32)">
            <summary>
            Reduces all coefficients to the interval [-modulus/2, modulus/2)
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ModPositive(System.Int32)">
            <summary>
            Ensures all coefficients are between 0 and <c>modulus-1</c>
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ModPositive4">
            <summary>
            Ensures all coefficients are between 0 and 3
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mult3(System.Int32)">
            <summary>
            Multiplies each coefficient by 3 and applies a modulus. Does not return a new polynomial but modifies this polynomial
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Multiply(System.Int32)">
            <summary>
            Multiplies each coefficient by a <c>int</c>. Does not return a new polynomial but modifies this polynomial.
            </summary>
            
            <param name="Factor">Integer factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial with another, taking the indices mod N
            </summary>
            <param name="Factor">The polynomial factor</param>
            
            <returns>Multiplied polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial with another, taking the indices mod N
            </summary>
            
            <param name="Factor">The polynomial factor</param>
            
            <returns>Multiplied polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial with another, taking the values mod modulus and the indices mod N
            </summary>
            
            <param name="Factor">The polynomial factor</param>
            <param name="Modulus">The Modulus</param>
            
            <returns>Multiplied polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Resultant">
            <summary>
            Resultant of this polynomial with <c>x^n-1</c> using a probabilistic algorithm.
            </summary>
            
            <remarks>
            <para>Unlike EESS, this implementation does not compute all resultants modulo primes
            such that their product exceeds the maximum possible resultant, but rather stops
            when <c>NUM_EQUAL_RESULTANTS</c> consecutive modular resultants are equal.
            This means the return value may be incorrect. Experiments show this happens in
            about 1 out of 100 cases when <c>N=439</c> and <c>NUM_EQUAL_RESULTANTS=2</c>,
            so the likelyhood of leaving the loop too early is <c>(1/100)^(NUM_EQUAL_RESULTANTS-1)</c>.</para>
            <para>Because of the above, callers must verify the output and try a different polynomial if necessary.</para>
            </remarks>
            
            <returns>Returns <c>(rho, res)</c> satisfying <c>res = rho*this + t*(x^n-1)</c> for some integer <c>t</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Rotate1">
            <summary>
            Multiplication by <c>X</c> in <c>Z[X]/Z[X^n-1]</c>.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Subtracts another polynomial which must not have more coefficients than <c>this</c> polynomial.
            </summary>
            
            <param name="B">The polynomial to subtract</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Resultant(System.Int32)">
            <summary>
            Resultant of this polynomial with <c>x^n-1 mod p</c>.
            </summary>
            
            <param name="P">P value</param>
            
            <returns>Returns <c>(rho, res)</c> satisfying <c>res = rho*this + t*(x^n-1) mod p</c> for some integer <c>t</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.SumCoeffs">
            <summary>
            Returns the sum of all coefficients, i.e. evaluates the polynomial at 1.
            </summary>
            
            <returns>The sum of all coefficients</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinary(System.Int32)">
            <summary>
            Encodes a polynomial whose coefficients are between 0 and q, to binary. q must be a power of 2.
            </summary>
            
            <param name="Q">Q value</param>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinary3Sves(System.Boolean)">
            <summary>
            Encodes a polynomial with ternary coefficients to binary.
            <para><c>coeffs[2*i]</c> and <c>coeffs[2*i+1]</c> must not both equal -1 for any integer <c>i</c>,
            so this method is only safe to use with polynomials produced by <c>fromBinary3Sves()</c>.</para>
            </summary>
            
            <param name="SkipFirst">Whether to skip the constant coefficient</param>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinary3Tight">
            <summary>
            Converts a polynomial with ternary coefficients to binary.
            </summary>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinaryTrunc(System.Int32,System.Int32)">
            <summary>
            Like ToBinary(int) but only returns the first <c>numBytes</c> bytes of the encoding.
            </summary>
            
            <param name="Q">Q value</param>
            <param name="NumBytes">Byte count</param>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToBinary4">
            <summary>
            Optimized version of ToBinary(int) for <c>q=4</c>.
            <para>Encodes the low 2 bits of all coefficients in a byte array.</para>
            </summary>
            
            <returns>A byte array equal to what <c>toBinary(4)</c> would return</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.InvertF2">
            <summary>
            Computes the inverse mod 2. 
            <para>The algorithm is described in <a href="http://www.securityinnovation.com/uploads/Crypto/NTRUTech014.pdf">
            Almost Inverses and Fast NTRU Key Generation</a>.</para>
            </summary>
            
            <returns>Returns <c>null</c> if the polynomial is not invertible.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mod2ToModq(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Computes the inverse mod <c>q</c> from the inverse mod 2.
            <para>The algorithm is described in <a href="http://www.securityinnovation.com/uploads/Crypto/NTRUTech014.pdf">
            Almost Inverses and Fast NTRU Key Generation</a>.</para>
            </summary>
            
            <param name="Fq">Fq value</param>
            <param name="Q">Q value</param>
            
            <returns>The inverse of this polynomial mod q</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Invert(System.Int32,System.Int32)">
            <remarks>
            Calculates the inverse of n mod modulus
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Pow(System.Int32,System.Int32,System.Int32)">
            <remarks>
            Calculates a^b mod modulus
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.MultShiftSub(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32,System.Int32,System.Int32)">
            <remarks>
             Computes this-b*c*(x^k) mod p and stores the result in this polynomial.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Degree">
            <remarks>
            Returns the degree of the polynomial
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Subtracts another polynomial which can have a different number of coefficients,
            and takes the coefficient values mod <c>modulus</c>.
            </summary>
            
            <param name="B">The polynomial to subtract</param>
            <param name="Modulus">The modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Subtract(System.Int32)">
            <summary>
            Subtracts a <c>int</c> from each coefficient. Does not return a new polynomial but modifies this polynomial.
            </summary>
            
            <param name="B">A number to subtract from each coefficient</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mult2(System.Int32)">
            <summary>
            Multiplies each coefficient by 2 and applies a modulus. Does not return a new polynomial but modifies this polynomial
            </summary>
            
            <param name="Modulus">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Mod2">
            <summary>
            Optimized version of ModPositive(2) //p
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.ShiftGap(System.Int32)">
            <summary>
            Shifts all coefficients so the largest gap is centered around <c>-q/2</c>.
            </summary>
            
            <param name="Q">The Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.EqualsZero">
            <summary>
            Tests if <c>p(x) = 0</c>.
            </summary>
            
            <returns>True if all coefficients are zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.EqualsAbsOne">
            <summary>
            Tests if <c>|p(x)| = 1</c>.
            </summary>
            
            <returns>True iff all coefficients are equal to zero, except for the lowest coefficient which must equal 1 or -1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.GetHashCode">
            <summary>
            Get the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial.Equals(System.Object)">
            <summary>
            Compare this integer polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial">
            <summary>
            A polynomial whose coefficients are all equal to -1, 0, or 1
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>, taking the indices mod N
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.GetOnes">
            <summary>
            Get the number of ones
            </summary>
            
            <returns>Ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.GetNegOnes">
            <summary>
            Get the number of negative ones
            </summary>
            
            <returns>negative ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.Size">
            <summary>
            Returns the maximum number of coefficients the polynomial can have
            </summary>
            
            <returns>Coefficients size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial.Clear">
            <summary>
            Clear the coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>DenseTernaryPolynomial</c> from a <c>IntegerPolynomial</c>. 
            <para>The two polynomials are independent of each other.</para>
            </summary>
            
            <param name="IntPoly">The original polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.#ctor(System.Int32[])">
            <summary>
            Constructs a new <c>DenseTernaryPolynomial</c> with a given set of coefficients.
            </summary>
            
            <param name="Coeffs">The coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GenerateBlindingPoly(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator,System.Int32,System.Int32)">
            <summary>
            Generates a blinding polynomial using an IndexGenerator
            </summary>
            
            <param name="Ig">An Index Generator</param>
            <param name="N">The number of coefficients</param>
            <param name="Dr">The number of ones / negative ones</param>
            
            <returns>A blinding polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GenerateRandom(System.Int32,System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a random polynomial with <c>NumOnes</c> coefficients equal to 1,
            <c>NumNegOnes</c> coefficients equal to -1, and the rest equal to 0.
            </summary>
            
            <param name="N">Number of coefficients</param>
            <param name="NumOnes">Number of 1's</param>
            <param name="NumNegOnes">Number of -1's</param>
            <param name="Rng">Random number generator</param>
            
            <returns>The generated polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GetNegOnes">
            <summary>
            Get the number of negative ones
            </summary>
            
            <returns>negative ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GetOnes">
            <summary>
            Get the number of ones
            </summary>
            
            <returns>Ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial with another, taking the values mod modulus and the indices mod N
            </summary>
            
            <param name="Factor">The polynomial factor</param>
            <param name="Modulus">The Modulus</param>
            
            <returns>Multiplied polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.Size">
            <summary>
            Returns the maximum number of coefficients the polynomial can have
            </summary>
            
            <returns>Coefficients size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GenerateBlindingCoeffs(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator,System.Int32,System.Int32)">
            <summary>
            Generates an <c>int</c> array containing <c>dr</c> elements equal to <c>1</c>
            and <c>dr</c> elements equal to <c>-1</c> using an index generator.
            </summary>
            
            <param name="Ig">An Index Generator</param>
            <param name="N">The number of coefficients</param>
            <param name="Dr">The number of ones / negative ones</param>
            
            <returns>An array containing numbers between <c>-1</c> and <c>1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.Equals(System.Object)">
            <summary>
            Compare this polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.DenseTernaryPolynomial.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField">
            <summary>
            This class implements the abstract class <c>GF2nField</c> for ONB representation.
            <para>It computes the fieldpolynomial, multiplication matrix and one of its roots mONBRoot,
            (see for example <a href="http://www2.certicom.com/ecc/intro.htm">Certicoms Whitepapers</a>).
            GF2nField is used by GF2nONBElement which implements the elements of this field.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField">
            <summary>
            This abstract class defines the finite field <c>GF(2 pow n)</c>.
            <para>It holds the extension degree <c>n</c>, the characteristic, the irreducible fieldpolynomial and conversion matrices. 
            GF2nField is implemented by the classes GF2nPolynomialField and GF2nONBField.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.DegreeN">
            <summary>
            The degree of this field 
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.FieldPoly">
            <summary>
            The irreducible fieldPolynomial stored in normal order (also for ONB)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.Fields">
            <summary>
            Holds a list of GF2nFields to which elements have been converted and thus a COB-Matrix exists
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.Matrices" -->
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.RandomRoot(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Computes a random root from the given irreducible fieldpolynomial according to IEEE 1363 algorithm A.5.6.
            <para>This calculation take very long for big degrees.</para>
            </summary>
            
            <param name="B0FieldPolynomial">The fieldpolynomial if the other basis as a Bitstring</param>
            
            <returns>Returns a random root of BOFieldPolynomial in representation according to this field</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.ComputeCOBMatrix(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField)">
            <summary>
            Computes the change-of-basis matrix for basis conversion according to 1363.
            <para>The result is stored in the lists fields and matrices.</para>
            </summary>
            
            <param name="B1">The GF2nField to convert to</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.ComputeFieldPolynomial">
            <summary>
            Computes the fieldpolynomial. This can take a long time for big degrees.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.InvertMatrix(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial[])">
            <summary>
            Inverts the given matrix represented as bitstrings
            </summary>
            
            <param name="MatrixN">The matrix to invert as a Bitstring[]</param>
            
            <returns>Returns <c>matrix^(-1)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.Convert(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField)">
            <summary>
            Converts the given element in representation according to this field to a new element in 
            representation according to B1 using the change-of-basis matrix calculated by computeCOBMatrix.
            </summary>
            
            <param name="Elem">The GF2nElement to convert</param>
            <param name="Basis">The basis to convert <c>Elem</c> to</param>
            
            <returns>Returns <c>Elem</c> converted to a new element representation according to <c>basis</c></returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.Degree">
            <summary>
            Get: Returns the degree <c>n</c> of this field
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField.FieldPolynomial">
            <summary>
            Get: Returns the fieldpolynomial as a new Bitstring
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Constructs an instance of the finite field with 2^degree elements and characteristic 2
            </summary>
            
            <param name="Degree">The extention degree of this field</param>
            <param name="Rand">The prng instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField.GetONBBit">
            <summary>
            Get the number of relevant bits in mONBPol[mLength-1]
            </summary>
            
            <returns>The relevant bits count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField.GetONBLength">
            <summary>
            Get the length of the array-representation of degree
            </summary>
            
            <returns>The length</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField.ComputeCOBMatrix(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField)">
            <summary>
            Computes the change-of-basis matrix for basis conversion according to 1363.
            The result is stored in the lists fields and matrices.
            </summary>
            
            <param name="B1">The GF2nField to convert to</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField.ComputeFieldPolynomial">
            <summary>
            Computes the field polynomial for a ONB according to IEEE 1363 A.7.2
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField.RandomRoot(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Computes a random root of the given polynomial
            </summary>
            
            <param name="P">A polynomial</param>
            
            <returns>A random root of the polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField.InvMatrix(System.Int32[][])">
            <summary>
            Compute the inverse of a matrix <c>A</c>
            </summary>
            
            <param name="A">The matrix</param>
            
            <returns>Returns <c>A^-1</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix">
            <summary>
            This class describes some operations with matrices over finite field GF(2) and is used in ecc and MQ-PKC (also has some specific methods and implementation).
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.#ctor(System.Byte[])">
            <summary>
            Create the matrix from encoded form
            </summary>
            
            <param name="Encoded">The encoded matrix</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.#ctor(System.Int32,System.Int32[][])">
            <summary>
            Create the matrix with the contents of the given array.
            <para>The matrix is not copied. Unused coefficients are masked out.</para>
            </summary>
            
            <param name="Columns">The number of columns</param>
            <param name="Matrix">The element array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.#ctor(System.Int32,System.Char,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create an nxn matrix of the given type
            </summary>
            
            <param name="N">The matrix size</param>
            <param name="MatrixType">The matrix type</param>
            <param name="SecRnd">The source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix)">
            <summary>
            Copy constructor
            </summary>
            
            <param name="A">A GF2Matrix to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.#ctor(System.Int32,System.Int32)">
            <summary>
            Create the mxn zero matrix
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.AddToRow(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Partially add one row to another
            </summary>
            
            <param name="FromRow">The addend</param>
            <param name="ToRow">The row to add to</param>
            <param name="StartIndex">The array index to start from</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.AssignZeroMatrix(System.Int32,System.Int32)">
            <summary>
            Create the mxn zero matrix
            </summary>
            <param name="M">Number of rows</param>
            <param name="N">Number of columns</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.AssignUnitMatrix(System.Int32)">
            <summary>
            Create the mxn unit matrix
            </summary>
            
            <param name="N">Number of rows (and columns)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.AssignRandomLowerTriangularMatrix(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create a nxn random lower triangular matrix
            </summary>
            
            <param name="N">Number of rows (and columns)</param>
            <param name="SecRnd">Source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.AssignRandomUpperTriangularMatrix(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create a nxn random upper triangular matrix
            </summary>
            
            <param name="N">Number of rows (and columns)</param>
            <param name="SecRnd">Source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.AssignRandomRegularMatrix(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create an nxn random regular matrix
            </summary>
            
            <param name="N">Number of rows (and columns)</param>
            <param name="SecRnd">Source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.SwapRows(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            Swap two rows of the given matrix
            </summary>
            
            <param name="NMatrix">The matrix</param>
            <param name="First">The index of the first row</param>
            <param name="Second">The index of the second row</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.Clear">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.ComputeTranspose">
            <summary>
            Compute the transpose of this matrix
            </summary>
            
            <returns>Returns <c>(this)^T</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.CreateRandomRegularMatrixAndItsInverse(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create a nxn random regular matrix and its inverse
            </summary>
            
            <param name="N">Number of rows (and columns)</param>
            <param name="SecRnd">Source of randomness</param>
            <returns>The created random regular matrix and its inverse</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.ExtendLeftCompactForm">
            <summary>
            Compute the full form matrix <c>(this | Id)</c> from this matrix in left compact form.
            <para>Where <c>Id</c> is the <c>k x k</c> identity matrix and <c>k</c> is the number of rows of this matrix.</para>
            </summary>
            
            <returns>Returns <c>(this | Id)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.ExtendRightCompactForm">
            <summary>
            Compute the full form matrix <c>(Id | this)</c> from this matrix in right compact form.
            <para>Where <c>Id</c> is the <c>k x k</c> identity matrix and <c>k</c> is the number of rows of this matrix.</para>
            </summary>
            
            <returns>Returns <c>(Id | this)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.HammingWeight">
            <summary>
            Returns the percentage of the number of "ones" in this matrix
            </summary>
            
            <returns>The Hamming weight of this matrix (as a ratio).</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.LeftMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Compute the product of a permutation matrix (which is generated from an n-permutation) and this matrix.
            </summary>
            
            <param name="P">The permutation</param>
            
            <returns>Returns GF2Matrix <c>P*this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.LeftMultiplyLeftCompactForm(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Compute the product of the matrix <c>(this | Id)</c> and a column vector.
            <para>Where <c>Id</c> is a <c>(numRows x numRows)</c> unit matrix.</para>
            </summary>
            
            <param name="V">The vector over GF(2)</param>
            
            <returns>Returns <c>(this | Id)*vector</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.LeftSubMatrix">
            <summary>
            Get the quadratic submatrix of this matrix consisting of the leftmost <c>numRows</c> columns
            </summary>
            
            <returns>Returns the <c>(numRows x numRows)</c> submatrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.RightMultiplyRightCompactForm(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Compute the product of the matrix <c>(Id | this)</c> and a column vector, where <c>Id</c> is a <c>(numRows x numRows)</c> unit matrix.
            </summary>
            
            <param name="V">The vector over GF(2)</param>
            
            <returns>Returns <c>(Id | this)*vector</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.RightSubMatrix">
            <summary>
            Get the submatrix of this matrix consisting of the rightmost <c>numColumns-numRows</c> columns
            </summary>
            
            <returns>Returns the <c>(numRows x (numColumns-numRows))</c> submatrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.RowAtIndex(System.Int32)">
            <summary>
            Return the row of this matrix with the given index
            </summary>
            
            <param name="Index">The index</param>
            
            <returns>The row of this matrix with the given index</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.ToIntArray">
            <summary>
            Get the matrix array
            </summary>
            
            <returns>The matrix array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.ComputeInverse">
            <summary>
            Compute the inverse of this matrix
            </summary>
            
            <returns>Returns the inverse of this matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.Equals(System.Object)">
            <summary>
            Compare this matrix with another object.
            </summary>
            
            <param name="Obj">The object to compare this to</param>
            <returns>Returns <c>true</c> if object is equal and has the same values</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.GetEncoded">
            <summary>
            Returns encoded matrix, i.e., this matrix in byte array form
            </summary>
            
            <returns>The encoded matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.GetHashCode">
            <summary>
            Computes the the hash code of this matrix
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.IsZero">
            <summary>
            Check if this is the zero matrix (i.e., all entries are zero).
            </summary>
            
            <returns>Returns <c>true</c> if this is the zero matrix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.LeftMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Compute product a row vector and this matrix
            </summary>
            
            <param name="V">A vector over GF(2)</param>
            <returns>Vector product <c>v*matrix</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Matrix)">
            <summary>
            Compute the product of this matrix and a matrix A over GF(2)
            </summary>
            
            <param name="M">A matrix A over GF(2)</param>
            
            <returns>Returns matrix product <c>this*M</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Compute the product of this matrix and a permutation matrix which is generated from an n-permutation
            </summary>
            
            <param name="P">The permutation</param>
            
            <returns>Returns GF2Matrix <c>this*P</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Compute the product of this matrix and the given column vector
            </summary>
            
            <param name="V">The vector over GF(2)</param>
            
            <returns>Returns <c>this*vector</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.ToString">
            <summary>
            Get a human readable form of the matrix
            </summary>
            
            <returns>Returns the matrix as a string</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix.Length">
            <summary>
            Get: Returns the length of each array representing a row of this matrix
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags">
            <summary>
            The flag indicating the type of service request
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.Internal">
            <summary>
            An internal error has occured
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.Refusal">
            <summary>
            The host refused the connection
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.Disconnected">
            <summary>
            The host was disconnected from the session
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.Resend">
            <summary>
            The host requires a re-transmission of the data
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.OutOfSequence">
            <summary>
            The host received data that was out of sequence
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.DataLost">
            <summary>
            The data can not be recovered, attempt a resync
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.Terminate">
            <summary>
            Tear down the connection
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.Resync">
            <summary>
            Response to a data lost messagem attempt to resync crypto stream
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.Echo">
            <summary>
            The response is an echo
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags.KeepAlive">
            <summary>
            The message is a keep alive
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricUtils">
            <summary>
            An asymmetric cipher components helper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricUtils.GetCipherType(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher)">
            <summary>
            Returns the cipher engine instance family type
            </summary>
            
            <param name="Cipher">An instance of an asymmetric cipher</param>
            
            <returns>The asymmetric family designator</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricUtils.GetKeyType(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Returns the asymmetric keys family type
            </summary>
            
            <param name="AsmKey">An asymmetric Public or Private key</param>
            
            <returns>The asymmetric family designator</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricUtils.GetParametersType(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters)">
            <summary>
            Returns the asymmetric parameters family type
            </summary>
            
            <param name="Parameters">An asymmetric ciphers Parameters</param>
            
            <returns>The asymmetric family designator</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricUtils.GetSignerType(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricSign)">
            <summary>
            Returns the signer engine instance family type
            </summary>
            
            <param name="Signer">An instance of an asymmetric signer</param>
            
            <returns>The asymmetric family designator</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Common.AsymmetricUtils.IsPublicKey(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Test if the asymmetric key is a Public key
            </summary>
            
            <param name="AsmKey">The asymmetric key</param>
            
            <returns>Returns <c>true</c> if it is a Public key, <c>false</c> for a private key</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">
            <summary>
            <h3>An implementation of a Hash based Message Authentication Code: HMAC<cite>Fips 198-1</cite>.</h3>
            <para>A HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new HMAC(new SHA256Digest(), [DisposeEngine]))
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>.</description></item>
            <item><description>Block size is the Digests engines block size.</description></item>
            <item><description>Digest size is the Digest engines digest return size.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            <item><description>NMAC and HMAC Security: <see href="http://cseweb.ucsd.edu/~mihir/papers/hmac-new.pdf">NMAC and HMAC Security Proofs</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">Message Digest instance</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Digest">Message Digest instance</param>
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the digest
            </summary>
            
            <param name="Input">Hash input data</param>
            <param name="InOffset">Starting position with the Input array</param>
            <param name="Length">Length of data to process</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>HMAC hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Completes processing and returns the HMAC code
            </summary>
            
            <param name="Output">Output array that receives the hash code</param>
            <param name="OutOffset">Offset within Output array</param>
            
            <returns>The number of bytes processed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the HMAC.
            <para>Uses the Key field of the KeyParams class.</para>
            </summary>
            
            <param name="KeyParam">The HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class.
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DigestSize"/> value.</para>
            </param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if the Key is null or less than digest size</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Reset">
            <summary>
            Reset and initialize the underlying digest
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Update(System.Byte)">
            <summary>
            Update the digest with 1 byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Logical">
            <summary>
            This class implements some logical operations over BigInteger.
            
            <description>The operations provided are:</description>
            <list type="bullet">
            <item><description>Not</description></item>
            <item><description>And</description></item>
            <item><description>AndNot</description>/></item>
            <item><description>Or</description>/></item>
            <item><description>Xor</description>/></item>
            </list>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Not(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is ~Value.
            <para>The result of this operation is <c>-this-1</c>.</para>
            </summary>
            
            <param name="Value">Value to be Not'ed</param>
            
            <returns>Returns <c>~Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.And(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one.
            </summary>
            
            <param name="Value">The value to be And'ed with X</param>
            <param name="X">The second value</param>
            
            <returns>
            Returns a new BigInteger whose value is <c>Value &amp; X</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.AndNot(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this &amp; ~Value</c>.
            <para>Evaluating <c>x.AndNot(Value)</c> returns the same result as <c>x.And(Value.Not())</c>.</para>
            </summary>
            
            <param name="Value">Value to be Not'ed and then And'ed</param>
            <param name="X">The second value</param>
            
            <returns><c>Value &amp; ~X</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Or(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this | Value</c>.
            </summary>
            
            <param name="Value">Value to be Or'ed</param>
            <param name="X">The second value</param>
            
            <returns>Returns <c>this | Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Logical.Xor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Value</c>
            </summary>
            
            <param name="Value">Value to be Xor'ed </param>
            <param name="X">The second value</param>
            
            <returns>Returns <c>this ^ Value</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.LittleEndian">
            <summary>
            This is a utility class containing data type conversions using little-endian byte order
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32)">
            <summary>
            Convert an integer to an octet string of length 4
            </summary>
            
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Convert an integer into a byte array beginning at the specified offset
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array to hold the result</param>
            <param name="Offset">The integer offset into the byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.IntToOctets(System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert an integer to a byte array beginning at the specified offset.
            <para>No length checking is performed (i.e., if the integer cannot be encoded with <c>length</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The byte array to hold the result</param>
            <param name="Offset">The integer offset into the byte array</param>
            <param name="Length">The length of the encoding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.LongToOctets(System.Int64)">
            <summary>
            Convert an integer to a byte array of length 8
            </summary>
            
            <param name="Input">The integer to convert</param>
            
            <returns>The converted integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.LongToOctets(System.Int64,System.Byte[],System.Int32)">
            <summary>
            Convert an integer to a byte array of length 8
            </summary>
            
            <param name="Input">The integer to convert</param>
            <param name="Output">The offset in output array</param>
            <param name="Offset">The byte array holding the output</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[])">
            <summary>
            Convert an octet string of length 4 to an integer
            </summary>
            
            <param name="Input">The byte array holding the octet string</param>
            
            <returns>Returns an integer representing the octet string <c>Input</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[],System.Int32)">
            <summary>
            Convert an byte array of length 4 beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToInt(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Convert a byte array of the given length beginning at <c>offset</c> into an integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            <param name="Length">The length of the encoding</param>
            
            <returns>The resulting integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.OctetsToLong(System.Byte[],System.Int32)">
            <summary>
            Convert a byte array of length 8 beginning at <c>inOff</c> into a long integer
            </summary>
            
            <param name="Input">The byte array</param>
            <param name="Offset">The offset into the byte array</param>
            
            <returns>The resulting long integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.ToByteArray(System.Int32[],System.Int32)">
            <summary>
            Convert an int array to a byte array of the specified length.
            <para>No length checking is performed (i.e., if the last integer cannot be encoded with <c>length % 4</c> octets, it is truncated).</para>
            </summary>
            
            <param name="Input">The int array</param>
            <param name="Length">The length of the converted array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.LittleEndian.ToIntArray(System.Byte[])">
            <summary>
            Convert a byte array to an int array
            </summary>
            
            <param name="Input">The byte array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession">
            <summary>
            Session Key structure; contains a minimal description of the symmetric cipher.
            <para>Used to define a symmetric ciphers parameters, implemented with minimal overhead. 
            For use in defining the symmetric cipher parameters over an asymmetric channel.</para>
            </summary>
            
            <example>
            <description>Example of creating a <c>SessionParams</c> structure:</description>
            <code>
             // initialize with CipherDescription structure containing all of the settings used by the cipher instance
             SessionParams session = new SessionParams(BlockCiphers.RDX, 32, IVSizes.V128);
            </code>
            <description>Example of writing a KeyParams class to a <c>SessionParams</c> structure:</description>
            <code>
             // write key material to the stream
             SessionParams.SetKey(keyStream, keyParams);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/03/12" version="1.3.2.0">Initial release</revision>
            <revision date="2015/07/02" version="1.4.0.0">Changes to documentation and method structure</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmClient structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmIdentity structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmPacket structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmParameters class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmKex class</seealso>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.EngineType">
            <summary>
            The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Engine</see> type
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.KeySize">
            <summary>
            The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes">Key Size</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.IvSize">
            <summary>
            Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes">Initialization Vector</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.RoundCount">
            <summary>
            The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts">Rounds</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.KdfEngine">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            SessionParams constructor
            </summary>
            
            <param name="EngineType">The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers">Engine</see> type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes">Initialization Vector</see></param>
            <param name="RoundCount">The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts">Rounds</see></param>
            <param name="KdfEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid KeyId, MessageKey, or ExtensionKey is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.#ctor(System.IO.Stream)">
            <summary>
            Initialize the SessionParams structure using a Stream
            </summary>
            
            <param name="SessionStream">The Stream containing the SessionParams</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.#ctor(System.Byte[])">
            <summary>
            Initialize the SessionParams structure using a byte array
            </summary>
            
            <param name="SessionArray">The byte array containing the SessionParams</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.IsValid(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession)">
            <summary>
            Get this is a valid header file
            </summary>
            
            <param name="Key">The stream containing a key header</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.ToBytes">
            <summary>
            Convert the SessionParams structure as a byte array
            </summary>
            
            <returns>The byte array containing the SessionParams</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.ToStream">
            <summary>
            Convert the SessionParams structure to a MemoryStream
            </summary>
            
            <returns>The MemoryStream containing the SessionParams</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.GetKey(System.IO.Stream)">
            <summary>
            Get the key data from the key stream
            </summary>
            
            <param name="KeyStream">The stream containing a session key</param>
            
            <returns>KeyParams structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.SetKey(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Write the key data from the key stream
            </summary>
            
            <param name="KeyStream">The stream containing a session key</param>
            <param name="KeyParam">KeyParams class containing the keying material</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.SetKey(System.IO.Stream,System.Byte[])">
            <summary>
            Write the key data from the key stream
            </summary>
            
            <param name="KeyStream">The stream containing a session key</param>
            <param name="KeyData">A byte array containing the keying material</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.op_Equality(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession)">
            <summary>
            Compare this object instance is equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession.op_Inequality(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession)">
            <summary>
            Compare this object instance is not equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Not equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">
            <summary>
            <h3>HKDF: An implementation of an Hash based Key Derivation Function.</h3>
            <para>HKDF as outlined in RFC 5869<cite>RFC 5869</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new HKDF(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC HMAC</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 5869: <see href="http://tools.ietf.org/html/rfc5869">Specification</see>.</description></item>
            <item><description>HKDF Scheme: <see href="http://tools.ietf.org/html/rfc5869">Whitepaper</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a HKDF Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac)">
            <summary>
            Creates a HKDF Bytes Generator based on the given HMAC function
            </summary>
            
            <param name="Hmac">The HMAC digest used</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Hmac is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if the output buffer is too small, or the size requested exceeds maximum: 255 * HashLen bytes</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">
            <summary>
            Wraps exceptions thrown within a Asymmetric cipher operational context.
            <para>This exception is used throughout the Asymmetric cipher domain.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators">
            <summary>
            Seed Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators.CSPRsg">
            <summary>
            A Secure Seed Generator using RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators.XSPRsg">
            <summary>
            A Secure Seed Generator using an Xor+ generator
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX">
            <summary>
            <h3>SHX: A Serpent cipher extended with an HKDF powered Key Schedule.</h3>
            <para>SHX is a Serpent<cite>Serpent</cite> implementation that uses an HKDF generator to expand the user supplied key into a working key integer array.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new SHX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 32, 40, 48, 56, 64, 80, 96 and 128, default is 64.</description></item>
            </list>
            
            <para>It also takes a user defined number of rounds between 32 (the standard number of rounds), all the way up to 128 rounds in 8 round sets. 
            A round count of 40 or 48 is more than sufficient, as theoretical attacks to date are only able to break up to 12 rounds; and would require an enormous amount of memory and processing power.
            The transform in SHX is identical to the Serpent implementation SPX, it process rounds by first moving the byte input array into 4 integers, then processing the rounds in a while loop. 
            Each round consists of an XOR of each state word (<math>Rn</math>) with a key, an S-Box transformation of those words, and then a linear transformation. 
            Each of the 8 S-Boxes are used in succession within a loop cycle. The final round XORs the last 4 keys with the state and shifts them back into the output byte array.</para>
            
            <para>The key schedule in SHX powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            SHX is capable of processing up to 128 rounds, that is four times the number of rounds used in a standard implementation of Serpent. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds"/> property contains available sizes. Default is 32 rounds.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container.<para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib0(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvSO - {13, 3,11, 0,10, 6, 5,12, 1,14, 4, 7,15, 9, 8, 2 } - 15 terms.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb1(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S1 - {15,12, 2, 7, 9, 0, 5,10, 1,11,14, 8, 6,13, 3, 4 } - 14 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib1(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS1 - { 5, 8, 2,14,15, 6,12, 3,11, 4, 7, 9, 1,13,10, 0 } - 14 steps
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb2(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S2 - { 8, 6, 7, 9, 3,12,10,15,13, 1,14, 4, 0,11, 5, 2 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib2(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS2 - {12, 9,15, 4,11,14, 1, 2, 0, 3, 6,13, 5, 8,10, 7 } - 16 steps
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb3(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S3 - { 0,15,11, 8,12, 9, 6, 3,13, 1, 2, 4,10, 7, 5,14 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib3(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS3 - { 0, 9,10, 7,11,14, 6,13, 3, 5,12, 2, 4, 8,15, 1 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb4(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S4 - { 1,15, 8, 3,12, 0,11, 6, 2, 5, 4,10, 9,14, 7,13 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib4(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS4 - { 5, 0, 8, 3,10, 9, 7,14, 2,12,11, 6, 4,15,13, 1 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb5(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S5 - {15, 5, 2,11, 4,10, 9,12, 0, 3,14, 8,13, 6, 7, 1 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib5(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS5 - { 8,15, 2, 9, 4, 1,13,14,11, 6, 5, 3, 7,12,10, 0 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb6(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S6 - { 7, 2,12, 5, 8, 4, 6,11,14, 9, 1,15,13, 3,10, 0 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib6(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS6 - {15,10, 1,13, 5, 3, 6, 0, 4, 9,14, 7, 2,12, 8,11 } - 15 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Sb7(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            S7 - { 1,13,15, 0,14, 8, 2,11, 7, 4,12,10, 9, 3, 5, 6 } - 16 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Ib7(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            InvS7 - { 3, 0, 6,13, 9,14,15, 8, 5,12,11, 7,10, 1, 4, 2 } - 17 terms
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LinearTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.InverseTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the inverse of the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SHX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil">
            <summary>
            This class is needed for the conversions while encoding and decoding, as well as for comparison between arrays of some dimensions
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.ConvertArraytoInt(System.Byte[])">
            <summary>
            This function converts an one-dimensional array of bytes into a one-dimensional array of int
            </summary>
            
            <param name="Input">The array to be converted</param>
            
            <returns>The one-dimensional int-array that corresponds the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.ConvertArray(System.Byte[])">
            <summary>
            This function converts an one-dimensional array of bytes into a one-dimensional array of type short
            </summary>
            
            <param name="Input">The array to be converted</param>
            
            <returns>A one-dimensional short-array that corresponds the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.ConvertArray(System.Byte[][])">
            <summary>
            This function converts a matrix of bytes into a matrix of type short
            </summary>
            
            <param name="Input">The matrix to be converted</param>
            
            <returns>A short-matrix that corresponds the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.ConvertArray(System.Byte[][][])">
            <summary>
            This function converts a 3-dimensional array of bytes into a 3-dimensional array of type short
            </summary>
            
            <param name="Input">The array to be converted</param>
            
            <returns>A short-array that corresponds the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.ConvertArray(System.Int16[])">
            <summary>
            This function converts an array of type short into an array of type byte
            </summary>
            
            <param name="Input">The array to be converted</param>
            
            <returns>The byte-array that corresponds the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.ConvertIntArray(System.Int32[])">
            <summary>
            This function converts an array of type int into an array of type byte
            </summary>
            
            <param name="Input">The array to be converted</param>
            
            <returns>The byte-array that corresponds the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.ConvertArray(System.Int16[][])">
            <summary>
            This function converts a matrix of type short into a matrix of type byte
            </summary>
            
            <param name="Input">The matrix to be converted</param>
            
            <returns>The byte-matrix that corresponds the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.ConvertArray(System.Int16[][][])">
            <summary>
            This function converts a 3-dimensional array of type short into a 3-dimensional array of type byte
            </summary>
            
            <param name="Input">The array to be converted</param>
            
            <returns>The byte-array that corresponds the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.Equals(System.Int16[],System.Int16[])">
            <summary>
            Compare two short arrays
            </summary>
            
            <param name="A">The first short array</param>
            <param name="B">The second short array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.Equals(System.Int16[][],System.Int16[][])">
            <summary>
            Compare two two-dimensional short arrays
            </summary>
            
            <param name="A">The first short array</param>
            <param name="B">The second short array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.RainbowUtil.Equals(System.Int16[][][],System.Int16[][][])">
            <summary>
            Compare two three-dimensional short arrays
            </summary>
            
            <param name="A">The first short array</param>
            <param name="B">The second short array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSRandom">
            <summary>
            This class provides a PRNG for GMSS
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSRandom.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="DigestTree">A hash digest instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSRandom.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSRandom.NextSeed(System.Byte[])">
            <summary>
            Computes the next seed value, returns a random byte array and sets outseed to the next value
            </summary>
            
            <param name="OutSeed">A byte array in which ((1 + SEEDin +RAND) mod 2^n) will be</param>
            
            <returns>Returns byte array of H(SEEDin)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSRandom.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial">
            <summary>
            A <c>TernaryPolynomial</c> with a "low" number of nonzero coefficients.
            <para>Coefficients are represented as two arrays, one containing the indices of one-values
            and the other containing indices of negative ones.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.#ctor(System.Int32,System.Int32[],System.Int32[])">
            <summary>
            Constructs a new polynomial
            </summary>
            
            <param name="N">Total number of coefficients including zeros</param>
            <param name="Ones">Indices of coefficients equal to 1 in ascending order</param>
            <param name="NegOnes">Indices of coefficients equal to -1 in ascending order</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>DenseTernaryPolynomial</c> from a <c>IntegerPolynomial</c>.
            <para>The two polynomials are independent of each other.</para>
            </summary>
            
            <param name="IntPoly">The original polynomial></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.#ctor(System.Int32[])">
            <summary>
            Constructs a new <c>SparseTernaryPolynomial</c> with a given set of coefficients.
            </summary>
            
            <param name="Coeffs">The coefficients</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Throws if the coefficients are not ternary</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Clear">
            <summary>
            Clear the coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.FromBinary(System.IO.MemoryStream,System.Int32)">
            <summary>
            Decodes a polynomial encoded with ToBinary()
            </summary>
            
            <param name="InputStream">An input stream containing an encoded polynomial</param>
            <param name="N">Number of coefficients in the polynomial</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GenerateBlindingPoly(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.IndexGenerator,System.Int32,System.Int32)">
            <summary>
            Generates a blinding polynomial using an IndexGenerator
            </summary>
            
            <param name="Ig">An Index Generator</param>
            <param name="N">The number of coefficients</param>
            <param name="Dr">The number of ones / negative ones</param>
            
            <returns>A blinding polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GenerateRandom(System.Int32,System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a random polynomial with <c>numOnes</c> coefficients equal to 1,
            <c>numNegOnes</c> coefficients equal to -1, and the rest equal to 0.
            </summary>
            
            <param name="N">Number of coefficients</param>
            <param name="NumOnes">Number of 1's</param>
            <param name="NumNegOnes">Number of -1's</param>
            <param name="Rng">Random number generator</param>
            
            <returns>The new SparseTernaryPolynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GetNegOnes">
            <summary>
            Get the number of negative ones
            </summary>
            
            <returns>negative ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GetOnes">
            <summary>
            Get the number of ones
            </summary>
            
            <returns>Ones count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the coefficient values mod <c>modulus</c> and the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            <param name="Modulus">The modulus to apply</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by a <c>BigIntPolynomial</c>, taking the indices mod N. Does not
            change this polynomial but returns the result as a new polynomial.
            <para>Both polynomials must have the same number of coefficients.</para>
            </summary>
            
            <param name="Factor">The polynomial to multiply by</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.ToBinary">
            <summary>
            Encodes the polynomial to a byte array writing <c>BITS_PER_INDEX</c> bits for each coefficient
            </summary>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that Multiply(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Size">
            <summary>
            Returns the maximum number of coefficients the polynomial can have
            </summary>
            
            <returns>Coefficients size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.Equals(System.Object)">
            <summary>
            Compare this polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial.GetHashCode">
            <summary>
            Get the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair">
            <summary>
            An Ntru Key-Pair container
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Constructs a new key pair
            </summary>
            
            <param name="PublicKey">The Public key</param>
            <param name="PrivateKey">The Private Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Constructs a new key pair
            </summary>
            
            <param name="Key">The public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid name is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.#ctor(System.IO.MemoryStream)">
            <summary>
            Reads a key pair from an input stream.
            <para>Note: both keys must be present in the stream; ordered Public, Private.</para>
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key pair</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.#ctor(System.Byte[])">
            <summary>
            Reads a key pair  from a byte array.
            <para>Note: both keys must be present in the stream; ordered Public, Private.</para>
            </summary>
            
            <param name="KeyArray">An byte array containing an encoded key pair</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.IsValid">
            <summary>
            Tests if the key pair is valid.
            <para>See IEEE 1363.1 section 9.2.4.1.</para>
            </summary>
            
            <returns>if the key pair is valid, <c>true</c> otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.ToBytes">
            <summary>
            Converts the key pair to a byte array
            </summary>
            
            <returns>The encoded key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.ToStream">
            <summary>
            Returns the current key pair set as a MemoryStream
            </summary>
            
            <returns>NtruKeyPair as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.WriteTo(System.Byte[])">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">NtruKeyPair as a byte array; can be initialized as zero bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the key pair to an output byte array
            </summary>
            
            <param name="Output">NtruKeyPair as a byte array; can be initialized as zero bytes</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.WriteTo(System.IO.Stream)">
            <summary>
            Writes the key pair to an output stream
            </summary>
            
            <param name="Output">Output Stream</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an IO exception is raised</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Clone">
            <summary>
            Create a copy of this key pair instance
            </summary>
            
            <returns>The IAsymmetricKeyPair copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.Name">
            <summary>
            Get: KeyPair name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.PrivateKey">
            <summary>
            Returns the private key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair.PublicKey">
            <summary>
            Returns the public key
            </summary>
            
            <returns>The public key</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher">
            <summary>
            This class implements the Fujisaki/Okamoto conversion of the McEliecePKCS
            </summary>
            <remarks>
            <para>Fujisaki and Okamoto propose hybrid encryption that merges a symmetric encryption scheme which is secure in the find-guess model with 
            an asymmetric one-way encryption scheme which is sufficiently probabilistic to obtain a public key cryptosystem which is CCA2-secure. 
            For details, see D. Engelbert, R. Overbeck, A. Schmidt, "A summary of the development of the McEliece Cryptosystem", technical report.</para>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.IMPKCCiphers">
            <summary>
            McEliece cipher interface
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.IMPKCCiphers.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher
            </summary>
            
            <param name="AsmKey">The public or private key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.IMPKCCiphers.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.IMPKCCiphers.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.IMPKCCiphers.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.OID">
            <summary>
            The OID of the algorithm
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Paramaters">The cipher parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.GetKeySize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Return the key size of the working key
            </summary>
            
            <returns>The size of the key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey"/> for encryption, or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey"/> for decryption</para>
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the McEliece public or private key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.FujisakiCipher.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can decrypt
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.RandomDegree">
            <summary>
            Extends the IRandom class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.RandomDegree.NextInt(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,System.Int32)">
            <summary>
            Get a random number using a degree over a polynomial field
            </summary>
            <param name="SecRnd">The IRandom instance</param>
            <param name="N">The polynomial degree</param>
            
            <returns>A random number</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient">
            <summary>
            The DtmClient structure.
            <para>The DtmClient structure is used to store data that uniquely identifies the host.</para>
            </summary>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmParameters class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmIdentity structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmPacket structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmSession structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmKex class</seealso>
            
            <revisionHistory>
            <revision date="2015/05/23" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <para>The PublicId field is a byte array used as a unique id, presented to other operators as a host identifier 
            during the <c>Auth-Stage</c> of the key exchange.
            The SecretId is a byte array that can be a serialized object like a key, or code, and is used to identify 
            the host during the <c>Primary-Stage</c> of the key exchange.</para>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.PublicId">
            <summary>
            The <c>Auth-Stage</c> Public Identity field
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.SecretId">
            <summary>
            The <c>Primary-Stage</c> Secret Identity field
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.OptionsFlag">
            <summary>
            The options flag; can be used as additional information about the client structure
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.#ctor(System.Byte[],System.Byte[],System.Int64)">
            <summary>
            The DtmClient primary constructor
            </summary>
            
            <param name="PublicId">The <c>Auth-Stage</c> Public Identity</param>
            <param name="SecretId">The <c>Primary-Stage</c> Secret Identity</param>
            <param name="OptionsFlag">A flag used for additional information</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.#ctor(System.Byte[])">
            <summary>
            Extracts a DtmClient from a byte array
            </summary>
            
            <param name="ClientArray">The byte array containing the DtmClient structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.#ctor(System.IO.Stream)">
            <summary>
            Constructs a DtmClient from a stream
            </summary>
            
            <param name="ClientStream">Stream containing a serialized DtmClient</param>
            
            <returns>A populated DtmClient</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.DeSerialize(System.IO.Stream)">
            <summary>
            Deserialize an DtmClient
            </summary>
            
            <param name="ClientStream">Stream containing a serialized DtmClient</param>
            
            <returns>A populated DtmClient</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.Serialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient)">
            <summary>
            Serialize an DtmClient structure
            </summary>
            
            <param name="Client">A DtmClient structure</param>
            
            <returns>A stream containing the DtmClient data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.ToBytes">
            <summary>
            Returns the DtmClient as an encoded byte array
            </summary>
            
            <returns>The serialized DtmClient</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient.ToStream">
            <summary>
            Returns the DtmClient as an encoded MemoryStream
            </summary>
            
            <returns>The serialized DtmClient</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.IntUtils">
            <summary>
            An integer utilities class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.BitCount(System.Int32)">
            <summary>
            Returns the number of one-bits in the two's complement binary 
            representation of the specified int value. 
            <para>This function is sometimes referred to as the population count.</para>
            </summary>
            
            <param name="X">The value whose bits are to be counted</param>
            
            <returns>The number of one-bits in the two's complement binary representation of the specified int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.BitCount(System.Int64)">
            <summary>
            Returns the number of bits in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of bits in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.DeepCopy(System.Int32[])">
            <summary>
            Create a copy of an array
            </summary>
            <param name="A">The array to copy</param>
            
            <returns>Returns the array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.DoubleToLong(System.Double)">
            <summary>
            Convert a double to a long value
            </summary>
            
            <param name="X">Double to convert</param>
            
            <returns>Long value representation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.FloatToInt(System.Single)">
            <summary>
            Copy a floats bits to an integer
            </summary>
            
            <param name="X">Float to convert</param>
            
            <returns>The integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.HighestOneBit(System.Int32)">
            <summary>
            Returns the highest order 1 bit in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the highest order 1 bit in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.HighestOneBit(System.Int64)">
            <summary>
            Returns the highest order 1 bit in a number
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the highest order 1 bit in a number</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntToBytes(System.Int32)">
            <summary>
            Copy an integer to a byte array
            </summary>
            
            <param name="X">Integer to copy</param>
            
            <returns>The integer bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntsToBytes(System.Int32[])">
            <summary>
            Copy an array of integers to a byte array
            </summary>
            
            <param name="X">Array of integers</param>
            
            <returns>The integers bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.IntToFloat(System.Int32)">
            <summary>
            Copy an integer bits to a float
            </summary>
            
            <param name="X">Integer to copy</param>
            
            <returns>The float</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfLeadingZeros(System.Int32)">
            <summary>
            Returns the leading number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of leading zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfLeadingZeros(System.Int64)">
            <summary>
            Returns the leading number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of leading zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfTrailingZeros(System.Int32)">
            <summary>
            Returns the trailing number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of trailing zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.NumberOfTrailingZeros(System.Int64)">
            <summary>
            Returns the trailing number of zero bits
            </summary>
            
            <param name="X">Number to test</param>
            
            <returns>Returns the number of trailing zeros</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ParseInt(System.String)">
            <summary>
            Parses the string argument as a signed decimal integer. 
            </summary>
            
            <param name="S">A String containing the int representation to be parsed</param>
            
            <returns>The integer value represented by the argument in decimal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ParseInt(System.String,System.Int32)">
            <summary>
            Parses the string argument as a signed integer in the radix specified by the second argument. 
            </summary>
            
            <param name="S">The String containing the integer representation to be parsed</param>
            <param name="Radix">The radix to be used while parsing</param>
            
            <returns>The integer represented by the string argument in the specified radix</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReadShort(System.IO.Stream)">
            <summary>
            Read a short value (16 bits) from a stream
            </summary>
            
            <param name="InputStream">Stream containing the short value</param>
            
            <returns>The Int16 value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseBytes(System.Byte[])">
            <summary>
            Reverse a byte array order and copy to an integer
            </summary>
            
            <param name="Data">The byte array to reverse</param>
            
            <returns>The reversed integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseBytes(System.Int32)">
            <summary>
            Reverse the byte order of an integer
            </summary>
            
            <param name="Value">The integer value to reverse</param>
            
            <returns>The reversed integer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ReverseInt(System.Int32)">
            <summary>
            Returns the value obtained by reversing the order of the bits in the 
            two's complement binary representation of the specified int value
            </summary>
            
            <param name="X">The value to be reversed</param>
            
            <returns>The value obtained by reversing order of the bits in the specified int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.Signum(System.Int64)">
            <summary>
            Returns the signum function of the specified long value. 
            <para>The return value is -1 if the specified value is negative;
            0 if the specified value is zero; and 1 if the specified value is positive.</para>
            </summary>
            
            <param name="X">The value whose signum is to be computed</param>
            
            <returns>The signum function of the specified long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ToString(System.Int32)">
            <summary>
            Convert an integer to a string
            </summary>
            
            <param name="X">The integer to convert</param>
            <returns>Returns the integer as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.ToString(System.Int64)">
            <summary>
            Convert a long integer to a string
            </summary>
            
            <param name="X">The long integer to convert</param>
            <returns>Returns the long integer as a string</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.URShift(System.Int32,System.Int32)">
            <summary>
            Operates an unsigned right shift on the given integer by the number of bits specified
            </summary>
            
            <param name="X">The number to shift</param>
            <param name="NumBits">The number of bits to shift the given number</param>
            
            <returns>
            Returns an <see cref="T:System.Int32">int</see> representing the shifted number.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.IntUtils.URShift(System.Int64,System.Int32)">
            <summary>
            Operates an unsigned right shift on the given integer by the number of bits specified
            </summary>
            
            <param name="X">The number to shift</param>
            <param name="NumBits">The number of bits to shift the given number</param>
            
            <returns>
            Returns an <see cref="T:System.Int64">long integer</see> representing the shifted number.
            </returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.DirectoryTools">
            <summary>
            Folder methods wrapper class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.Create(System.String)">
            <summary>
            Create a folder
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.Checked(System.String)">
            <summary>
            Test for directory and create
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.Exists(System.String)">
            <summary>
            Test for directory
            </summary>
            
            <param name="DirectoryPath">Full path to folder</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.FileCount(System.String)">
            <summary>
            Get the number of files in a directory
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>Count</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.GetFiles(System.String,System.IO.SearchOption,System.String)">
            <summary>
            Return all the files in a directory
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            <param name="Option">Get all files (default) or only the top directory</param>
            <param name="Filter">Search file filter, default is all files</param>
            
            <returns>File names [string]]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.GetCommon(System.Environment.SpecialFolder)">
            <summary>
            Get common directories
            </summary>
            
            <param name="FolderPath">Folder enum</param>
            
            <returns>Directory [string]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.GetPath(System.String)">
            <summary>
            Get file directory from path
            </summary>
            
            <param name="FilePath">File path</param>
            
            <returns>Directory [string]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.GetSize(System.String)">
            <summary>
            Return all the files in a directory
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            
            <returns>File names [string]]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.HasPermission(System.String,System.Security.AccessControl.FileSystemRights)">
            <summary>
            Test a directory for create file access permissions
            </summary>
            
            <param name="DirectoryPath">Full path to file or directory </param>
            <param name="AccessRight">File System right tested</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.IsWritable(System.String)">
            <summary>
            Directory can write/create
            </summary>
            
            <param name="DirectoryPath">Directory path</param>
            
            <returns>Success</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.CanCreate(System.String)">
            <summary>
            Test a directory for create file access permissions
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.CanWrite(System.String)">
            <summary>
            Test a directory for write file access permissions
            </summary>
            
            <param name="DirectoryPath">Full directory path</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.AddAccessRule(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Add an access rule to a folder
            </summary>
            
            <param name="Path">Folder path</param>
            <param name="User">UNC path to user profile ex. Environment.UserDomainName + "\\" + Environment.UserName</param>
            <param name="Rights">Desired file system rights</param>
            <param name="Access">Desired level of access</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.AddSecurity(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Add a file system right to a directory
            </summary>
            
            <param name="Path">Full path to directory</param>
            <param name="Account">UNC path to user profile</param>
            <param name="Rights">Desired file system rights</param>
            <param name="ControlType">Access control type</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.GetAccessRules(System.String,System.String)">
            <summary>
            Get access rules for a folder
            </summary>
            
            <param name="Path">Folder path</param>
            <param name="Account">UNC path to user profile</param>
            
            <returns>Rule collection [AuthorizationRuleCollection]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.DirectoryTools.RemoveSecurity(System.String,System.String,System.Security.AccessControl.FileSystemRights,System.Security.AccessControl.AccessControlType)">
            <summary>
            Remove a file system right to a directory
            </summary>
            
            <param name="FileName">Full path to directory</param>
            <param name="Account">UNC path to user profile</param>
            <param name="Rights">Desired file system rights</param>
            <param name="ControlType">Access control type</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.MathContext">
            <summary>
            Immutable objects describing settings such as rounding mode and digit precision for the numerical operations 
            provided by class <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal128">
            <summary>
            A MathContext which corresponds to the IEEE 754r quadruple decimal precision format: 34 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal32">
            <summary>
            A MathContext which corresponds to the IEEE 754r single decimal precision format: 7 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Decimal64">
            <summary>
            A MathContext which corresponds to the IEEE 754r double decimal precision format: 16 digit precision and RoundingMode.HalfEven rounding
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.MathContext.Unlimited">
            <summary>
            A MathContext for unlimited precision with RoundingMode.HalfUp rounding
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.Int32)">
            <summary>
            Constructs a new MathContext with the specified precision and with the rounding mode RoundingMode.HalfUp.
            <para>If the precision passed is zero, then this implies that the computations have to be performed exact, the rounding mode in this case is irrelevant.</para>
            </summary>
            
            <param name="Precision">The precision for the new MathContext</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Constructs a new MathContext with the specified precision and with the specified rounding mode.
            <para>If the precision passed is zero, then this implies that the computations have to be performed exact, the rounding mode in this case is irrelevant.</para>
            </summary>
            
            <param name="Precision">The precision for the new MathContext</param>
            <param name="RoundingMode">The rounding mode for the new MathContext</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the Precision is less than zero</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.#ctor(System.String)">
            <summary>
            Constructs a new MathContext from a string.
            <para>The string has to specify the precision and the rounding mode to be used and has to follow the following syntax:
            "Precision=&lt;Precision&gt; RoundingMode=&lt;RoundingMode&gt;"
            This is the same form as the one returned by the ToString method.</para>
            </summary>
            
            <param name="Value">A string describing the precision and rounding mode for the new MathContext</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the string is not in the correct format or if the Precision specified is &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.Equals(System.Object)">
            <summary>
            Returns true if Obj is a MathContext with the same precision setting and the same rounding mode as this MathContext instance.
            </summary>
            
            <param name="Obj">bject to be compared</param>
            
            <returns>Returns true if this MathContext instance is equal to the Obj argument, false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.GetHashCode">
            <summary>
            Returns the hash code for this MathContext instance
            </summary>
            
            <returns>Returns the hash code for this MathContext</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.MathContext.ToString">
            <summary>
            Returns the string representation for this MathContext instance
            <para>The string has the form "Precision=&lt;Precision&gt; RoundingMode=&lt;RoundingMode&gt;" 
            where &lt;Precision&gt; is an integer describing the number of digits used for operations and
            &lt;RoundingMode&gt; is the string representation of the rounding mode.</para>
            </summary>
            
            <returns>Returns a string representation for this MathContext instance</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.MathContext.Precision">
            <summary>
            Returns the precision.
            <para>The precision is the number of digits used for an operation.</para>
            </summary>
            
            <remarks>
            <para>Results are rounded to this precision.
            The precision is guaranteed to be non negative.
            If the precision is zero, then the computations have to be performed exact,
            results are not rounded in this case.</para></remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.MathContext.RoundingMode">
            <summary>
            Returns the rounding mode.
            <para>The rounding mode is the strategy to be used to round results.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Elementary">
            <summary>
            Static library that provides the basic arithmetic mutable operations for BigInteger.
            
            <description>The operations provided are:</description>
            <list type="bullet">
            <item><description>Addition</description></item>
            <item><description>Subtraction</description></item>
            <item><description>Comparison</description>/></item>
            </list>
            
            <para>In addition to this, some Inplace (mutable) methods are provided.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.Add(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            See BigInteger#add(BigInteger)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompareArrays(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Compares two arrays. All elements are treated as unsigned integers. 
            <para>The magnitude is the bit chain of elements in big-endian order.</para>
            </summary>
            
            <param name="A">The first array</param>
            <param name="B">The second array</param>
            <param name="Size">Size the size of arrays</param>
            
            <returns>Returns 1 if A > B, -1 if A &lt; B, 0 if A == B</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompleteInPlaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Same as InplaceAdd(BigInteger, BigInteger), but without the restriction of non-positive values
            </summary>
            
            <param name="A">The operand</param>
            <param name="B">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.CompleteInPlaceSubtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Same as InplaceSubtract(BigInteger, BigInteger), but without the restriction of non-positive values
            <para>Op1 should have enough space to save the result</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The subtrahend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs Op1 += Op2.
            <para>Op1 must have enough place to store the result (i.e. Op1.BitLength() >= Op2.BitLength()). 
            Both should be positive (i.e. Op1 >= Op2).</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Adds an integer value to the array of integers remembering carry
            </summary>
            
            <param name="A">The input minuend</param>
            <param name="ASize">The minuend size</param>
            <param name="Addend">The addend</param>
            
            <returns>A possible generated carry (0 or 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceAdd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs: Op1 += Addend. 
            <para>The number must have a place to hold a possible carry.</para>
            </summary>
            
            <param name="A">The operand</param>
            <param name="Addend">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.InplaceSubtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs Op1 -= Op2. 
            <para>Op1 must have enough place to store the result (i.e. Op1.BitLength() >= Op2.BitLength()).
            Both should be positive (what implies that Op1 >= Op2).</para>
            </summary>
            
            <param name="A">The input minuend, and the output result</param>
            <param name="B">The subtrahend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Elementary.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            See BigInteger#subtract(BigInteger)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Division">
            <summary>
            Static library that provides all operations related with division and modular arithmetic to <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/>.
            <para>Some methods are provided in both mutable and immutable way.</para>
            
            <description>There are several variants provided listed below:</description>
            <list type="bullet">
            <item><description>BigInteger Division and Remainder operations</description></item>
            <item><description>Modular exponentiation between BigInteger</description></item>
            <item><description>Modular inverse of a BigInteger numbers</description>/&gt;</item>
            <item><description>BigInteger division and remainder by int</description></item>
            </list>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.Divide(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32[],System.Int32)">
            <summary>
            Divides the array 'a' by the array 'b' and gets the quotient and the remainder.
            <para>Implements the Knuth's division algorithm. See D. Knuth, The Art of Computer Programming, 
            vol. 2. Steps D1-D8 correspond the steps in the algorithm description.</para>
            </summary>
            
            <param name="Quotient">The quotient</param>
            <param name="QuotientLen">The quotient's length</param>
            <param name="X">The dividend</param>
            <param name="XLen">The dividend's length</param>
            <param name="Y">The divisor</param>
            <param name="YLength">The divisor's length</param>
            
            <returns>eturn the remainder</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.DivideAndRemainderByInteger(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,System.Int32)">
            <summary>
            Computes the quotient and the remainder after a division by an int number
            </summary>
            
            <param name="Value">The BigInteger dividend</param>
            <param name="Divisor">The divisor</param>
            <param name="DivisorSign">The divisors sign</param>
            
            <returns>Returns an array of the form <c>[quotient, remainder]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.DivideArrayByInt(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Divides an array by an integer value. Implements the Knuth's division algorithm.
            <para>See D. Knuth, The Art of Computer Programming, vol. 2.</para>
            </summary>
            
            <param name="Destination">The quotient</param>
            <param name="Source">The dividend</param>
            <param name="SourceLength">The length of the dividend</param>
            <param name="Divisor">The divisor</param>
            
            <returns>Returns the remainder</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.EvenModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs modular exponentiation using the Montgomery Reduction.
            <para>It requires that all parameters be positive and the modulus be even.
            Based on theThe square and multiply algorithm and the Montgomery Reduction 
            C. K. Koc - Montgomery Reduction with Even Modulus.
            The square and multiply algorithm and the Montgomery Reduction.
            ar.org.fitc.ref "C. K. Koc - Montgomery Reduction with Even Modulus"
            </para>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Y">The Exponent</param>
            <param name="Modulus">The Modulus</param>
            
            <returns><c>x1 + q * y</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.GcdBinary(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Return the greatest common divisor of X and Y
            </summary>
            
            <param name="X">Operand 1, must be greater than zero</param>
            <param name="Y">Operand 2, must be greater than zero</param>
            
            <returns>Returns <c>GCD(X, Y)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.GcdBinary(System.Int64,System.Int64)">
            <summary>
            Performs the same as GcdBinary(BigInteger, BigInteger)}, but with numbers of 63 bits, 
            represented in positives values of long type.
            </summary>
            
            <param name="X">A positive number</param>
            <param name="Y">A positive number></param>
            
            <returns>Returns <c>Gcd(X, Y)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.InplaceModPow2(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs <c>X = X Mod (2<sup>N</sup>)</c>
            </summary>
            <param name="X">A positive number, it will store the result</param>
            <param name="N">A positive exponent of 2</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.ModInverseMontgomery(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Calculates x.modInverse(p) Based on: Savas, E; Koc, C "The Montgomery Modular Inverse - Revised"
            </summary>
            
            <param name="X">BigInteger X</param>
            <param name="P">BigInteger P</param>
            
            <returns>Returns <c>1/X Mod M</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.MultiplyAndSubtract(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Multiplies an array by int and subtracts it from a subarray of another array
            </summary>
            
            <param name="X">The array to subtract from</param>
            <param name="Start">The start element of the subarray of X</param>
            <param name="Y">The array to be multiplied and subtracted</param>
            <param name="YLength">The length of Y</param>
            <param name="Multiplier">The multiplier of Y</param>
            
            <returns>Returns the carry element of subtraction</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.OddModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs modular exponentiation using the Montgomery Reduction.
            <para>It requires that all parameters be positive and the modulus be odd. </para>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Y">The exponent</param>
            <param name="Modulus">The modulus</param>
            
            <returns><c>(modulus[0]^(-1)) (mod 2^32)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Divides a BigInteger by a signed int and returns the remainder
            </summary>
            
            <param name="X">The BigInteger to be divided. Must be non-negative</param>
            <param name="Divisor">A signed integer</param>
            
            <returns>Returns Divide % Divisor</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Division.RemainderArrayByInt(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Divides an array by an integer value. Implements the Knuth's division
            algorithm. See D. Knuth, The Art of Computer Programming, vol. 2.
            </summary>
            
            <param name="Source">The dividend</param>
            <param name="SourceLength">The length of the dividend</param>
            <param name="Divisor">The divisor</param>
            
            <returns>Returns the remainder</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg">
            <summary>
            <h3>DGTDRBG: An implementation of a Digest Counter based Deterministic Random Byte Generator.</h3>
            <para>A Digest Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new DGTDRBG(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">digest</see>.</description></item>
            <item><description>Combination of [Salt, Ikm, Nonce] must be at least: digest block size + counter (8 bytes) size in length.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            <item><description>Output buffer is 4 * the digest return size.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90A: <see href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">Appendix E1.</see></description></item>
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Digest">Hash function</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if an invalid or null salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if an invalid or null salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Info value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if an invalid or null salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Three state Seed paramater: 
            If Seed size is equal to digest blocksize plus counter size, both are updated. 
            If Seed size is equal to digest block size, internal state seed is updated.
            If Seed size is equal to counter size (8 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null or invalid Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.DGCDrbg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC">
            <summary>
            <h3>An implementation of a Variably Modified Permutation Composition based Message Authentication Code: VMPC-MAC.</h3>
            <para>A VMPC-MAC as outlined in the VMPC-MAC Specification<cite>VMPC-MAC</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new VMPCMAC(new RDX()))
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>No fixed block size is used.</description></item>
            <item><description>MAC return size is 20 bytes.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>VMPC-MAC Specification: <see href="http://www.vmpcfunction.com/vmpc_mac.pdf">VMPC-MAC: A Stream Cipher Based Authenticated Encryption Scheme</see>.</description></item>
            <item><description>VMPC Paper: <see href="http://www.vmpcfunction.com/vmpcmac.htm>VMPC-MAC">VMPC-MAC Authenticated Encryption Scheme</see>.</description></item>
            <item><description>IETF: <see href="http://www.okna.wroc.pl/vmpc.pdf">VMPC One-Way Function and Stream Cipher</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Mac hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="OutOffset">The offset in the data</param>
            
            <returns>The number of bytes processed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the VMPC MAC.
            <para>Uses the Key and IV fields of the KeyParams class.</para>
            </summary>
            
            <param name="KeyParam">VMPCMAC Key and IV.
            <para>Uses the Key and IV fields of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class.
            Key and IV must be between 1 and 768 bytes in length.
            Key and IV should be equal in size.</para>
            </param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if a null or invalid Key, or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.InitKey(System.Byte[],System.Byte[])">
            <remarks>
            Section 3.2, table 2 <see href="http://vmpcfunction.com/vmpc_mac.pdf">VMPC-MAC: 
            A Stream Cipher Based Authenticated Encryption Scheme</see>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes.
            <para>Not used in VMPCMAC: Block size is variable.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.VMPCMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey">
            <summary>
            The PackageKey structure. 
            <para>Contains the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority"/> structure with identity and origin, attached policies, a description of the sub-key sets, 
            and the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> structure containing the description of the cipher.</para>
            <para>Used to create a key file that contains a series of Key, and optional Vector and Ikm sets. 
            A key set; the keying material assigned to a subkey, is valid for only one cycle of encryption, 
            guaranteeing that unique key material is used for every encryption cycle, but allowing for a key that can perform many
            encryptions while still exerting the maximum amount of security.</para>
            </summary>
            
            <example>
            <description>Example of populating a <c>PackageKey</c> structure:</description>
            <code>
               PackageKey package = new PackageKey(
                   keypol,      // a KeyAuthority structure containing originating identity, the master policy flag, and authentication info
                   cpdesc       // CipherDescription structure containing all of the settings used by the cipher instance
                   10);         // number of key sets contained in this package
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/03/12" version="1.3.2.0">Initial release</revision>
            <revision date="2015/07/02" version="1.4.0.0">Changes to documentation and method structure</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory">VTDev.Libraries.CEXEngine.Crypto PackageFactory class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures PackageKey structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures KeyAuthority structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">VTDev.Libraries.CEXEngine.Crypto.Enumeration KeyPolicies Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates">VTDev.Libraries.CEXEngine.Crypto KeyStates Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">VTDev.Libraries.CEXEngine.Crypto.Processing StreamCipher class</seealso>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.KeyPolicy">
            <summary>
            The master key policy flags, used to determine encryption state
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.CreatedOn">
            <summary>
            The creation date/time of this key in milliseconds
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.Authority">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority">KeyAuthority</see> structure containing the key authorization schema.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.Description">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">CipherDescription</see> structure containing a complete description of the cipher instance.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.ExtensionKey">
            <summary>
            An array of random bytes used to encrypt a message file extension. A null value auto generates this field.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeyCount">
            <summary>
            The number of Key Sets contained in this key package file.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeyPolicy">
            <summary>
            A <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeyPolicy">KeyPolicy</see> array that contains the policy flags for each sub key set
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeyID">
            <summary>
            An array of unique 16 byte fields that identify each sub key set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.#ctor(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,System.Int32,System.Byte[])">
            <summary>
            A PackageKey header structure. 
            </summary>
            
            <param name="Authority">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority">KeyAuthority</see> structure containing the key authorization schema.</param>
            <param name="Cipher">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">CipherDescription</see> structure containing a complete description of the cipher instance.</param>
            <param name="SubKeyCount">The number of Key Sets contained in this key package file.</param>
            <param name="ExtensionKey">An array of random bytes used to encrypt a message file extension. A null value auto generates this field.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if an invalid ExtensionKey is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.#ctor(System.IO.Stream)">
            <summary>
            Initialize the PackageKey structure using a Stream
            </summary>
            
            <param name="KeyStream">The Stream containing the PackageKey</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.#ctor(System.Byte[])">
            <summary>
            Initialize the PackageKey structure using a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the PackageKey</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.Reset">
            <summary>
            Reset all members of the PackageKey structure, 
            including the CipherDescription and KeyAuthority structures
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.ToBytes">
            <summary>
            Convert the PackageKey structure as a byte array
            </summary>
            
            <returns>The byte array containing the PackageKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.ToStream">
            <summary>
            Convert the PackageKey structure to a MemoryStream
            </summary>
            
            <returns>The MemoryStream containing the PackageKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetHeaderSize(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey)">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <param name="Package">The key package structure</param>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetPolicyOffset">
            <summary>
            Get policy flag offset
            </summary>
            
            <returns>offset size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetKeyPolicy(System.IO.Stream)">
            <summary>
            Get the key master policy flags
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>Key policy flags</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetCreatedOn(System.IO.Stream)">
            <summary>
            Get the creation date/time timestamp (in milliseconds)
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>Created on timestamp</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetKeyAuthority(System.IO.Stream)">
            <summary>
            Get the KeyAuthority structure
            </summary>
            
            <param name="KeyStream">The stream containing a KeyAuthority structure</param>
            
            <returns>KeyAuthority structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetCipherDescription(System.IO.Stream)">
            <summary>
            Get the cipher description header
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>CipherDescription structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetExtensionKey(System.IO.Stream)">
            <summary>
            Get the extension key (16 bytes)
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>The file extension key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetSubKeyCount(System.IO.Stream)">
            <summary>
            Get the number of subkey sets contained in the key package
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>Number of subkey sets</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetSubKeyPolicies(System.IO.Stream)">
            <summary>
            Get the subkey policy flags contained in the key package
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>Policy flag array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetSubKeyIds(System.IO.Stream)">
            <summary>
            Get the subkey identity arrays
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>Subkey id arrays</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SetKeyPolicy(System.IO.Stream,System.Int64)">
            <summary>
            Set the Key master policy flag
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Flags">Key policy flags</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SetCreatedOn(System.IO.Stream,System.Int64)">
            <summary>
            Set the Key package creation time
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="TimeStamp">Creation Date/Time in milliseconds</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SetKeyAuthority(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority)">
            <summary>
            Set the KeyAuthority structure
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Authority">The CipherDescription structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SetCipherDescription(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription)">
            <summary>
            Set the CipherDescription structure
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Description">The CipherDescription structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SetExtensionKey(System.IO.Stream,System.Byte[])">
            <summary>
            Set the ExtensionKey
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="ExtensionKey">Array of 16 bytes containing the ExtensionKey</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SetSubKeyCount(System.IO.Stream,System.Int32)">
            <summary>
            Set the Key package SubKey Count
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Count">Number of SubKeys in the package</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SetSubKeyIds(System.IO.Stream,System.Byte[][])">
            <summary>
            Set the SubKeyId arrays
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="KeyIds">Array of SubKey Id arrays</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SetSubKeyPolicies(System.IO.Stream,System.Int64[])">
            <summary>
            Set the Key package SubKey Policy flags
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Policies">Array of SubKey policy flags</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.AtIndex(System.IO.Stream,System.Int32)">
            <summary>
            Get the key/iv at a given index
            </summary>
            
            <param name="KeyStream">The stream containing the PackageKey</param>
            <param name="Index">The index value</param>
            
            <returns>A populated KeyParams class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.Contains(System.IO.Stream,System.Byte[])">
            <summary>
            Test if the PackageKey contains a file id
            </summary>
            
            <param name="KeyStream">The stream containing the PackageKey</param>
            <param name="Id">The subkey id</param>
            
            <returns>Returns true if the file id is known, otherwizse false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.FromId(System.IO.Stream,System.Byte[])">
            <summary>
            Get the key/iv associated with a file id
            </summary>
            
            <param name="KeyStream">The stream containing the PackageKey</param>
            <param name="Id">The file id</param>
            
            <returns>A populated KeyParams class, or null if the key is not found</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.IndexFromId(System.IO.Stream,System.Byte[])">
            <summary>
            Find a subkey index position within the stream
            </summary>
            <param name="KeyStream">The stream containing a PackageKey structure</param>
            <param name="KeyId">The unique identifies of the sub key</param>
            
            <returns>The index or -1 if the subkey was not found</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.KeyCount(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies)">
            <summary>
            Returns the number of keys in the package with the specified policy value
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="KeyPolicy">The key policy to search</param>
            
            <returns>The number of keys with that policy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.KeyHasPolicy(System.Int64,System.Int64)">
            <summary>
            Test if a specific KeyPolicy is within a policy group
            </summary>
            
            <param name="PolicyGroup">Policies group as an integer</param>
            <param name="KeyPolicy">Policy to test for existence</param>
            
            <returns>True if it contains the KeyPolicy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetIndex(System.IO.Stream,System.Byte[])">
            <summary>
            Get the index of the file id in the VolumeKey
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="Id">The key id</param>
            
            <returns>Returns the index, or <c>-1</c> if not found</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.NextSubkey(System.IO.Stream)">
            <summary>
            Gets the next subkey available for encryption
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>Index of subkey, or -1 for empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeyClearPolicies(System.IO.Stream,System.Int32)">
            <summary>
            Clear all policy flags from the KeyPolicy at the specified Index
            </summary>
            
            <param name="KeyStream">The stream containing a key package, changes are written to this stream</param>
            <param name="Index">Index of KeyPolicy within the KeyPolicies array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the Indexed value does not exist</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeyClearPolicy(System.IO.Stream,System.Int32,System.Int64)">
            <summary>
            Clear the KeyPolicy flag from the KeyPolicy at the specified Index
            </summary>
            
            <param name="KeyStream">The stream containing a PackageKey, changes are written to this stream</param>
            <param name="Index">Index of KeyPolicy within the KeyPolicies array</param>
            <param name="KeyPolicy">KeyPolicy flag to clear</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the Indexed value does not exist</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeyHasPolicy(System.IO.Stream,System.Int32,System.Int64)">
            <summary>
            Test if a specific KeyPolicy is within a policy group
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Index">Index of KeyPolicy within the KeyPolicies array</param>
            <param name="KeyPolicy">Policy to test for existence</param>
            
            <returns>True if it contains the KeyPolicy</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the Indexed value does not exist</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeyOffset(System.IO.Stream,System.Byte[])">
            <summary>
            Gdet the starting position of the key material (key/iv/mac key) of a specific subkey within the key package file
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="KeyId">The unique identifies of the sub key</param>
            
            <returns>The starting position index of the key material</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.SubKeySetPolicy(System.IO.Stream,System.Int32,System.Int64)">
            <summary>
            Set a policy flag on a member of the KeyPolicies array
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Index">Index of KeyPolicy within the KeyPolicies array</param>
            <param name="KeyPolicy">Policy flag to add to the KeyPolicy</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the Indexed value does not exist</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.op_Equality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey)">
            <summary>
            Compare this object instance is equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey.op_Inequality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey)">
            <summary>
            Compare this object instance is not equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Not equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority">
            <summary>
            The KeyAuthority structure.
            <para>Contains origin information, authentication controls data, and policy flags that determine how a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/> is processed.</para>
            </summary>
            
            <example>
            <description>Example of defining a KeyAuthority structure:</description>
            <code>
            // populate the KeyAuthority structure; used for key identity, post creation control, and layered authorization.
            // see the PolicyFlags enumeration and KeyAuthority class for more information
            KeyAuthority keyAuth = new KeyAuthority(
               _domainId,                      // can be a domain path, a shared secret, or a target identity
               _originId,                      // the unique id of the creator of this key package
               _pkgId,                         // can uniquely identify the software that created this key package, or the package itself
               _pkgTag,                        // can be a friendly name, storage for a layered authentication scheme, or details about this package or provider
               KeyPolicies.NoNarrative |       // policy flag; the target of this key has limited knowledge about the keys construction and origin
               KeyPolicies.PostOverwrite);     // policy flag; each package subkey can be read only once for decryption, after which it is overwritten in the key package file
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/03/12" version="1.3.2.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory">VTDev.Libraries.CEXEngine.Crypto PackageFactory class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures PackageKey structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">VTDev.Libraries.CEXEngine.Crypto.Enumeration KeyPolicies Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates">VTDev.Libraries.CEXEngine.Crypto KeyStates Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">VTDev.Libraries.CEXEngine.Crypto.Processing StreamCipher class</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>The <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.DomainId"/> 32 byte field can be used to authenticate a domain when used with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies"/> DomainAuth policy flag.</description></item>
            <item><description>The <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.OriginId"/> is used to identify the creator of the key and is unique to each installation. This id can be used as a secret id in a trust relationship.</description></item>
            <item><description>A <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.PackageId"/> 32 byte field can be used as a software id, or as an authentication string if using the <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.PackageAuth"/> policy flag.</description></item>
            <item><description>A <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.PackageTag"/> field is a 32 byte description field that can contain a package or creator description string.</description></item>
            <item><description>The <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.KeyPolicy"/> is a master flag; all subkeys in this package will use the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies"/> defined by this flag.</description></item>
            <item><description>The <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.OptionFlag"/> when used with the <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.Volatile"/> policy flag, stores the date/time in Ticks, after which this key must be expired or destroyed.</description></item>
            </list>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.DomainId">
            <summary>
            Domain identity; a 32 byte field that can describe the domain, a description, or contain a secret shared by a group. 
            <para>When combined with the KeyPolicy DomainRestrict flag, acts as an authentication key</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.OriginId">
            <summary>
            Origin identity; a unique 16 byte value identifying the node that created this key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.TargetId">
            <summary>
            Target identity; a unique 16 byte value identifying the target node
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.PackageId">
            <summary>
            A unique 32 byte field identity of this package
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.PackageTag">
            <summary>
            A 32 byte field containing an optional package description or authentication code
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.KeyPolicy">
            <summary>
            A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">KeyPolicy</see> master flag that contains the policy flags applied to each sub key set
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.OptionFlag">
            <summary>
            Used by KeyPolicy if the flag is set to <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.Volatile">Volatile</see>, set as the expiration date/time in Ticks
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.#ctor(System.Byte[],System.Byte[],System.Byte[],System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies,System.Int32,System.Byte[])">
            <summary>
            KeyAuthority constructor.
            </summary>
            
            <param name="DomainId">Domain identity; a 16 byte field that can describe the domain, a description, or contain a secret shared by a group</param>
            <param name="OriginId">Origin identity; a unique 16 byte value identifying the node that created this key</param>
            <param name="PackageId">A unique 16 byte field used for storage or as identity of this package</param>
            <param name="PackageTag">A 32 byte field containing an optional package description or authentication code</param>
            <param name="KeyPolicy">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">KeyPolicy</see> master flag that contains the policy flags applied to each subkey set</param>
            <param name="OptionFlag">Used by KeyPolicy if the flag is set to <see cref="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies.Volatile">Volatile</see>, set as the key expiration date/time in Ticks</param>
            <param name="TargetId">The hashed value of the targets origin id field, used to authenticate a target installation. A null value generates zeros.</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.#ctor(System.IO.Stream)">
            <summary>
            Initialize the KeyAuthority structure using a Stream
            </summary>
            
            <param name="AuthorityStream">The Stream containing the KeyAuthority</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.#ctor(System.Byte[])">
            <summary>
            Initialize the KeyAuthority structure using a byte array
            </summary>
            
            <param name="AuthorityArray">The byte array containing the KeyAuthority</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.IsValid(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority)">
            <summary>
            Get this is a valid header file
            </summary>
            
            <param name="Authority">The stream containing a KeyAuthority structure</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.Reset">
            <summary>
            Reset all members of the KeyAuthority structure
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.ToBytes">
            <summary>
            Convert the KeyAuthority structure as a byte array
            </summary>
            
            <returns>The byte array containing the KeyAuthority</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.ToStream">
            <summary>
            Convert the KeyAuthority structure to a MemoryStream
            </summary>
            
            <returns>The MemoryStream containing the KeyAuthority</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.op_Equality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority)">
            <summary>
            Compare this object instance is equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority.op_Inequality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority)">
            <summary>
            Compare this object instance is not equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Not equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng">
            <summary>
            <h3>DGCPrng: An implementation of a Digest Counter based Random Number Generator.</h3>
            <para>Uses a Digest Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new DGCPrng([Digests])
                num = rnd.Next([Minimum], [Maximum]);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">digest</see>.</description></item>
            <item><description>Can use either a random seed generator for initialization, or a user supplied Seed array.</description></item>
            <item><description>Numbers generated with the same seed will produce the same random output.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90A: <see href="http://csrc.nist.gov/publications/nistpubs/800-90A/SP800-90A.pdf">Appendix E1.</see></description></item>
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="SeedEngine">The Seed engine used to create the salt (default is CSPRsg)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if the buffer size is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is digest blocksize + 8)</param>
            <param name="DigestEngine">The digest that powers the rng (default is Keccak512)</param>
            <param name="BufferSize">The size of the internal state buffer in bytes; must be at least 128 bytes size (default is 1024)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if the seed is null or buffer size is too small; (min. seed = digest blocksize + 8)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Reset">
            <summary>
            Reset the DGCPrng instance
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.DGCPrng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">
            <summary>
            Symmetric Encryption Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.ChaCha">
            <summary>
            An implementation of the ChaCha Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.Fusion">
            <summary>
            An implementation of the Twofish and Rijndael Merged Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.RDX">
            <summary>
            An extended implementation of the Rijndael Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.RHX">
            <summary>
            An implementation based on the Rijndael Block Cipher, using HKDF with a SHA512 HMAC for expanded key generation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.RSM">
            <summary>
            An implementation based on the Rijndael and Serpent Merged Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.Salsa">
            <summary>
            A Salsa20 Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.SPX">
            <summary>
            An extended implementation of the Serpent Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.SHX">
            <summary>
            The Serpent Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.TFX">
            <summary>
            An extended implementation of the Twofish Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.THX">
            <summary>
            A Twofish Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines.TSM">
            <summary>
            An implementation based on the Twofish and Serpent Merged Block Ciphers, using an HKDF Key Schedule
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts">
            <summary>
            Rounds Count. Can be cast as round count integers, 
            i.e. (int ct = RoundCounts.R12) is equal to 12.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R8">
            <summary>
            8 Rounds: ChaCha
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R10">
            <summary>
            10 Rounds: ChaCha, RHX, RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R12">
            <summary>
            12 Rounds: ChaCha, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R14">
            <summary>
            14 Rounds: ChaCha, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R16">
            <summary>
            16 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R18">
            <summary>
            18 Rounds: ChaCha, Fusion, RSM, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R20">
            <summary>
            20 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R22">
            <summary>
            22 Rounds: ChaCha, Fusion, RHX, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R24">
            <summary>
            24 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R26">
            <summary>
            26 Rounds: ChaCha, Fusion, RSM, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R28">
            <summary>
            28 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R30">
            <summary>
            30 Rounds: ChaCha, Fusion, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R32">
            <summary>
            32 Rounds: Fusion, SHX, SPX, TFX, THX, TSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R34">
            <summary>
            34 Rounds, RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R38">
            <summary>
            38 Rounds, RHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R40">
            <summary>
            40 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R42">
            <summary>
            42 Rounds: RSM
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R48">
            <summary>
            48 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R56">
            <summary>
            56 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R64">
            <summary>
            64 Rounds: SHX, SPX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R80">
            <summary>
            80 Rounds: SHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R96">
            <summary>
            96 Rounds: SHX
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts.R128">
            <summary>
            128 Rounds: SHX
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs">
            <summary>
            Message Authentication Code Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.CMAC">
            <summary>
            A Cipher based Message Authentication Code wrapper (CMAC)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.HMAC">
            <summary>
            A Hash based Message Authentication Code wrapper (HMAC)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.SHA256HMAC">
            <summary>
            SHA256 Hash based Message Authentication Code
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.SHA512HMAC">
            <summary>
            SHA512 Hash based Message Authentication Code
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs.VMPCMAC">
            <summary>
            A Variably Modified Permutation Composition based Message Authentication Code (VMPC-MAC)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024">
            <summary>
            <h3>Skein1024: An implementation of the Skein digest with a 1024 bit digest return size.</h3>
            <para>SHA-3 finalist<cite>NIST IR7896</cite>: The Skein<cite>Skein</cite> digest</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Skein1024())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/03/10" version="1.3.0.0">Added Initialize call to Ctor</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Block size is 128 bytes, (1024 bits).</description></item>
            <item><description>Digest size is 128 bytes, (1024 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods, and resets the internal state.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DoFinal(System.Byte[],System.Int32)"/> method does NOT reset the internal state; call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> to reinitialize.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>The Skein Hash Function Family: <see href="http://www.skein-hash.info/sites/default/files/skein1.1.pdf">Skein V1.1</see>.</description></item>
            <item><description>Skein <see href="http://www.skein-hash.info/sites/default/files/skein-proofs.pdf">Provable Security</see> Support for the Skein Hash Family.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Adapted from the excellent project by Alberto Fajardo: <see href="http://code.google.com/p/skeinfish/">Skeinfish Release 0.50</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Initializes the Skein hash instance
            </summary>
            
            <param name="InitializationType">Digest initialization type <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType"/></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value.
            <para>Note: <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> is called post hash calculation.</para> 
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DoFinal(System.Byte[],System.Int32)">
            <summary>
            <para>Do final processing and get the hash value. 
            Note: Digest is not reset after calling DoFinal. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset"/> must be called before a new hash can be generated.</para>
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Initialize(VTDev.Libraries.CEXEngine.Crypto.Digest.SkeinInitializationType)">
            <summary>
            Used to re-initialize the digest state.
            <para>Creates the initial state with zeros instead of the configuration block, then initializes the hash. 
            This does not start a new UBI block type, and must be done manually.</para>
            </summary>
            
            <param name="InitializationType">Initialization parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Update(System.Byte)">
            <summary>
            Update the message digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SkeinConfig">
            <remarks>
            Default configuration
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.GenerateConfiguration">
            <remarks>
            Default generation function
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.GenerateConfiguration(System.UInt64[])">
            <summary>
            Generate a configuration using a state key
            </summary>
            
            <param name="InitialState">Twofish Cipher key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetSchema(System.Byte[])">
            <summary>
            Set the Schema. Schema must be 4 bytes.
            </summary>
            
            <param name="Schema">Schema Configuration string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid schema is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetVersion(System.Int32)">
            <summary>
            Set the version string. Version must be between 0 and 3, inclusive.
            </summary>
            
            <param name="Version">Version string</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid version is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetTreeLeafSize(System.Byte)">
            <summary>
            Set the tree leaf size
            </summary>
            
            <param name="Size">Leaf size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetTreeFanOutSize(System.Byte)">
            <summary>
            Set the tree fan out size
            </summary>
            
            <param name="Size">Fan out size</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.SetMaxTreeHeight(System.Byte)">
            <summary>
            Set the tree height. Tree height must be zero or greater than 1.
            </summary>
            
            <param name="Height">Tree height</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid tree height is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ConfigValue">
            <summary>
            The post-chain configuration value ToDo: change these and threefish cipher to int type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.ConfigString">
            <summary>
            The pre-chain configuration string
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.InitializationType">
            <summary>
            The initialization type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.Name">
            <summary>
            Get: The Digest name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.StateSize">
            <summary>
            State size in bits
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Skein1024.UbiParameters">
            <summary>
            Ubi Tweak parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256">
            <summary>
            <h3>Keccak256: An implementation of the SHA-3 Keccak digest.</h3>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak256())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 28, 32, and 36 bytes (224, 256, and 288 bits).</description></item>
            <item><description>Block sizes are 144, 128, and 136 bytes (1152, 1024, 1088 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak256.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX">
            <summary>
            <h3>RHX: A Rijndael Cipher extended with an HKDF powered Key Schedule.</h3>
            <para>RHX is a Rijndael<cite>Rijndael</cite> implementation that uses an HKDF generator to expand the user supplied key into a working key integer array.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RHX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">VTDev.Libraries.CEXEngine.Crypto.HKDF Generator</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <para>The key schedule in RHX is the defining difference between this and a standard version of Rijndael<cite>Rijndael</cite>; 
            instead of using a simple inline function to expand the user supplied key into a larger working array, it uses a hash based pseudo-random generator to create the working key.</para>
            
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            <item><description>Valid Rounds are 10 to 38, default is 22.</description></item>
            </list>
            
            <para>HKDF<cite>RFC 5869</cite> is a key derivation function that uses a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
            HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RHX is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in post-quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RHX is capable of processing up to 38 rounds, that is twenty-four rounds more than the fourteen rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds"/> property contains available sizes.  Default is 22 rounds.</param>
            <param name="BlockSize">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalBlockSizes"/> property contains available sizes. Default is 16 bytes.</param>
            <param name="KeyEngine"><para>The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> 
            implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/></para>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid block size or invalid rounds count are used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and initialize state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RHX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey">
            <summary>
            A Rainbow Public Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.#ctor(System.Int32,System.Int16[][],System.Int16[][],System.Int16[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="DocLength">The doc length</param>
            <param name="Quadratic">The quadratic coefficient</param>
            <param name="Singular">The singular coefficient</param>
            <param name="Scalar">The scalar coefficient</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.#ctor(System.IO.Stream)">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Stream is unreadable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.#ctor(System.Byte[])">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="Key">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized RNBWPublicKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.From(System.IO.Stream)">
            <summary>
            Read a Public key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized RNBWPublicKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.ToBytes">
            <summary>
            Converts the Public key to an encoded byte array
            </summary>
            
            <returns>The encoded RNBWPublicKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.ToStream">
            <summary>
            Converts the Public key to an encoded MemoryStream
            </summary>
            
            <returns>The Public Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the RNBWPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded RNBWPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded RNBWPublicKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Public Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.Clone">
            <summary>
            Create a shallow copy of this RNBWPublicKey instance
            </summary>
            
            <returns>RNBWPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.DeepCopy">
            <summary>
            Create a deep copy of this RNBWPublicKey instance
            </summary>
            
            <returns>The RNBWPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.CoeffQuadratic">
            <summary>
            Get: Returns the coeff quadratic
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.CoeffSingular">
            <summary>
            Get: Returns the coeff singular
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.CoeffScalar">
            <summary>
            Get: Returns the coeff scalar
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey.DocLength">
            <summary>
            Get: Returns the doc length
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer">
            <summary>
            This class represents a layer of the Rainbow Oil and Vinegar Map.
            <para>Each Layer consists of oi polynomials with their coefficients, generated at random.</para>
            </summary>
            
            <remarks>
            <para>To sign a document, we solve a LES (linear equation system) for each layer in
            order to find the oil variables of that layer and to be able to use the
            variables to compute the signature. This functionality is implemented in the
            RainbowSignature-class, by the aid of the private key.</para>
            <para>Each layer is a part of the private key.</para>
            <para>More information about the layer can be found in the paper of Jintai Ding,
            Dieter Schmidt: Rainbow, a New Multivariable Polynomial Signature Scheme.
            ACNS 2005: 164-175 <see href="http://dx.doi.org/10.1007/11496137_12"/></para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.#ctor(System.Byte,System.Byte,System.Int16[][][],System.Int16[][][],System.Int16[][],System.Int16[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Vi">The number of vinegar variables of this layer</param>
            <param name="ViNext">The number of vinegar variables of next layer; the same as (num of oils) + (num of vinegars) of this layer</param>
            <param name="CoeffAlpha">The alpha-coefficients in the polynomials of this layer</param>
            <param name="CoeffBeta">The beta-coefficients in the polynomials of this layer</param>
            <param name="CoeffGamma">The gamma-coefficients in the polynomials of this layer</param>
            <param name="CoeffEta">The eta-coefficients in the polynomials of this layer</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            This function generates the coefficients of all polynomials in this layer at random using random generator
            </summary>
            <param name="Vi">The number of vinegar variables of this layer</param>
            <param name="ViNext">The number of vinegar variables of next layer</param>
            <param name="Rand">he random generator which is to be used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.#ctor(System.IO.Stream)">
            <summary>
            Reads a Layer from a Stream
            </summary>
            
            <param name="LayerStream">An input stream containing an encoded Layer</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.#ctor(System.Byte[])">
            <summary>
            Reads a Layer from a byte array
            </summary>
            
            <param name="LayerArray">The encoded Layer</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.PlugInVinegars(System.Int16[])">
            <summary>
            This method plugs in the vinegar variables into the polynomials of this layer and computes
            the coefficients of the Oil-variables as well as the free coefficient in each polynomial.
            </summary>
            
            <param name="X">The vinegar variables of this layer that should be plugged into the polynomials</param>
            
            <returns>Returns the coefficients of Oil variables and the free coeff in the polynomials of this layer</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.From(System.Byte[])">
            <summary>
            Read a Private key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized RNBWPrivateKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.From(System.IO.Stream)">
            <summary>
            Read a Private key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized RNBWPrivateKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.ToBytes">
            <summary>
            Converts the Private key to an encoded byte array
            </summary>
            
            <returns>The encoded RNBWPrivateKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.ToStream">
            <summary>
            Converts the RNBWPrivateKey to an encoded MemoryStream
            </summary>
            
            <returns>The Private Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.Equals(System.Object)">
            <summary>
            This function compares this Layer with another object
            </summary>
            
            <param name="Obj">The other object</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.VI">
            <summary>
            Get: Returns the number of vinegar variables of this layer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.ViNext">
            <summary>
            Get: Returns the number of vinegar variables of the next layer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.OI">
            <summary>
            Get: Returns the number of Oil variables of this layer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.CoeffAlpha">
            <summary>
            Get: Returns the alpha-coefficients of the polynomials in this layer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.CoeffBeta">
            <summary>
            Get: Returns the beta-coefficients of the polynomials in this layer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.CoeffGamma">
            <summary>
            Get: Returns the gamma-coefficients of the polynomials in this layer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer.CoeffEta">
            <summary>
            Get: Returns the eta-coefficients of the polynomials in this layer
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey">
            <summary>
            A Ring-LWE Public Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.#ctor(System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="N">The number of coefficients</param>
            <param name="A">The polynomial 'a'</param>
            <param name="P">The polynomial 'p'</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.#ctor(System.IO.Stream)">
            <summary>
            Read a Public Key from a Stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.#ctor(System.Byte[])">
            <summary>
            Read a Public Key from a byte array
            </summary>
            
            <param name="KeyArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized RLWEPublicKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.From(System.IO.Stream)">
            <summary>
            Read a Public key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized RLWEPublicKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.ToBytes">
            <summary>
            Converts the Public key to an encoded byte array
            </summary>
            
            <returns>The encoded RLWEPublicKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.ToStream">
            <summary>
            Converts the Public key to an encoded MemoryStream
            </summary>
            
            <returns>The Public Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the RLWEPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded RLWEPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded RLWEPublicKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Public Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.Clone">
            <summary>
            Create a shallow copy of this RLWEPublicKey instance
            </summary>
            
            <returns>RLWEPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.DeepCopy">
            <summary>
            Create a deep copy of this RLWEPublicKey instance
            </summary>
            
            <returns>The RLWEPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.A">
            <summary>
            Get: Returns the A array
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.N">
            <summary>
            Get: Returns the number of coefficients
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey.P">
            <summary>
            Get: Returns the P array
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.Arithmetic.NTT256.#ctor(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="SecRand">The secure random number generator instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.Arithmetic.NTT256.Decrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey,System.Byte[])">
            <summary>
            Decrypt a ciphertext
            </summary>
            
            <param name="PrivateKey">The RLWE private key</param>
            <param name="Message">The encrypted message</param>
            
            <returns>The decrypted message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.Arithmetic.NTT256.Encrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey,System.Byte[])">
            <summary>
            Encrypt a message
            </summary>
            
            <param name="PublicKey">The RLWE public key</param>
            <param name="Message">The message array to encrypt</param>
            
            <returns>The encrypted message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.Arithmetic.NTT256.Generate">
            <summary>
            Generate a RLWE key pair
            </summary>
            
            <returns>An initialized RLWE KeyPair</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant">
            <summary>
            A resultant modulo a <c>BigInteger</c>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant">
            <summary>
            Contains a resultant and a polynomial <c>rho</c> such that <c>res = rho*this + t*(x^n-1) for some integer t</c>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant.Rho">
            <summary>
            A polynomial such that <c>res = rho*this + t*(x^n-1) for some integer t</c>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant.Res">
            <summary>
            Resultant of a polynomial with <c>x^n-1</c>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Stores the Rho and resultant values
            </summary>
            
            <param name="Rho">A polynomial such that <c>res = rho*this + t*(x^n-1) for some integer t</c></param>
            <param name="Res">A polynomial with <c>x^n-1</c> </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.Resultant.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial,VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Instantiate the class
            </summary>
            
            <param name="Rho">Rho code</param>
            <param name="Res">Resultant</param>
            <param name="Modulus">Modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant.CombineRho(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ModularResultant)">
            <summary>
            Calculates a <c>rho</c> modulo <c>m1*m2</c> from two resultants whose 
            <c>rho</c>s are modulo <c>m1</c> and <c>m2</c>.
            <para><c>res</c> is set to <c>null</c>.</para>
            </summary>
            
            <param name="ModRes1">M1 resultant</param>
            <param name="ModRes2">M2 resultant</param>
            
            <returns><c>Rho</c> modulo <c>modRes1.modulus * modRes2.modulus</c>, and <c>null</c> for <c>res</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial">
            <summary>
            A polynomial with BigDecimal coefficients.
            <para>Some methods (like <c>Add</c>) change the polynomial, others (like <c>Mult</c>) do not,
            but return the result as a new polynomial.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Coeffs">
            <summary>
            Should be marked as internal
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.#ctor(System.Int32)">
            <summary>
            Constructs a new polynomial with <c>N</c> coefficients initialized to 0
            </summary>
            
            <param name="N">The number of coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigDecimal[])">
            <summary>
            Constructs a new polynomial with a given set of coefficients
            </summary>
            <param name="Coeffs">The coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Clear">
            <summary>
            Clear the Coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Halve">
            <summary>
            Divides all coefficients by 2
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial)">
            <summary>
            Adds another polynomial which can have a different number of coefficients.
            </summary>
            
            <param name="B">The polynomial to add</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Round">
            <summary>
            Rounds all coefficients to the nearest integer
            </summary>
            
            <returns>A new polynomial with <c>BigInteger</c> coefficients</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Clone">
            <summary>
            Makes a copy of the polynomial that is independent of the original
            </summary>
            
            <returns>Cloned copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigDecimalPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by another, taking the indices mod N.
            <para>Does not change this polynomial but returns the result as a new polynomial.
            Both polynomials must have the same number of coefficients.
            This method uses the <a href="http://en.wikipedia.org/wiki/SchnhageStrassen_algorithm"/> 
            SchnhageStrassen algorithm.</para>
            </summary>
            
            <param name="Factor">Multiplication factor</param>
            
            <returns>Multiplied polynomial</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the two polynomials differ in the number of coefficients</exception>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Primitives">
            <summary>
            Core operations for the CCA-secure variants of McEliece
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Primitives.Encrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector)">
            <summary>
            The McEliece encryption primitive
            </summary>
            
            <param name="PublicKey">The public key</param>
            <param name="M">The message vector</param>
            <param name="Z">The error vector</param>
            
            <returns><c>m*G + z</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Primitives.Decrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector)">
            <summary>
            The McEliece decryption primitive
            </summary>
            
            <param name="PrivateKey">The private key</param>
            <param name="C">The ciphertext vector <c>c = m*G + z</c></param>
            
            <returns>The message vector <c>m</c> and the error vector <c>z</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector">
            <summary>
            This abstract class defines a Vector object
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector.GetEncoded">
            <summary>
            Returns this vector as byte array
            </summary>
            
            <returns>The encoded vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector.IsZero">
            <summary>
            Return whether this is the zero vector (i.e., all elements are zero)
            </summary>
            
            <returns>Returns <c>true</c> if this is the zero vector, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Add another vector to this vector
            </summary>
            
            <param name="Addend">The other vector</param>
            
            <returns>Returns <c>this + Addend</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Multiply this vector with a permutation
            </summary>
            
            <param name="P">The permutation</param>
            
            <returns>Returns <c>this*P</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector.Equals(System.Object)">
            <summary>
            Compare this element with another object
            </summary>
            
            <param name="Obj">The object for comprison</param>
            
            <returns>Returns <c>true</c> if the two objects are equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector.GetHashCode">
            <summary>
            Returns the hash code of this element
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector.ToString">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal radix in MSB-first order
            </summary>
            
            <returns>Returns a String representing this Bitstrings value</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector.Length">
            <summary>
            Get: Returns the length of this vector
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement">
            <summary>
            This class implements elements of finite binary fields <c>GF(2^n)</c> using polynomial representation.
            <para>For more information on the arithmetic see for example IEEE Standard 1363 or 
            <a href="http://www.certicom.com/research/online.html"> Certicom online-tutorial</a>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField,System.Random)">
            <summary>
            Create a new random GF2nPolynomialElement using the given field and source of randomness
            </summary>
            
            <param name="Gf">The GF2nField to use</param>
            <param name="Rnd">The source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Creates a new GF2nPolynomialElement using the given field and Bitstring
            </summary>
            
            <param name="Gf">The GF2nPolynomialField to use</param>
            <param name="Gp">The desired value as Bitstring</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField,System.Byte[])">
            <summary>
            Creates a new GF2nPolynomialElement using the given field <c>f</c> and byte[] <c>os</c> as value. 
            <para>The conversion is done according to 1363.</para>
            </summary>
            
            <param name="Gf">The GF2nField to use</param>
            <param name="Os">The octet string to assign to this GF2nPolynomialElement</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField,System.Int32[])">
            <summary>
            Creates a new GF2nPolynomialElement using the given field <c>Gf</c> and int[] <c>Is</c> as value
            </summary>
            
            <param name="Gf">The GF2nField to use</param>
            <param name="Is">The integer string to assign to this GF2nPolynomialElement</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement)">
             .
            
             @param other t
            <summary>
            Creates a new GF2nPolynomialElement by cloning the given GF2nPolynomialElement <c>Ge</c>
            </summary>
            
            <param name="Ge">The GF2nPolynomialElement to clone</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.GetGF2Polynomial">
            <summary>
            Returns the value of this GF2nPolynomialElement in a new Bitstring
            </summary>
            
            <returns>The GF2nPolynomialElement as a Bitstring</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.InvertEEA">
            <summary>
            Calculates the multiplicative inverse of <c>this</c> and returns the result in a new GF2nPolynomialElement
            </summary>
            
            <returns>Returns <c>this</c>^(-1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.InvertMAIA">
            <summary>
            Calculates the multiplicative inverse of <c>this</c> using the modified almost inverse algorithm and returns the result in a new GF2nPolynomialElement
            </summary>
            
            <returns>Returns <c>this</c>^(-1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.InvertSquare">
            <summary>
            Calculates the multiplicative inverse of <c>this</c> and returns the result in a new GF2nPolynomialElement
            </summary>
            
            <returns>Returns <c>this</c>^(-1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.One(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField)">
            <summary>
            Create the one element
            </summary>
            
            <param name="Gf">The finite field</param>
            
            <returns>The one element in the given finite field</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Power(System.Int32)">
            <summary>
            Calculates <c>this</c> to the power of <c>K</c> and returns the result in a new GF2nPolynomialElement
            </summary>
            
            <param name="K">The power</param>
            
            <returns>Returns <c>this</c>^<c>K</c> in a new GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Randomize(System.Random)">
            <summary>
            Assign a random value to this GF2nPolynomialElement using the specified source of randomness
            </summary>
            
            <param name="Rnd">The source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquareBitwise">
            <summary>
            Squares this GF2nPolynomialElement by shifting left its Bitstring and reducing.
            <para>This is supposed to be the slowest method. Use SquarePreCalc or SquareMatrix instead.</para>
            </summary>
            
            <returns></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquareMatrix">
            <summary>
            Squares this GF2nPolynomialElement using GF2nField's squaring matrix.
            <para>This is supposed to be fast when using a polynomial (no tri- or pentanomial) as fieldpolynomial.
            Use SquarePreCalc when using a tri- or pentanomial as fieldpolynomial instead.</para>
            </summary>
            
            <returns>Returns <c>this^2</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquarePreCalc">
            <summary>
            Squares this GF2nPolynomialElement by using precalculated values and reducing.
            <para>This is supposed to de fastest when using a trinomial or pentanomial as field polynomial.
            Use SquareMatrix when using a ordinary polynomial as field polynomial.</para>
            </summary>
            
            <returns></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquareThisBitwise">
            <summary>
            Squares this GF2nPolynomialElement by shifting left its Bitstring and reducing.
            <para>This is supposed to be the slowest method. Use SquarePreCalc or SquareMatrix instead.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquareThisMatrix">
            <summary>
            Squares this GF2nPolynomialElement using GF2nFields squaring matrix. 
            <para>This is supposed to be fast when using a polynomial (no tri- or pentanomial) as fieldpolynomial.
            Use SquarePreCalc when using a tri- or pentanomial as fieldpolynomial instead.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquareThisPreCalc">
            <summary>
            Squares this GF2nPolynomialElement by using precalculated values and reducing.
            <para>This is supposed to de fastest when using a tri- or pentanomial as fieldpolynomial.
            Use SquareMatrix when using a ordinary polynomial as fieldpolynomial.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Zero(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField)">
            <summary>
            Create the zero element
            </summary>
            
            <param name="Gf">The finite field</param>
            
            <returns>The zero element in the given finite field</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the sum of this element and <c>Addend</c>.
            </summary>
            
            <param name="Addend">The addend</param>
            
            <returns>Returns <c>this + other</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.AddToThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute <c>this + addend</c> (overwrite <c>this</c>)
            </summary>
            
            <param name="Addend">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.AssignOne">
            <summary>
            Assigns the value 'one' to this Polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.AssignZero">
            <summary>
            Assigns the value 'zero' to this Polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Clone">
            <summary>
            Creates a new GF2nPolynomialElement by cloning this GF2nPolynomialElement
            </summary>
            
            <returns>A copy of this element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Equals(System.Object)">
            <summary>
            Compare this element with another object
            </summary>
            
            <param name="Obj">The object for comprison</param>
            
            <returns>Returns <c>true</c> if the two objects are equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.GetHashCode">
            <summary>
            Returns the hash code of this element
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Invert">
            <summary>
            Compute the multiplicative inverse of this element
            </summary>
            
            <returns>Returns <c>this^-1</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.IsOne">
            <summary>
            Tests if the GF2nPolynomialElement has 'one' as value
            </summary>
            
            <returns>Returns true if <c>this</c> equals one (this == 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.IsZero">
            <summary>
            Checks whether this element is zero
            </summary>
            
            <returns>Returns <c>true</c> if <c>this</c> is the zero element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Increase">
            <summary>
            Increase the element by one
            </summary>
            
            <returns>Returns <c>this</c> + 'one'</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.IncreaseThis">
            <summary>
            Increase <c>this</c> polynomial + 'one"
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the product of this element and <c>factor</c>
            </summary>
            
            <param name="Factor">he factor</param>
            
            <returns>Returns <c>this * factor</c> </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.MultiplyThisBy(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute <c>this * factor</c> (overwrite <c>this</c>).
            </summary>
            
            <param name="Factor">The factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SolveQuadraticEquation">
            <summary>
            Solves the quadratic equation <c>z^2 + z = this</c> if such a solution exists.
            <para>This method returns one of the two possible solutions.
            The other solution is <c>z + 1</c>. Use z.Increase() to compute this solution.</para>
            </summary>
            
            <returns>Returns a GF2nPolynomialElement representing one z satisfying the equation <c>z^2 + z = this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Square">
            <summary>
            This method is used internally to map the square()-calls within GF2nPolynomialElement to one of the possible squaring methods
            </summary>
            
            <returns>Returns <c>this^2</c> </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquareRoot">
            <summary>
            Compute the square root of this element and return the result in a new GF2nPolynomialElement
            </summary>
            
            <returns>Returns <c>this^1/2</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquareRootThis">
            <summary>
            Compute the square root of this element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.SquareThis">
            <summary>
            This method is used internally to map the square()-calls 
            within GF2nPolynomialElement to one of the possible squaring methods
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.TestBit(System.Int32)">
            <summary>
            Checks whether the indexed bit of the bit representation is set
            </summary>
            
            <param name="Index">The index of the bit to test</param>
            
            <returns>Returns <c>true</c> if the indexed bit is set</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.TestRightmostBit">
            <summary>
            Returns whether the rightmost bit of the bit representation is set.
            <para>This is needed for data conversion according to 1363.</para>
            </summary>
            
            <returns>Returns <c>true</c> if the rightmost bit of this element is set</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.ToByteArray">
            <summary>
            Converts this GF2nPolynomialElement to a byte[] according to 1363
            </summary>
            
            <returns>Returns a byte[] representing the value of this GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.ToFlexiBigInt">
            <summary>
            Converts this GF2nPolynomialElement to an integer according to 1363
            </summary>
            
            <returns>Returns a BigInteger representing the value of this GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.ToString">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal radix in MSB-first order
            </summary>
            
            <returns>Returns a String representing this Bitstrings value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.ToString(System.Int32)">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal or binary radix in MSB-first order
            </summary>
            
            <param name="Radix">The radix to use (2 or 16, otherwise 2 is used)</param>
            
            <returns>Returns a String representing this Bitstrings value.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.Trace">
            <summary>
            Returns the trace of this GF2nPolynomialElement
            </summary>
            
            <returns>The trace of this GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.HalfTrace">
            <summary>
            Returns the half-trace of this GF2nPolynomialElement
            </summary>
            
            <returns>Returns a GF2nPolynomialElement representing the half-trace of this GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.ReducePentanomialBitwise(System.Int32[])">
            <summary>
            Reduce this GF2nPolynomialElement using the pentanomial x^n + x^pc[2] + x^pc[1] + x^pc[0] + 1 as fieldpolynomial.
            The coefficients are reduced bit by bit.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.ReduceThis">
            <summary>
            Reduces this GF2nPolynomialElement modulo the field-polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialElement.ReduceTrinomialBitwise(System.Int32)">
            <summary>
            Reduce this GF2nPolynomialElement using the trinomial x^n + x^tc + 1 as fieldpolynomial. The coefficients are reduced bit by bit.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets">
            <summary>
            A set of pre-defined DTM parameter sets.
            <para>Both hosts in a key exchange must use a parameter set with the same Security Classification.
            This is negotiated during the Connect phase of the DTM Key Exchange protocol. See the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex"/> class for a description of the exchange.</para>
            <para>Set id prefix is defined as: Security Classification <c>X1</c> (maximum security), <c>X2</c> (high security), <c>X3</c> (security and speed), and <c>X4</c> (speed optimized).
            The next 2 characters are the first letter of both asymmetric parameter ids. 
            This is followed by both symmetric cipher enumeration values and their Kdf engine type (Digests enum member or 0 for none).</para>
            </summary>
            
            <remarks>
            <description><h4>The 16 byte Parameter OId configuration:</h4></description>
            <list type="bullet">
            <item><description>The bytes <c>0</c> through <c>3</c> are the Auth-Stage asymmetric parameters OId.</description></item>
            <item><description>The bytes <c>4</c> through <c>7</c> are the Primary-Stage asymmetric parameters OId.</description></item>
            <item><description>Bytes <c>8</c> and <c>9</c> identify the Auth-Stage DtmSession symmetric cipher parameters.</description></item>
            <item><description>Bytes <c>10</c> and <c>11</c> identify the Primary-Stage DtmSession symmetric cipher parameters.</description></item>
            <item><description>The third byte: <c>SubSet</c>, defines the PolyType; simple <c>1</c> or product form <c>2</c>.</description></item>
            <item><description>The last <c>4</c> bytes are used to uniquely identify the parameter set.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.FromId(System.Byte[])">
            <summary>
            Retrieve a DtmParameters by its identity code
            </summary>
            
            <param name="OId">The 16 byte parameter set identity code</param>
            
            <returns>A populated DtmParameters parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.FromName(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames)">
            <summary>
            Retrieve a DtmParameters by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>A populated DtmParameters parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown parameter name is used.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.GetContext(System.Byte[])">
            <summary>
            Returns the security classification prefix
            </summary>
            
            <param name="OId">A DtmParameters OId</param>
            
            <returns>The security classification prefix</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown parameter name is used.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.GetContext(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames)">
            <summary>
            Returns the security classification prefix
            </summary>
            
            <param name="Name">The DtmParameters enumeration name</param>
            
            <returns>The security classification prefix</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown parameter name is used.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.GetID(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames)">
            <summary>
            Retrieve the DtmParameters OId by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>The 16 byte DtmParameters OId field</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DTMX11RNS1R2">
            <summary>
            Class 1, X1.1 Configuration: Optimized for maximum security; (this is the recommended X1 parameter set).
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 40 rounds of Serpent.
            Primary Stage: NTRU <see cref="!:CX1931SK512"/> and 22 rounds of RHX with the Keccak512 Kdf.
            Random bytes appended and prepended to exchange entities and message packets.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DTMX12RNT1S2">
            <summary>
            Class 1, X1.2 Configuration: Optimized for maximum security.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 20 rounds of TwoFish.
            Primary Stage: NTRU <see cref="!:CX1931SK512"/> and 40 rounds of SHX with the Keccak512 Kdf.
            Random bytes appended and prepended to exchange entities and message packets.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DTMX21MNR2T2">
            <summary>
            Class 2, X2.1 Configuration: Optimized for maximum security.
            <para>Authentication Stage: McEliece <see cref="!:MPKCFM12T67S256"/> and 22 rounds of RHX.
            Primary Stage: NTRU <see cref="!:CX1861SK512"/> and 22 rounds of THX with the Skein512 Kdf.
            Random bytes appended and prepended to exchange entities and message packets.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DTMX22MNS2R2">
            <summary>
            Class 2, X2.2 Configuration: Optimized for security and speed; (this is the recommended x2 parameter set).
            <para>Authentication Stage: McEliece <see cref="!:MPKCFM12T67S256"/> and 40 rounds of SHX.
            Primary Stage: NTRU <see cref="!:CX1861SK512"/> and 22 rounds of RHX with the Skein512 Kdf.
            Random bytes appended and prepended to exchange entities.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DTMX31RNT1R2">
            <summary>
            Class 3, X3.1 Configuration: Optimized for security and speed.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 20 rounds of Twofish.
            Primary Stage: NTRU <see cref="!:CX1861SK512"/> and 22 rounds of RHX with the Skein512 Kdf.
            Random bytes appended and prepended to exchange entities.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DTMX32RNS1T2">
            <summary>
            Class 3, X3.2 Configuration: Optimized for security and speed.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 40 rounds of Serpent.
            Primary Stage: NTRU <see cref="!:CX1861SK512"/> and 20 rounds of THX with the Skein512 Kdf.
            Random bytes appended and prepended to exchange entities.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DTMX41RNT1R1">
            <summary>
            Class 4, X4.1 Configuration: Optimized for speed.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 16 rounds of Twofish.
            Primary Stage: NTRU <see cref="!:APR2011743FAST"/> and 14 rounds of Rijndael.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DTMX42RNS1R1">
            <summary>
            Class 4, X4.2 Configuration: Optimized for speed.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 32 rounds of Serpent.
            Primary Stage: NTRU <see cref="!:APR2011743FAST"/> and 22 rounds of Rijndael.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames">
            <summary>
            Set id prefix is defined as: Security Classification <c>X1</c> (maximum security), <c>X2</c> (high security), <c>X3</c> (security and speed), and <c>X4</c> (speed optimized).
            <para>The next 2 characters are the first letter of both asymmetric parameter ids. 
            This is followed by both symmetric cipher enumeration values and their Kdf engine type (Digests enum member or 0 for none).</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames.X11RNS1R2">
            <summary>
            Class 1, X1.1 Configuration: Optimized for maximum security; (this is the recommended X1 parameter set).
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 40 rounds of Serpent.
            Primary Stage: NTRU <see cref="!:CX1931SK512"/> and 22 rounds of RHX with the Keccak512 Kdf.
            Random bytes appended and prepended to exchange entities and message packets.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames.X12RNT1S2">
            <summary>
            Class 1, X1.2 Configuration: Optimized for maximum security.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 20 rounds of TwoFish.
            Primary Stage: NTRU <see cref="!:CX1931SK512"/> and 40 rounds of SHX with the Keccak512 Kdf.
            Random bytes appended and prepended to exchange entities and message packets.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames.X21MNR2T2">
            <summary>
            Class 2, X2.1 Configuration: Optimized for maximum security.
            <para>Authentication Stage: McEliece <see cref="!:MPKCFM12T67S256"/> and 22 rounds of RHX.
            Primary Stage: NTRU <see cref="!:CX1861SK512"/> and 22 rounds of THX with the Skein512 Kdf.
            Random bytes appended and prepended to exchange entities and message packets.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames.X22MNS2R2">
            <summary>
            Class 2, X2.2 Configuration: Optimized for security and speed; (this is the recommended x2 parameter set).
            <para>Authentication Stage: McEliece <see cref="!:MPKCFM12T67S256"/> and 40 rounds of SHX.
            Primary Stage: NTRU <see cref="!:CX1861SK512"/> and 22 rounds of RHX with the Skein512 Kdf.
            Random bytes appended and prepended to exchange entities.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames.X31RNT1R2">
            <summary>
            Class 3, X3.1 Configuration: Optimized for security and speed.
            <para>Authentication Stage: McEliece <see cref="!:MPKCFM12T41S256"/> and 20 rounds of Twofish.
            Primary Stage: NTRU <see cref="!:CX1861SK512"/> and 22 rounds of RHX with the Skein512 Kdf.
            Random bytes appended and prepended to exchange entities.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames.X32RNS1T2">
            <summary>
            Class 3, X3.2 Configuration: Optimized for security and speed.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 40 rounds of Serpent.
            Primary Stage: NTRU <see cref="!:CX1861SK512"/> and 20 rounds of THX with the Skein512 Kdf.
            Random bytes appended and prepended to exchange entities.
            Maximum 200 Millisecond transmission delay post primary key creation.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames.X41RNT1R1">
            <summary>
            Class 4, X4.1 Configuration: Optimized for speed.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 16 rounds of Twofish.
            Primary Stage: NTRU <see cref="!:APR2011743FAST"/> and 14 rounds of Rijndael.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.DtmParamNames.X42RNS1R1">
            <summary>
            Class 4, X4.2 Configuration: Optimized for speed.
            <para>Authentication Stage: Ring-LWE <see cref="!:RLWEN512Q12289"/> and 32 rounds of Serpent.
            Primary Stage: NTRU <see cref="!:APR2011743FAST"/> and 22 rounds of Rijndael.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.SecurityContexts">
            <summary>
            Represents the security classification of a predefined parameter set
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.SecurityContexts.X1">
            <summary>
            Maximum Security: Set was implemented for a maximum security context
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.SecurityContexts.X2">
            <summary>
            High Security: Set was implemented for a high security context
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.SecurityContexts.X3">
            <summary>
            Security and Speed: Set was balanced for security and speed
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParamSets.SecurityContexts.X4">
            <summary>
            Speed Optimized: Set was optimized for speed
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">
            <summary>
            Wraps exceptions thrown within a Networking operational context.
            <para>This exception is used in the PacketBuffer class.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR">
            <summary>
            <h3>Implements a Parallel Segmented Counter Mode: CTR.</h3>
            <para>CTR as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Parallel processing is enabled by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">The KeyParams containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. Parallel capable function if Output array length is at least equal to <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize"/>. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters.  Parallel capable function if Output array length is at least equal to <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize"/>. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CTR.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5">
            <summary>
            <h3>PKCS5 V2: An implementation of an Hash based Key Derivation Function.</h3>
            <para>PKCS5 Version 2, as outlined in RFC 2898<cite>RFC 2898</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new PKCS5(new SHA512(), 10000))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/28/15" version="1.3.1.1">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(System.Int32)">
            <summary>
            Creates a PKCS5 Bytes Generator using the default SHA512 HMAC engine
            </summary>
            
            <param name="Iterations">The number of cycles used to produce output</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if an invalid Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Boolean)">
            <summary>
            Creates a PKCS5 Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="Iterations">The number of cycles used to produce output</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Digest or Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Mac.IMac,System.Int32,System.Boolean)">
            <summary>
            Creates a PKCS5 Bytes Generator based on the given HMAC function
            </summary>
            
            <param name="Hmac">The HMAC digest used</param>
            <param name="Iterations">The number of cycles used to produce output</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Hmac or invalid Iterations count is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.PKCS5.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">
            <summary>
            Wraps exceptions thrown within a MAC operational context.
            <para>This exception is used throughout the Mac domain.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">
            <summary>
            Wraps exceptions thrown within a Asymmetric Signing operational context.
            <para>This exception is used throughout the Asymmetric Sign domain.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher">
            <summary>
            <h3>Packet cipher helper class.</h3>
            <para>Wraps encryption/decryption of a byte array in a continuous operation.</para>
            
            </summary> 
            
            <example>
            <description>Example of encrypting and decrypting a packet stream:</description>
            <code>
            public static void PacketCipherTest()
            {
                const int BLSZ = 1024;
                KeyParams key;
                byte[] data;
                MemoryStream instrm;
                MemoryStream outstrm = new MemoryStream();
            
                using (KeyGenerator kg = new KeyGenerator())
                {
                    // get the key
                    key = kg.GetKeyParams(32, 16);
                    // 2 * 1200 byte packets
                    data = kg.GetBytes(BLSZ * 2);
                }
                // data to encrypt
                instrm = new MemoryStream(data);
            
                // Encrypt a stream //
                // create the outbound cipher
                using (ICipherMode cipher = new CTR(new RDX()))
                {
                    // initialize the cipher for encryption
                    cipher.Initialize(true, key);
                    // set block size
                    ((CTR)cipher).ParallelBlockSize = BLSZ;
            
                    // encrypt the stream
                    using (PacketCipher pc = new PacketCipher(cipher))
                    {
                        byte[] inbuffer = new byte[BLSZ];
                        byte[] outbuffer = new byte[BLSZ];
                        int bytesread = 0;
            
                        while ((bytesread = instrm.Read(inbuffer, 0, BLSZ)) &gt; 0)
                        {
                            // encrypt the buffer
                            pc.Write(inbuffer, 0, outbuffer, 0, BLSZ);
                            // add it to the output stream
                            outstrm.Write(outbuffer, 0, outbuffer.Length);
                        }
                    }
                }
            
                // reset stream position
                outstrm.Seek(0, SeekOrigin.Begin);
                MemoryStream tmpstrm = new MemoryStream();
            
                // Decrypt a stream //
                // create the inbound cipher
                using (ICipherMode cipher = new CTR(new RDX()))
                {
                    // initialize the cipher for decryption
                    cipher.Initialize(false, key);
                    // set block size
                    ((CTR)cipher).ParallelBlockSize = BLSZ;
            
                    // decrypt the stream
                    using (PacketCipher pc = new PacketCipher(cipher))
                    {
                        byte[] inbuffer = new byte[BLSZ];
                        byte[] outbuffer = new byte[BLSZ];
                        int bytesread = 0;
            
                        while ((bytesread = outstrm.Read(inbuffer, 0, BLSZ)) &gt; 0)
                        {
                            // process the encrypted bytes
                            pc.Write(inbuffer, 0, outbuffer, 0, BLSZ);
                            // write to stream
                            tmpstrm.Write(outbuffer, 0, outbuffer.Length);
                        }
                    }
                }
            
                // compare decrypted output with data
                if (!Compare.AreEqual(tmpstrm.ToArray(), data))
                    throw new Exception();
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/05/19" version="1.3.8.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>This instance does not use padding; input and output arrays must be block aligned.</description></item>
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher Mode</see> wrapped <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Block Ciphers</see>, or any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Ciphers</see>.</description></item>
            <item><description>Cipher Engine can be Disposed when this class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.Dispose">Disposed</see>, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Changes to the Cipher or StreamCipher <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.ParallelBlockSize">ParallelBlockSize</see> must be set after initialization.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.#ctor(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the class with a CipherDescription Structure; containing the cipher implementation details, and a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class containing the Key material.
            <para>This constructor creates and configures cryptographic instances based on the cipher description contained in a CipherDescription. 
            Cipher modes, padding, and engines are destroyed automatically through this classes Dispose() method.</para>
            </summary>
            
            <param name="Encryption">Cipher is an encryptor</param>
            <param name="Description">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> containing the cipher description</param>
            <param name="KeyParam">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class containing the encryption Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if an invalid <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">CipherDescription</see> or <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams">KeyParams</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode,VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding,System.Boolean)">
            <summary>
            Initialize the class with a Block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> and optional <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding">Padding</see> instances.
            <para>This constructor requires a fully initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes">CipherMode</see> instance.
            If the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes">PaddingMode</see> parameter is null, X9.23 padding will be used if required.</para>
            </summary>
            
            <param name="Cipher">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Block Cipher</see> wrapped in a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> mode</param>
            <param name="Padding">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.IPadding">Padding</see> instance</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null or uninitialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher,System.Boolean)">
            <summary>
            Initialize the class with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> instance.
            <para>This constructor requires a fully initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">StreamCipher</see> instance.</para>
            </summary>
            
            <param name="Cipher">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Cipher</see> instance</param>
            <param name="DisposeEngine">Dispose of cipher engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null or uninitialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.Write(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Process a length within the Input stream using Offsets
            </summary>
            
            <param name="Input">The Input Stream</param>
            <param name="InOffset">The Input Stream positional offset</param>
            <param name="Output">The Output Stream</param>
            <param name="OutOffset">The Output Stream positional offset</param>
            <param name="Length">The number of bytes to process</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, 
            or the size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.ProcessorCount">
            <summary>
            Get: The system processor count
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.BlockProfiles">
            <summary>
            ParallelBlockProfile enumeration
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.BlockProfiles.ProgressProfile">
            <summary>
            Set parallel block size as a division of 100 segments
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher.BlockProfiles.SpeedProfile">
            <summary>
            Set parallel block size for maximum possible speed
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator">
             <summary>
             An Rainbow Signature Scheme Key-Pair Generator
             </summary>
            
             <example>
             <description>Example of creating a keypair:</description>
             <code>
             RNBWKeyGenerator encParams = RNBWParamSets.RNBWN49L5;
             RNBWKeyGenerator keyGen = new RNBWKeyGenerator(encParams);
             IAsymmetricKeyPair keyPair = keyGen.GenerateKeyPair();
             </code>
             </example>
             
             <revisionHistory>
             <revision date="2015/07/06" version="1.4.0.0">Initial release</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWSign Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWPublicKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWPrivateKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Prngs Enumeration</seealso>
             
             <remarks>
             <description><h4>Guiding Publications:</h4></description>
             <list type="number">
             <item><description>Selecting Parameters for the Rainbow Signature Scheme<cite>Rainbow Parameters</cite>.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The RNBWParameters instance containing the cipher settings</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if a Prng that requires pre-initialization is specified; (wrong constructor)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Use an initialized prng to generate the key; use this constructor with an Rng that requires pre-initialization, i.e. PBPrng
            </summary>
            
            <param name="CipherParams">The RNBWParameters instance containing the cipher settings</param>
            <param name="RngEngine">An initialized Prng instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.GenerateKeyPair">
            <summary>
            Generate an encryption Key pair
            </summary>
            
            <returns>A RNBWKeyPair containing public and private keys</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.Generate">
            <summary>
            This function calls the functions for the random generation of the coefficients
            and the matrices needed for the private key and the method for computing the public key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.GenerateL1">
            <summary>
            This function generates the invertible affine linear map L1 = A1*x + b1
            <para>The translation part b1, is stored in a separate array. 
            The inverse of the matrix-part of L1 A1inv is also computed here.
            This linear map hides the output of the map F. It is on k^(n-v1).</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.GenerateL2">
            <summary>
            This function generates the invertible affine linear map L2 = A2*x + b2.
            <para>The translation part b2, is stored in a separate array.
            The inverse of the matrix-part of L2 A2inv is also computed here.
            This linear map hides the output of the map F. It is on k^(n).</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.GenerateF">
            <summary>
            This function generates the private map F, which consists of u-1 layers.
            <para>Each layer consists of oi polynomials where oi = vi[i+1]-vi[i].
            The methods for the generation of the coefficients of these polynomials are called here.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.ComputePublicKey">
            <summary>
            This function computes the public key from the private key.
            <para>The composition of F with L2 is computed, followed by applying L1 to the composition's result.
            The singular and scalar values constitute to the public key as is, the quadratic terms are compacted in CompactPublicKey.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.CompactPublicKey(System.Int16[][][])">
            <summary>
            The quadratic (or mixed) terms of the public key are compacted from a n x
            n matrix per polynomial to an upper diagonal matrix stored in one integer
            array of n (n + 1) / 2 elements per polynomial.
            <para>The ordering of elements is lexicographic and the result is updating _pubQuadratic, 
            which stores the quadratic elements of the public key.</para>
            </summary>
            <param name="Quadratic">A 3-dimensional array containing a n x n Matrix for each of the n - v1 polynomials</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWKeyGenerator.Name">
            <summary>
            Get: Generator name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters">
            <summary>
            Creates, reads and writes parameter settings for GMSS.
            <para>Predefined parameter sets are available through the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets"/> class.</para>
            </summary>
            
            <example>
            <description>Create a parameter set and write to stream:</description>
            <code>
            MemoryStream ks = new MemoryStream();
            using (GMSSParameters mp = new GMSSParameters(new byte[] { 4, 1, 2, 1 }, new int[] { 19, 26, 32, 38, 49 }))
               mp.WriteTo(ks);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/07" version="1.0.1.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSSign Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Generalized Merkle Signature Scheme Parameter Description:</h4></description>
            <list type="table">
            <item><description>OId - Three bytes that uniquely identify the parameter set.</description></item>
            <item><description>Vi - An array containing the number of vinegar variables per layer.</description></item>
            <item><description>Engine - The Prng engine.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Selecting Parameters for the Generalized Merkle Signature Scheme Signature Scheme<cite>Generalized Merkle Signature Scheme Parameters</cite>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.#ctor(System.Byte[],System.Int32,System.Int32[],System.Int32[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Intitialize this class
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The Generalized Merkle Signature Scheme family must be <c>4</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="NumLayers">The number of authentication tree layers</param>
            <param name="HeightOfTrees">The height of the authentication trees of each layer</param>
            <param name="WinternitzParameter">The Winternitz Parameter 'w' of each layer</param>
            <param name="K">The parameter K needed for the authentication path computation</param>
            <param name="Digest">The hash engine type</param>
            <param name="RandomEngine">The random generator type</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the Vi or Oid settings are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.#ctor(System.IO.Stream)">
            <summary>
            Reconstructs a GMSSParameters from its <c>byte</c> array representation.
            </summary>
            
            <param name="ParamStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Stream is unreadable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.#ctor(System.Int32)">
            <summary>
            Assign default H, W, and K values based on a Power of 2^10, 2^20, or 2^30 signatures scale.
            <para>Ex. Values up to 10 creates 2^10 (1024) signatures, up to 20 2^20 (1048576) signatures, more than 20 = 2^40 (1099511627776) signatures created</para>
            </summary>
            
            <param name="KeySize">Can be 0-10 (2^10), 10-20 (2^20), or 20+ (2^40)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.#ctor(System.Byte[])">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="ParamArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.From(System.Byte[])">
            <summary>
            Read an encoded Parameter set from a byte array
            </summary>
            
            <param name="ParamArray">The byte array containing the parameters</param>
            
            <returns>An initialized GMSSParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.From(System.IO.Stream)">
            <summary>
            Read an encoded Parameters set from a Stream
            </summary>
            
            <param name="ParamStream">The Stream containing the encoded Parameter set</param>
            
            <returns>An initialized GMSSParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.ToBytes">
            <summary>
            Converts the current Parameter set to an encoded byte array
            </summary>
            
            <returns>GMSSParameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.ToStream">
            <summary>
            Converts the current Parameter set to an encoded Stream
            </summary>
            
            <returns>GMSSParameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the GMSSParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the GMSSParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if The output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the GMSSParameters to a Stream
            </summary>
            
            <param name="Output">The Output stream receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.Clone">
            <summary>
            Create a shallow copy of this GMSSParameters instance
            </summary>
            
            <returns>The GMSSParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.DeepCopy">
            <summary>
            Create a deep copy of this GMSSParameters instance
            </summary>
            
            <returns>The GMSSParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.DigestEngine">
            <summary>
            The hash engine type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.HeightOfTrees">
            <summary>
            Get: Returns the array of height (for each layer) of the authentication trees
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.K">
            <summary>
            Get: Returns the parameter K needed for authentication path computation
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.Name">
            <summary>
            Get: Parameters name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.NumLayers">
            <summary>
            Get: Returns the number of levels of the authentication trees
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.OId">
            <summary>
            Get: Four bytes that uniquely identify the parameter set
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.RandomEngine">
            <summary>
            The random generator engine type
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters.WinternitzParameter">
            <summary>
            Get: Returns the array of WinternitzParameter (for each layer) of the authentication trees
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets">
            <summary>
            Contains sets of predefined Ring-LWE parameters.
            <para>Use the FromId(byte[]) or FromName(RLWEParamSets) to return a deep copy of a parameter set.</para>
            </summary>
            
            <remarks>
            <description><h4>Parameter OId:</h4></description>
            <list type="bullet">
            <item><description>A Parameter Set OId (uniquely identifies the parameter set), is always the first four bytes of a serialized parameter set.</description></item>
            <item><description>The OId format is ordered as: <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Unique</c>.</description></item>
            <item><description>A Ring-LWE parameters Family designator (first byte) is always the value <c>3</c>, and corresponds to its entry in the AsymmetricEngines enumeration.</description></item>
            <item><description>The remaining bytes can be a unique designator.</description></item>
            </list>
            
            <description><h4>Ring-LWE Parameter Description:</h4></description>
            <list type="table">
            <item><description>N - The number of coefficients.</description></item>
            <item><description>Q - The Q modulus.</description></item>
            <item><description>Sigma - The Sigma value.</description></item>
            <item><description>OId - Three bytes that uniquely identify the parameter set.</description></item>
            <item><description>MFP - The number of random bytes to prepend to the message.</description></item>
            <item><description>Engine - The Prng engine.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Efficient Software Implementation of Ring-LWE Encryption<cite>Ring-LWE Encryption</cite>.</description></item>
            <item><description>Compact Ring-LWE Cryptoprocessor<cite>Ring-LWE Cryptoprocessor</cite>.</description></item>
            <item><description>A Simple Provably Secure Key Exchange Scheme Based on the Learning with Errors Problem<cite>RLWE Scheme</cite>.</description></item>
            <item><description>The Knuth-Yao Quadrangle-Inequality Speedup is a Consequence of Total-Monotonicity<cite>Knuth-Yao Quadrangle-Inequality Speedup</cite>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.FromId(System.Byte[])">
            <summary>
            Retrieve a parameter set by its identity code
            </summary>
            
            <param name="OId">The 4 byte parameter set identity code</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is used.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.FromName(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.RLWEParamNames)">
            <summary>
            Retrieve a parameter set by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown parameter name is used.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.GetID(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.RLWEParamNames)">
            <summary>
            Retrieve the OId for a parameter set
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>The 4 byte OId field</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown parameter name is used.</exception>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.RLWEN256Q7681">
            <summary>
            Medium security; uses CSPRng as the default Prng.
            <para>Security:120, MaxText:32, N:256 Q:7681, S:11.31, PublicKey Size:1036, PrivateKey Size:520, OId: 3, 2, 2, 1</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.RLWEN512Q12289">
            <summary>
            High security; uses CSPRng as the default Prng.
            <para>Security:240, MaxText:64, N:512 Q:12289, S:12.18, PublicKey Size:2060, PrivateKey Size:1032, OId: 3, 2, 5, 2</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.RLWEParamNames">
            <summary>
            Set id is defined as: N: coefficients, Q: Modulus
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.RLWEParamNames.N256Q7681">
            <summary>
            Low security; uses CSPRng as the default Prng.
            <para>Security:120, MaxText:32, N:256 Q:7681, S:11.31, PublicKey Size:1036, PrivateKey Size:520, OId: 3, 2, 2, 1</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets.RLWEParamNames.N512Q12289">
            <summary>
            High security; uses CSPRng as the default Prng.
            <para>Security:240, MaxText:64, N:512 Q:12289, S:12.18, PublicKey Size:2060, PrivateKey Size:1032, OId: 3, 2, 5, 2</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters">
            <summary>
            Creates, reads and writes parameter settings for RLWEEncrypt.
            <para>Predefined parameter sets are available through the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParamSets"/> class.</para>
            </summary>
            
            <example>
            <description>Create a parameter set and write to stream:</description>
            <code>
            MemoryStream ks = new MemoryStream();
            using (RLWEParameters mp = new RLWEParameters(512, 12289, 12.18, new byte[] { 2, 5, 1 }))
               mp.WriteTo(ks);
            </code>
            </example>
            
            <note>This implementation currently supports only the N256Q7681 and N512Q12289 parameter sets.</note>
            
            <revisionHistory>
            <revision date="2015/06/07" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE RLWEEncrypt Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>RLWE Parameter Description:</h4></description>
            <para>The current implementation uses pre-generated lookup tables for speed, 
            because of this only two base parameter sets are currently supported: N256Q7681 and N512Q12289.
            </para>
            <list type="table">
            <item><description>OId - .</description></item>
            <item><description>N - The number of coefficients.</description></item>
            <item><description>Q - The Q modulus.</description></item>
            <item><description>Sigma - The Sigma value.</description></item>
            <item><description>OId - Three bytes that uniquely identify the parameter set.</description></item>
            <item><description>MFP - The number of random bytes to prepend to the message.</description></item>
            <item><description>Engine - The Prng engine.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Efficient Software Implementation of Ring-LWE Encryption<cite>Ring-LWE Encryption</cite>.</description></item>
            <item><description>Compact Ring-LWE Cryptoprocessor<cite>Ring-LWE Cryptoprocessor</cite>.</description></item>
            <item><description>A Simple Provably Secure Key Exchange Scheme Based on the Learning with Errors Problem<cite>RLWE Scheme</cite>.</description></item>
            <item><description>The Knuth-Yao Quadrangle-Inequality Speedup is a Consequence of Total-Monotonicity<cite>Knuth-Yao Quadrangle-Inequality Speedup</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Ring-LWE-Encryption C version: <see href="https://github.com/ruandc/Ring-LWE-Encryption">ruandc/Ring-LWE-Encryption</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Set the default parameters (N:512, Q:12289, Sigma:12.18)
            </summary>
            
            <param name="OId">Three bytes that uniquely identify the parameter set</param>
            <param name="Engine">The PRNG engine used to power SecureRandom</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if <c>N</c>, or <c>Q</c>, or the Oid are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.#ctor(System.Byte[],System.Int32,System.Int32,System.Double,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="OId">Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The Ring-LWE family must be <c>3</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="N">The number of coefficients</param>
            <param name="Q">The Q modulus</param>
            <param name="Sigma">The Sigma value</param>
            <param name="MFP">The number of random bytes to prepend to the message</param>
            <param name="Engine">The PRNG engine used to power Random Generation</param>
            <param name="PBDigest">The digest engine used to power a Passphrase Based Prng</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if <c>N</c>, or <c>Q</c>, or the Oid are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.#ctor(System.IO.Stream)">
            <summary>
            Builds a parameter set from an encoded input stream
            </summary>
            
            <param name="ParamStream">Stream containing a parameter set</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Stream is unreadable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.#ctor(System.Byte[])">
            <summary>
            Builds a parameter set from an encoded byte array
            </summary>
            
            <param name="ParamArray">Byte array containing a parameter set</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.From(System.Byte[])">
            <summary>
            Read an encoded Parameter set from a byte array
            </summary>
            
            <param name="ParamArray">The byte array containing the parameters</param>
            
            <returns>An initialized RLWEParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.From(System.IO.Stream)">
            <summary>
            Read an encoded Parameters set from a Stream
            </summary>
            
            <param name="ParamStream">The Stream containing the encoded Parameter set</param>
            
            <returns>An initialized RLWEParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.ToBytes">
            <summary>
            Converts the current Parameter set to an encoded byte array
            </summary>
            
            <returns>RLWEParameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.ToStream">
            <summary>
            Converts the current Parameter set to an encoded Stream
            </summary>
            
            <returns>RLWEParameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the RLWEParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the RLWEParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if The output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the RLWEParameters to a Stream
            </summary>
            
            <param name="Output">The Output stream receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.Clone">
            <summary>
            Create a shallow copy of this RLWEParameters instance
            </summary>
            
            <returns>The RLWEParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.DeepCopy">
            <summary>
            Create a deep copy of this RLWEParameters instance
            </summary>
            
            <returns>The RLWEParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.Name">
            <summary>
            Get: Parameters name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.Digest">
            <summary>
            The digest engine powering the PBPrng used to generate a key; used with the RLWEKeyGenerator:GenerateKeyPair(byte[] Passphrase, byte[] Salt) method.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid digest is specified</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.OId">
            <summary>
            Get: Three bytes that uniquely identify the parameter set
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.MFP">
            <summary>
            The number of random bytes to prepend to the message
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.N">
            <summary>
            Returns the number of coefficients
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.Q">
            <summary>
            Return the modulus
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.RandomEngine">
            <summary>
            The random engine used by SecureRandom
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters.Sigma">
            <summary>
            Returns the sigma value
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.TernaryPolynomialType">
            <summary>
            TernaryPolynomialType enumeration
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.TernaryPolynomialType.SIMPLE">
            <summary>
            Use Ternary type key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.TernaryPolynomialType.PRODUCT">
            <summary>
            Use Product form type key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters">
            <summary>
            Creates, reads and writes parameter settings for NtruEncrypt.
            <para>Predefined parameter sets are available and new ones can be created as well.
            These predefined settings are accessable through the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets"/> class</para>
            </summary>
            
            <example>
            <description>Create a parameter set and write to stream:</description>
            <code>
            MemoryStream ks = new MemoryStream();
            using (NtruParameters np = new NtruParameters(new byte[] { 2, 1, 1, 63 }, 1087, 2048, 120, 120, 0, 256, 13, 25, 14, true, true, false, Digests.SHA512))
               np.WriteTo(ks);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.0.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUEncrypt Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>NTRU Parameter Description:</h4></description>
            <list type="table">
            <item><description><c>OId</c> - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The NTRU family must be <c>2</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</description></item>
            <item><description><c>N</c> - Degree Parameter. A positive integer. The associated NTRU lattice has dimension 2N.</description></item>
            <item><description><c>q</c> - Large Modulus. A positive integer. The associated NTRU lattice is a convolution modular lattice of modulus q.</description></item>
            <item><description><c>p</c> - Small Modulus. An integer or a polynomial.</description></item>
            <item><description><c>Df, Dg</c> - Private Key Spaces. Sets of small polynomials from which the private keys are selected.</description></item>
            <item><description><c>Dm</c> - Plaintext Space. Set of polynomials that represent encryptable messages.</description></item>
            <item><description><c>Dr</c> - Blinding Value Space. Set of polynomials from which the temporary blinding value used during encryption is selected.</description></item>
            <item><description><c>Center</c> - Centering Method. A means of performing mod q reduction on decryption.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NTRU: A Ring Based Public Key Crypto System<cite>NTRU Crypto</cite>.</description></item>
            <item><description>Optimizations for NTRU<cite>NTRU Optimizations</cite>.</description></item>
            <item><description>Adaptive Key Recovery Attacks on NTRU-based Somewhat Homomorphic Encryption Schemes<cite>NTRU Adaptive</cite>.</description></item>
            <item><description>Efficient Embedded Security Standards (EESS)<cite>NTRU EESS</cite>.</description></item>
            <item><description>Practical lattice-based cryptography: NTRUEncrypt and NTRUSign<cite>NTRU Practical</cite>.</description></item>
            <item><description>NTRU Cryptosystems Technical Report<cite>NTRU Technical</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent java project NTRU Encrypt by Tim Buktu: <see href="https://github.com/tbuktu/ntru/description">Release 1.2</see>, and
            the NTRUOpenSourceProject/ntru-crypto project provided by Security Innovation, Inc <see href="https://github.com/NTRUOpenSourceProject/ntru-crypto">NTRU Encrypt</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Constructs a parameter set that uses ternary private keys (i.e. <c>PolyType=SIMPLE</c>)
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The NTRU family must be <c>2</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="N">The ring dimension; the number of polynomial coefficients</param>
            <param name="Q">The big Q Modulus</param>
            <param name="Df">Number of ones in the private polynomial <c>f</c></param>
            <param name="Dm0">Minimum acceptable number of -1's, 0's, and 1's in the polynomial <c>m</c> in the last encryption step</param>
            <param name="MaxM1">Maximum absolute value of mTrin.sumCoeffs() or zero to disable this check. Values greater than zero cause the constant coefficient of the message to always be zero.</param>
            <param name="Db">Number of random bits to prepend to the message; should be a multiple of 8</param>
            <param name="CBits">The number of bits in candidate for deriving an index in IGF-2</param>
            <param name="MinIGFHashCalls">Minimum number of hash calls for the IGF to make</param>
            <param name="MinMGFHashCalls">Minimum number of calls to generate the masking polynomial</param>
            <param name="HashSeed">Whether to hash the seed in the MGF first (true), or use the seed directly (false)</param>
            <param name="Sparse">Whether to treat ternary polynomials as sparsely populated; SparseTernaryPolynomial vs DenseTernaryPolynomial</param>
            <param name="FastFp">Whether <c>f=1+p*F</c> for a ternary <c>F</c> (true) or <c>f</c> is ternary (false)</param>
            <param name="Digest">The Message Digest engine to use; default is SHA512</param>
            <param name="Random">The pseudo random generator engine to use; default is CTRPrng</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Oid format is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Constructs a parameter set that uses product-form private keys (i.e. <c>PolyType=PRODUCT</c>).
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The NTRU family must be <c>2</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="N">N number of polynomial coefficients</param>
            <param name="Q">The big Q Modulus</param>
            <param name="Df1">Number of ones in the private polynomial <c>f1</c></param>
            <param name="Df2">Number of ones in the private polynomial <c>f2</c></param>
            <param name="Df3">Number of ones in the private polynomial <c>f3</c></param>
            <param name="Dm0">Minimum acceptable number of -1's, 0's, and 1's in the polynomial <c>m'</c> in the last encryption step</param>
            <param name="MaxM1">Maximum absolute value of mTrin.sumCoeffs() or zero to disable this check. Values greater than zero cause the constant coefficient of the message to always be zero.</param>
            <param name="Db">Number of random bits to prepend to the message; should be a multiple of 8</param>
            <param name="CBits">The number of bits in candidate for deriving an index in IGF-2</param>
            <param name="MinIGFHashCalls">Minimum number of hash calls for the IGF to make</param>
            <param name="MinMGFHashCalls">Minimum number of calls to generate the masking polynomial</param>
            <param name="HashSeed">Whether to hash the seed in the MGF first (true) or use the seed directly (false)</param>
            <param name="Sparse">Whether to treat ternary polynomials as sparsely populated SparseTernaryPolynomial vs DenseTernaryPolynomial</param>
            <param name="FastFp">Whether <c>F=1+p*F</c> for a ternary <c>F</c> (true) or <c>F</c> is ternary (false)</param>
            <param name="Digest">The Message Digest engine to use; default is SHA512</param>
            <param name="Random">The pseudo random generator engine to use; default is CTRPrng</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Oid format is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.#ctor(System.IO.Stream)">
            <summary>
            Builds a parameter set from an encoded input stream
            </summary>
            
            <param name="ParamStream">Stream containing a parameter set</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Stream is unreadable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.#ctor(System.Byte[])">
            <summary>
            Builds a parameter set from an encoded byte array
            </summary>
            
            <param name="ParamArray">Byte array containing a parameter set</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.From(System.Byte[])">
            <summary>
            Read an encoded Parameter set from a byte array
            </summary>
            
            <param name="ParamArray">The byte array containing the parameters</param>
            
            <returns>An initialized NTRUParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.From(System.IO.Stream)">
            <summary>
            Read an encoded Parameters set from a Stream
            </summary>
            
            <param name="ParamStream">The Stream containing the encoded Parameter set</param>
            
            <returns>An initialized NTRUParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.GetOutputLength">
            <summary>
            Returns the length of a message after encryption with this parameter set
            <para>The length does not depend on the input size.</para>
            </summary>
            
            <returns>The length in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.ToBytes">
            <summary>
            Converts the current Parameter set to an encoded byte array
            </summary>
            
            <returns>NtruParameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.ToStream">
            <summary>
            Converts the current Parameter set to an encoded Stream
            </summary>
            
            <returns>NtruParameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the NTRUParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the NTRUParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if The output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the NTRUParameters to a Stream
            </summary>
            
            <param name="Output">The Output stream receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Clone">
            <summary>
            Create a shallow copy of this NTRUParameters instance
            </summary>
            
            <returns>The NTRUParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DeepCopy">
            <summary>
            Create a deep copy of this NTRUParameters instance
            </summary>
            
            <returns>The NTRUParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Name">
            <summary>
            Get: Parameters name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.N">
            <summary>
            Get: The ring dimension; the number of polynomial coefficients
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Q">
            <summary>
            Get: The big q Modulus
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.CBits">
            <summary>
            Get: The number of bits in candidate for deriving an index in IGF-2
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Db">
            <summary>
            Get: Number of random bits to prepend to the message; should be a multiple of 8
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DF">
            <summary>
            Get: Number of ones in the private polynomial <c>f</c>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DF1">
            <summary>
            Get/Set: Number of ones in the private polynomial <c>f1</c>; Product form of Df
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DF2">
            <summary>
            Get/Set: Number of ones in the private polynomial <c>f2</c>; Product form of Df
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DF3">
            <summary>
            Get/Set: Number of ones in the private polynomial <c>f3</c>; Product form of Df
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Dm0">
            <summary>
            Get: Minimum acceptable number of -1's, 0's, and 1's in the polynomial <c>m</c> in the last encryption step
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DR">
            <summary>
            Get: Blinding Value Space
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DR1">
            <summary>
            Get/Set: Blinding Value Space <c>dr1</c>; Product form of Dr
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DR2">
            <summary>
            Get/Set: Blinding Value Space <c>dr2</c>; Product form of Dr
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.DR3">
            <summary>
            Get/Set: Blinding Value Space <c>dr3</c>; Product form of Dr
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.FastFp">
            <summary>
            Get/Set: Whether <c>F=1+p*F</c> for a ternary <c>F</c> (true) or <c>F</c> is ternary (false)
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.HashSeed">
            <summary>
            Get: Whether to hash the seed in the MGF first (true), or use the seed directly (false)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Length">
            <summary>
            Get: Used in message length calculation
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.MaxM1">
            <summary>
            Get: Maximum absolute value of mTrin.sumCoeffs() or zero to disable this check. 
            <para>Values greater than zero cause the constant coefficient of the message to always be zero.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.MessageMax">
            <summary>
            Get: The maximum  length of a plaintext message in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Digest">
            <summary>
            Get/Set: The Message Digest engine to use; default is SHA512
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.MinIGFHashCalls">
            <summary>
            Get: Minimum number of hash calls for the IGF to make
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.MinMGFHashCalls">
            <summary>
            Get: Minimum number of calls to generate the masking polynomial
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.OId">
            <summary>
            Get: Three bytes that uniquely identify the parameter set
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.PolyType">
            <summary>
            Get/Set: The polynomial type
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.RandomEngine">
            <summary>
            Get/Set: The pseudo random generator engine to use; default is CSPRng
            <para>Set can be readonly in distribution</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters.Sparse">
            <summary>
            Whether to treat ternary polynomials as sparsely populated; SparseTernaryPolynomial vs DenseTernaryPolynomialinternal
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField">
            <summary>
            This class implements the abstract class <c>GF2nField</c> for polynomial representation.
            <para>It computes the field polynomial and the squaring matrix.
            GF2nField is used by GF2nPolynomialElement which implements the elements of this field.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.#ctor(System.Int32)">
            <summary>
            Constructs an instance of the finite field with 2^Degree elements and characteristic 2
            </summary>
            
            <param name="Degree">The extention degree of this field</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.#ctor(System.Int32,System.Boolean)">
            <summary>
            Constructs an instance of the finite field with 2^Degree elements and characteristic 2
            </summary>
            
            <param name="Degree">he degree of this field</param>
            <param name="File">True if you want to read the field polynomial from the file,
            false if you want to use a random fielpolynomial (this can take very long for huge degrees)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Creates a new GF2nField of degree <c>i</c> and uses the given <c>G</c> as field polynomial. 
            <para>The <c>G</c> is checked whether it is irreducible. This can take some time if <c>Degree</c> is huge!</para>
            </summary>
            
            <param name="Degree">The degree of the GF2nField</param>
            <param name="G">The field polynomial to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.SquaringVector(System.Int32)">
            <summary>
            Returns row vector <c>Index</c> of the squaring matrix
            </summary>
            
            <param name="Index">The index of the row vector to return</param>
            
            <returns>Returns a copy of SquaringMatrix[i]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.ComputeCOBMatrix(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField)">
            <summary>
            Computes the change-of-basis matrix for basis conversion according to 1363.
            The result is stored in the lists fields and matrices.
            </summary>
            
            <param name="B1">The GF2nField to convert to</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.ComputeFieldPolynomial">
            <summary>
            Computes the field polynomial. This can take a long time for big degrees.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.ComputeFieldPolynomial2">
            <summary>
            Computes the field polynomial. This can take a long time for big degrees.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.RandomRoot(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Compute a random root of the given GF2Polynomial
            </summary>
            
            <param name="G">The polynomial</param>
            
            <returns>Returns a random root of <c>G</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.ComputeSquaringMatrix">
            <summary>
            Computes a new squaring matrix used for fast squaring
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.TestPentanomials">
            <summary>
            Tests all pentanomials of degree (n+1) until a irreducible is found and stores the result in <c>field polynomial</c>.
            Returns false if no irreducible pentanomial exists in GF(2^n).
            This can take very long for huge degrees.
            </summary>
            
            <returns>Returns true if an irreducible pentanomial is found</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.TestRandom">
            <summary>
            Tests random polynomials of degree (n+1) until an irreducible is found and stores the result in <c>field polynomial</c>.
            This can take very long for huge degrees.
            </summary>
            
            <returns>Returns true</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.TestTrinomials">
            <summary>
            Tests all trinomials of degree (n+1) until a irreducible is found and stores the result in <c>field polynomial</c>.
            Returns false if no irreducible trinomial exists in GF(2^n). This can take very long for huge degrees.
            </summary>
            
            <returns>Returns true if an irreducible trinomial is found</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.IsPentanomial">
            <summary>
            Get: Returns true if the field polynomial is a pentanomial; the coefficients can be retrieved using Pc property
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.IsTrinomial">
            <summary>
            Get: Returns true if the field polynomial is a trinomial; the coefficient can be retrieved using Tc property
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.Pc">
            <summary>
            Get: Returns the degree of the middle coefficients of the used field pentanomial (x^n + x^(Pc[2]) + x^(Pc[1]) + x^(Pc[0]) + 1)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.SquaringMatrix">
            <summary>
            Get: Matrix used for fast squaring of GF2Polynomial
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomialField.Tc">
            <summary>
            Get: Returns the degree of the middle coefficient of the used field trinomial (x^n + x^(getTc()) + 1)
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.X923">
            <summary>
            <h3>The X.923 Padding Scheme.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.X923.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.X923.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.X923.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.X923.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">
            <summary>
            The CipherDescription structure.
            <para>Used in conjunction with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher"/>, <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.CompressionCipher"/>, 
            <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.PacketCipher"/>, and <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher"/> classes.
            Contains all the necessary settings required to recreate a cipher instance.</para>
            </summary>
            
            <example>
            <description>Example of populating a <c>CipherDescription</c> structure:</description>
            <code>
               CipherDescription cdsc = new CipherDescription(
                   Engines.RHX,             // cipher engine
                   192,                     // key size in bytes
                   IVSizes.V128,            // cipher iv size enum
                   CipherModes.CTR,         // cipher mode enum
                   PaddingModes.X923,       // cipher padding mode enum
                   BlockSizes.B128,         // block size enum
                   RoundCounts.R18,         // diffusion rounds enum
                   Digests.Skein512,        // cipher kdf engine
                   64,                      // mac size
                   Digests.Keccak);         // mac digest
            </code>
            </example>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">VTDev.Libraries.CEXEngine.Crypto.Processing StreamCipher class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher">VTDev.Libraries.CEXEngine.Crypto.Processing VolumeCipher class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures PackageKey Structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">VTDev.Libraries.CEXEngine.Crypto.Enumeration KeyPolicies Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates">VTDev.Libraries.CEXEngine.Crypto KeyStates Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator">VTDev.Libraries.CEXEngine.Crypto.KeyGenerator class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams">VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams class</seealso>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/09/23" version="1.3.2.0">Rebuilt to accomodate PackageKey structures</revision>
            <revision date="2015/09/23" version="1.3.6.0">Shortened field sizes on serialized header</revision>
            </revisionHistory>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.EngineType">
            <summary>
            The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Engine</see> type
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.KeySize">
            <summary>
            The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeySizes">Key Size</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.IvSize">
            <summary>
            Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes">Initialization Vector</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.CipherType">
            <summary>
            The type of <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes">Cipher Mode</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.PaddingType">
            <summary>
            The type of cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes">Padding Mode</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.BlockSize">
            <summary>
            The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes">Block Size</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.RoundCount">
            <summary>
            The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts">Rounds</see>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.KdfEngine">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.MacSize">
            <summary>
            The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.MacEngine">
            <summary>
            The HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to authenticate a message file encrypted with this key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            CipherDescription constructor
            </summary>
            
            <param name="EngineType">The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Engine</see> type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes">Initialization Vector</see></param>
            <param name="CipherType">The type of <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes">Cipher Mode</see></param>
            <param name="PaddingType">The type of cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes">Padding Mode</see></param>
            <param name="BlockSize">The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes">Block Size</see></param>
            <param name="RoundCount">The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts">Rounds</see></param>
            <param name="KdfEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers</param>
            <param name="MacSize">The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key</param>
            <param name="MacEngine">The HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to authenticate a message file encrypted with this key</param>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid KeyId, MessageKey, or ExtensionKey is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.#ctor(System.IO.Stream)">
            <summary>
            Initialize the CipherDescription structure using a Stream
            </summary>
            
            <param name="DescriptionStream">The Stream containing the CipherDescription</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.#ctor(System.Byte[])">
            <summary>
            Initialize the CipherDescription structure using a byte array
            </summary>
            
            <param name="DescriptionArray">The byte array containing the CipherDescription</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.IsValid(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription)">
            <summary>
            Get this is a valid header file
            </summary>
            
            <param name="Description">The stream containing a key header</param>
            
            <returns>Valid</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.ToBytes">
            <summary>
            Convert the CipherDescription structure as a byte array
            </summary>
            
            <returns>The byte array containing the CipherDescription</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.ToStream">
            <summary>
            Convert the CipherDescription structure to a MemoryStream
            </summary>
            
            <returns>The MemoryStream containing the CipherDescription</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.op_Equality(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription)">
            <summary>
            Compare this object instance is equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription.op_Inequality(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription)">
            <summary>
            Compare this object instance is not equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Not equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg">
            <summary>
            <h3>PBKDF2: An implementation of an Hash based Key Derivation Function.</h3>
            <para>PBKDF2 as outlined in ISO 18033-2 <cite>ISO 18033</cite>.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new PBKDF2(new SHA512()))
            {
                // initialize
                rnd.Initialize(Salt, Ikm, [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/28/15" version="1.3.1.1">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Mac.HMAC">VTDev.Libraries.CEXEngine.Crypto.Mac HMAC</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Macs">Mac</see>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Salt size should be multiple of Digest block size.</description></item>
            <item><description>Ikm size should be Digest hash return size.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="table">
            <item><description>ISO-18033-2: <see href="http://www.shoup.net/iso/std6.pdf">Specification</see>.</description></item>
            <item><description>RFC 2898: <see href="http://tools.ietf.org/html/rfc2898">Specification</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.#ctor">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given HMAC function using the default SHA512 engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Creates a PBKDF2 Bytes Generator based on the given hash function
            </summary>
            
            <param name="Digest">The digest used</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Digest is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt or 'password' value</param>
            <param name="Ikm">Key material</param>
            <param name="Nonce">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Salt or Ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Update(System.Byte[])">
            <summary>
            Update the Seed material
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.KeySize">
            <summary>
            <para>Minimum initialization key size in bytes; 
            combined sizes of Salt, Ikm, and Nonce must be at least this size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.KDF2Drbg.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg">
            <summary>
            <h3>An implementation of a Cryptographically Secure seed generator using the RNGCryptoServiceProvider class.</h3>
            <para>Implements a random byte generator using the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class</para>
            </summary>
            
            <example>
            <code>
            byte seed;
            using (ISeed rnd = new CSPRng())
                seed = rnd.GetSeed(48);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4>:</description>
            <list type="number">
            <item><description>RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class documentation.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.#ctor">
            <summary>
            Initialize the class
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if RNGCryptoServiceProvider initialization failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.GetSeed(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Seed.CSPRsg.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.VolumeKeyStates">
            <summary>
            The state of a volume key pair
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.VolumeKeyStates.Unassigned">
            <summary>
            The key pair is unassigned
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.VolumeKeyStates.Encrypted">
            <summary>
            The key pair was used for encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.VolumeKeyStates.Decrypted">
            <summary>
            The key pair was used for decryption
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes">
            <summary>
            <para>IV Sizes in bits. Can be cast as IV byte size integers, 
            i.e. (int sz = IVSizes.V128) is equal to 16.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes.V64">
            <summary>
            64 bit IV
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes.V128">
            <summary>
            128 bit IV
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes.V256">
            <summary>
            256 bit IV
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets">
            <summary>
            Contains sets of predefined Rainbow parameters.
            <para>Use the FromId(byte[]) or FromName(RNBWParamSets) to return a deep copy of a parameter set.</para>
            </summary>
            
            <revisionHistory>
            <revision date="2015/06/07" version="1.0.1.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWSign Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Parameter Sets:</h4></description>
            <list type="table">
            <listheader>
                <term>Strength</term>
                <term>N</term>
                <term>V1, V2, V3, V4</term>
            </listheader>
            
            <item><description>Low</description></item>
            <item><description>33</description></item>
            <item><description>6, 12, 17, 22</description></item>
            
            <item><description>Medium</description></item>
            <item><description>49</description></item>
            <item><description>19, 26, 32, 38</description></item>
            
            <item><description>Medium</description></item>
            <item><description>54</description></item>
            <item><description>21, 27, 34, 44</description></item>
            
            <item><description>High</description></item>
            <item><description>58</description></item>
            <item><description>24, 30, 37, 44</description></item>
            
            <item><description>High</description></item>
            <item><description>60</description></item>
            <item><description>24, 30, 37, 45</description></item>
            
            <item><description>High</description></item>
            <item><description>63</description></item>
            <item><description>26, 33, 40, 51</description></item>
            
            <item><description>High</description></item>
            <item><description>66</description></item>
            <item><description>27, 35, 43, 54</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Selecting Parameters for the Rainbow Signature Scheme<cite>Rainbow Parameters</cite>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.FromId(System.Byte[])">
            <summary>
            Retrieve a parameter set by its identity code
            </summary>
            
            <param name="OId">The 4 byte parameter set identity code</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.FromName(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames)">
            <summary>
            Retrieve a parameter set by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.GetID(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames)">
            <summary>
            Retrieve the parameter OId by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>The 4 byte OId field</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWN33L5">
            <summary>
            Medium security.
            <para>N: 33, VI: 6, 12, 17, 22, PublicKey Size: 32162, PrivateKey Size: 27896</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWN49L5">
            <summary>
            Medium security. 
            <para>N: 49, VI: 19, 26, 32, 38, PublicKey Size: 76532, PrivateKey Size: 81858</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWN54L5">
            <summary>
            Medium security. 
            <para>N: 54, VI: 21, 27, 34, 44, PublicKey Size: 101672, PrivateKey Size: 108406</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWN58L5">
            <summary>
            High security.
            <para>N: 58, VI: 24, 30, 37, 44, PublicKey Size: 120392, PrivateKey Size: 131138</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWN60L5">
            <summary>
            High security.
            <para>N: 60, VI: 24, 30, 37, 45, PublicKey Size: 136184, PrivateKey Size: 145574</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWN63L5">
            <summary>
            High security.
            <para>N: 63, VI: 26, 33, 40, 51, PublicKey Size: 153952, PrivateKey Size: 167390</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWN66L5">
            <summary>
            High security.
            <para>N: 66, VI: 27, 35, 43, 54, PublicKey Size: 177716, PrivateKey Size: 192182</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames">
            <summary>
            Set id is defined as: N: coefficients, L: vinegar count
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames.N33L5">
            <summary>
            Medium security.
            <para>N: 33, VI: 6, 12, 17, 22, PublicKey Size: 32162, PrivateKey Size: 27896</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames.N49L5">
            <summary>
            Medium security. 
            <para>N: 49, VI: 19, 26, 32, 38, PublicKey Size: 76532, PrivateKey Size: 81858</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames.N54L5">
            <summary>
            Medium security. 
            <para>N: 54, VI: 21, 27, 34, 44, PublicKey Size: 101672, PrivateKey Size: 108406</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames.N58L5">
            <summary>
            High security.
            <para>N: 58, VI: 24, 30, 37, 44, PublicKey Size: 120392, PrivateKey Size: 131138</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames.N60L5">
            <summary>
            High security.
            <para>N: 60, VI: 24, 30, 37, 45, PublicKey Size: 136184, PrivateKey Size: 145574</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames.N63L5">
            <summary>
            High security.
            <para>N: 63, VI: 26, 33, 40, 51, PublicKey Size: 153952, PrivateKey Size: 167390</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParamSets.RNBWParamNames.N66L5">
            <summary>
            High security.
            <para>N: 66, VI: 27, 35, 43, 54, PublicKey Size: 177716, PrivateKey Size: 192182</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey">
            <summary>
            A Generalized Merkle Signature Scheme Public Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.#ctor(System.Byte[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="KeyArray">The byte array containing the public key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.#ctor(System.IO.Stream)">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Stream is unreadable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized GMSSPublicKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.From(System.IO.Stream)">
            <summary>
            Read a Public key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized GMSSPublicKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.ToBytes">
            <summary>
            Converts the Public key to an encoded byte array
            </summary>
            
            <returns>The encoded GMSSPublicKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.ToStream">
            <summary>
            Converts the Public key to an encoded MemoryStream
            </summary>
            
            <returns>The Public Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the GMSSPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded GMSSPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded GMSSPublicKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Public Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.Clone">
            <summary>
            Create a shallow copy of this GMSSPublicKey instance
            </summary>
            
            <returns>GMSSPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.DeepCopy">
            <summary>
            Create a deep copy of this GMSSPublicKey instance
            </summary>
            
            <returns>The GMSSPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey.PublicKey">
            <summary>
            Get: Returns the doc length
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair">
            <summary>
            An Ring-LWE Key-Pair container
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="PublicKey">The public key</param>
            <param name="PrivateKey">The corresponding private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Key">The public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.#ctor(System.IO.MemoryStream)">
            <summary>
            Reads a key pair from an input stream.
            <para>Note: both keys must be present in the stream; ordered Public, Private.</para>
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key pair</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.#ctor(System.Byte[])">
            <summary>
            Reads a key pair  from a byte array.
            <para>Note: both keys must be present in the stream; ordered Public, Private.</para>
            </summary>
            
            <param name="KeyArray">An byte array containing an encoded key pair</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.Clone">
            <summary>
            Create a copy of this key pair instance
            </summary>
            
            <returns>The IAsymmetricKeyPair copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.Name">
            <summary>
            Get: KeyPair name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.PublicKey">
            <summary>
            Get: Returns the public key parameters
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEKeyPair.PrivateKey">
            <summary>
            Get: Returns the private key parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial5">
            <summary>
            A polynomial class that combines five coefficients into one <c>long</c> value for
            faster multiplication by a ternary polynomial.
            <para>Coefficients can be between 0 and 2047 and are stored in bits 0..11, 12..23, ..., 48..59 of a <c>long</c> number.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial5.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>LongPolynomial5</c> from a <c>IntegerPolynomial</c>. The two polynomials are independent of each other.
            </summary>
            
            <param name="P">The original polynomial. Coefficients must be between 0 and 2047.</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial5.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ITernaryPolynomial)">
            <summary>
            Multiplies the polynomial with a <c>TernaryPolynomial</c>, taking the indices mod N and the values mod 2048.
            </summary>
            
            <param name="Factor">The polynomial factor</param>
            
            <returns>The multiplication product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial5.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher">
            <summary>
            This class implements the Kobara/Imai conversion of the McEliecePKCS.
            <para>This is  a conversion of the McEliecePKCS which is CCA2-secure.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.OID">
            <summary>
            The algorithm identifier
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.MPKCINFO">
            <summary>
            Configurable nonce, can create a unique distribution
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters,System.Byte[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Parameters">The cipher parameters</param>
            <param name="Info">The predefined nonce value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.GetKeySize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Return the key size of the working key
            </summary>
            
            <returns>The size of the key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey"/> for encryption, or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey"/> for decryption</para>
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the McEliece public or private key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.KobaraImaiCipher.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can decrypt
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2m">
            <summary>
            This class represents polynomial rings <c>GF(2^m)[X]/p(X)</c> for <c>m&lt;32</c>.
            <para>If <c>p(X)</c> is irreducible, the polynomial ring is in fact an extension field of <c>GF(2^m)</c>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2m.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Field">The finite field</param>
            <param name="Poly">The reduction polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2m.ComputeSquaringMatrix">
            <summary>
            Compute the squaring matrix for this polynomial ring, using the base field and the reduction polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2m.ComputeSquareRootMatrix">
            <summary>
            Compute the matrix for computing square roots in this polynomial ring by inverting the squaring matrix
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2m.SwapColumns(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialGF2mSmallM[],System.Int32,System.Int32)">
            <summary>
            Swap two columns
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2m.SquaringMatrix">
            <summary>
            Get: Return the squaring matrix for this polynomial ring
            </summary>
            <returns></returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.PolynomialRingGF2m.SquareRootMatrix">
            <summary>
            Get: Return the matrix for computing square roots for this polynomial ring
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters">
            <summary>
            The DtmParameters class.
            <para>The DtmParameters class is used to define the working parameters used by the DTM Key Exchange using a DtmKex instance.</para>
            <para>The bytes <c>0</c> through <c>3</c> are the Auth-Stage asymmetric parameters OId.
            The next 4 bytes are the Primary-Stage asymmetric parameters OId.
            Bytes <c>8</c> and <c>9</c> identify the Auth-Stage DtmSession symmetric cipher parameters.
            Bytes <c>10</c> and <c>11</c> identify the Primary-Stage DtmSession symmetric cipher parameters.
            The last <c>4</c> bytes are used to uniquely identify the parameter set.</para>
            </summary>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmClient structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmIdentity structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmPacket structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmSession structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmKex class</seealso>
            
            <revisionHistory>
            <revision date="2015/05/23" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.OId">
            <summary>
            The DtmParameters Identifier field; should be 16 bytes describing the parameter set (see class notes)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.AuthPkeId">
            <summary>
            The <c>Auth-Stage</c> Asymmetric parameters OId; can be the Asymmetric cipher parameters OId, or a serialized Asymmetric Parameters class
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.PrimaryPkeId">
            <summary>
            The <c>Primary-Stage</c> Asymmetric parameters OId; can be the Asymmetric cipher parameters OId, or a serialized Asymmetric Parameters class
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.AuthSession">
            <summary>
            The <c>Auth-Stage</c> Symmetric sessions cipher parameters; contains a complete description of the Symmetric cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.PrimarySession">
            <summary>
            The <c>Primary-Stage</c> Symmetric sessions cipher parameters; contains a complete description of the Symmetric cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.RandomEngine">
            <summary>
            The Prng used to pad messages
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxAsmKeyAppend">
            <summary>
            (Optional) The maximum number of pseudo-random bytes to append to the <c>Primary-Stage</c> Asymmetric Public key before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxAsmKeyPrePend">
            <summary>
            (Optional) The maximum number of pseudo-random bytes to prepend to the <c>Primary-Stage</c> Asymmetric Public key before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxAsmParamsAppend">
            <summary>
            (Optional) The maximum number of pseudo-random bytes to append to the <c>Primary-Stage</c> Client Identity before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxAsmParamsPrePend">
            <summary>
            (Optional) The maximum number of pseudo-random bytes to prepend to the <c>Primary-Stage</c> Asymmetric Client Identity before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxSymKeyAppend">
            <summary>
            (Optional) The maximum number of pseudo-random bytes to append to the <c>Primary-Stage</c> Symmetric key before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxSymKeyPrePend">
            <summary>
            (Optional) The maximum number of pseudo-random bytes to prepend to the <c>Primary-Stage</c> Symmetric key before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxMessageAppend">
            <summary>
            (Optional) The maximum number of pseudo-random bytes to append to a <c>Post-Exchange</c> message before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxMessagePrePend">
            <summary>
            (Optional) The maximum number of pseudo-random bytes to prepend to a <c>Post-Exchange</c> message before encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxAsmKeyDelayMS">
            <summary>
            (Optional) The maximum delay time before sending the <c>Primary-Stage</c> Asymmetric key; the minimum time is 1 half max, a value of <c>0</c> has no delay 
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxSymKeyDelayMS">
            <summary>
            (Optional) The maximum delay time before sending the <c>Primary-Stage</c> Symmetric key; the minimum time is 1 half max, a value of <c>0</c> has no delay
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.MaxMessageDelayMS">
            <summary>
            (Optional) The maximum delay time before sending <c>Post-Exchange</c> message traffic; the minimum time is <c>0</c>, a value of <c>0</c> has no delay
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.#ctor(System.Byte[],System.Byte[],System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The DtmParameters primary constructor
            </summary>
            
            <param name="OId">The DtmParameters Identifier field; must be 16 bytes in length</param>
            <param name="AuthPkeId">The <c>Auth-Stage</c> Asymmetric parameters OId; can be the Asymmetric cipher parameters OId, or a serialized Asymmetric Parameters class</param>
            <param name="PrimaryPkeId">The <c>Primary-Stage</c> Asymmetric parameters OId; can be the Asymmetric cipher parameters OId, or a serialized Asymmetric Parameters class</param>
            <param name="AuthSession">The <c>Auth-Stage</c> Symmetric sessions cipher parameters; contains a complete description of the Symmetric cipher</param>
            <param name="PrimarySession">The <c>Primary-Stage</c> Symmetric sessions cipher parameters; contains a complete description of the Symmetric cipher</param>
            <param name="RandomEngine">(Optional) The Prng used to pad messages, defaults to <see cref="!:CTRPrng"/></param>
            <param name="MaxAsmKeyAppend">(Optional) The maximum number of pseudo-random bytes to append to the <c>Primary-Stage</c> Asymmetric Public key before encryption</param>
            <param name="MaxAsmKeyPrePend">(Optional) The maximum number of pseudo-random bytes to prepend to the <c>Primary-Stage</c> Asymmetric Public key before encryption</param>
            <param name="MaxAsmParamsAppend">(Optional) The maximum number of pseudo-random bytes to append to the <c>Primary-Stage</c> Client Identity before encryption</param>
            <param name="MaxAsmParamsPrePend">(Optional) The maximum number of pseudo-random bytes to prepend to the <c>Primary-Stage</c> Asymmetric Client Identity before encryption</param>
            <param name="MaxSymKeyAppend">(Optional) The maximum number of pseudo-random bytes to append to the <c>Primary-Stage</c> Symmetric key before encryption</param>
            <param name="MaxSymKeyPrePend">(Optional) The maximum number of pseudo-random bytes to prepend to the <c>Primary-Stage</c> Symmetric key before encryption</param>
            <param name="MaxMessageAppend">(Optional) The maximum number of pseudo-random bytes to append to a <c>Post-Exchange</c> message before encryption</param>
            <param name="MaxMessagePrePend">(Optional) The maximum number of pseudo-random bytes to prepend to a <c>Post-Exchange</c> message before encryption</param>
            <param name="MaxAsmKeyDelayMS">(Optional) The maximum delay time before sending the <c>Primary-Stage</c> Asymmetric key; the minimum time is 1 half max, a value of <c>0</c> has no delay</param>
            <param name="MaxSymKeyDelayMS">(Optional) The maximum delay time before sending the <c>Primary-Stage</c> Symmetric key; the minimum time is 1 half max, a value of <c>0</c> has no delay</param>
            <param name="MaxMessageDelayMS">(Optional) The maximum delay time before sending message traffic; the minimum time is <c>0</c>, a value of <c>0</c> has no delay</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.#ctor(System.Byte[])">
            <summary>
            Constructs a DtmParameters from a byte array
            </summary>
            
            <param name="ParametersArray">The byte array containing the DtmParameters structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.#ctor(System.IO.Stream)">
            <summary>
            Constructs a DtmIdentity from a stream
            </summary>
            
            <param name="ParametersStream">Stream containing a serialized DtmParameters</param>
            
            <returns>A populated DtmParameters</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.DeSerialize(System.IO.Stream)">
            <summary>
            Deserialize an DtmParameters
            </summary>
            
            <param name="ParametersStream">Stream containing a serialized DtmParameters</param>
            
            <returns>A populated DtmParameters</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.Serialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters)">
            <summary>
            Serialize an DtmParameters structure
            </summary>
            
            <param name="Paramaters">A DtmParameters structure</param>
            
            <returns>A stream containing the DtmParameters data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.GetHeaderSize">
            <summary>
            Get the class Size in bytes
            </summary>
            
            <returns>Serialized class size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.ToBytes">
            <summary>
            Returns the DtmParameters as an encoded byte array
            </summary>
            
            <returns>The serialized DtmParameters</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.ToStream">
            <summary>
            Returns the DtmParameters as an encoded MemoryStream
            </summary>
            
            <returns>The serialized DtmParameters</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.Clone">
            <summary>
            Create a shallow copy of this DtmParameters instance
            </summary>
            
            <returns>The DtmParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.DeepCopy">
            <summary>
            Create a deep copy of this DtmParameters instance
            </summary>
            
            <returns>The DtmParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ZeroPad">
            <summary>
            <h3>The Zero Padding Scheme (Not Recommended).</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ZeroPad.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ZeroPad.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ZeroPad.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ZeroPad.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB">
            <summary>
            <h3>Implements a Cipher FeedBack Mode: CFB.</h3>
            <para>CFB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CFB(new RDX(), [BlockSizeBits], [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Parallel processing is enabled on decryption by passing a block size of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelBlockSize"/> to the transform.</description></item>
            <item><description><see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelBlockSize"/> must be divisible by <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelMinimumSize"/>.</description></item>
            <item><description>Parallel block calculation ex. <c>int blocklen = (data.Length / cipher.ParallelMinimumSize) * 10</c></description></item>
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Int32,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="BlockSizeBits">Block size in bits; minimum is 8, or 1 byte. Maximum is Cipher block size in bits</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Cipher or valid block size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">KeyParams containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Decrypt a single block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Decrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            <para>Encrypt a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Encrypt a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CFB.ProcessorCount">
            <remarks>
            Processor count
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ISO7816">
            <summary>
            <h3>The ISO7816 Padding Scheme.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ISO7816.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ISO7816.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ISO7816.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.ISO7816.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey">
            <summary>
            The VolumeKey structure. 
            <para>This structure is used for the encryption of a series of files, each with unique key/iv pairings; like a directory or online volume.
            Keys can be added, removed, and a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class containing the key material for a specific file can be returned from a key file with this 
            structures static methods either by index, or by using a unique file id, (like the hash value of a files full path).</para>
            <para>The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory"/> class can be used to populate a VolumeKey structure with random keying material.
            This structure can be used in conjunction with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher"/> class for implementing file system level disk encryption.</para>
            </summary>
            
            <example>
            <description>Example of creating a new <c>VolumeKey</c> structure:</description>
            <code>
            // specify key tag, key length, iv length, and number of key sets
            VolumeKey _keyVol = new VolumeKey(tag, 32, 16, 100);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/05/22" version="1.3.6.0">Initial release</revision>
            <revision date="2015/07/02" version="1.4.0.0">Changes to documentation and method structure</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher">VTDev.Libraries.CEXEngine.Crypto.Processing VolumeCipher class</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory">VTDev.Libraries.CEXEngine.Crypto.Processing.Factory KeyFactory class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures PackageKey structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures KeyAuthority structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">VTDev.Libraries.CEXEngine.Crypto.Enumeration KeyPolicies Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates">VTDev.Libraries.CEXEngine.Crypto KeyStates Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">VTDev.Libraries.CEXEngine.Crypto.Processing StreamCipher class</seealso>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Tag">
            <summary>
            The volume tag; a 32 byte field identifying this volume
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Description">
            <summary>
            The session key containing the cipher description
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Count">
            <summary>
            The number of key/vector pairs in this container
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.FileId">
            <summary>
            The unique id array identifying each file in a set
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.State">
            <summary>
            The current state of the file associated with a key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.#ctor(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,System.Int32)">
            <summary>
            Initialize an empty VolumeKey structure; generates a random key tag identifier
            </summary>
            
            <param name="Description">The cipher description</param>
            <param name="Count">The number of key/vector pairs</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,System.Int32)">
            <summary>
            Initialize an empty VolumeKey structure
            </summary>
            
            <param name="Tag">The volume tag; a 32 byte field identifying this volume</param>
            <param name="Description">The cipher description</param>
            <param name="Count">The number of key/vector pairs</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.#ctor(System.IO.Stream)">
            <summary>
            Initialize the VolumeKey structure using a Stream
            </summary>
            
            <param name="KeyStream">The Stream containing the VolumeKey</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.#ctor(System.Byte[])">
            <summary>
            Initialize the VolumeKey structure using a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the VolumeKey</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.GetHeaderSize">
            <summary>
            Get the size of this header
            </summary>
            
            <returns>Returns the size of current structure in bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Contains(System.Int32)">
            <summary>
            Test if the VolumeKey contains a file id
            </summary>
            
            <param name="Id">The file id</param>
            
            <returns>Returns true if the file id is known, otherwizse false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.GetIndex(System.Int32)">
            <summary>
            Get the index of the file id in the VolumeKey
            </summary>
            
            <param name="Id">The file id</param>
            
            <returns>Returns the index, or <c>-1</c> if not found</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.KeyCount(VTDev.Libraries.CEXEngine.Crypto.Enumeration.VolumeKeyStates)">
            <summary>
            Returns the number of keys in the volume with the specified state value
            </summary>
            
            <param name="KeyState">The state to search</param>
            
            <returns>The number of keys with that state</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.NextSubKey">
            <summary>
            Get the next unused key/iv in the volume key
            </summary>
            
            <returns>The index of the next available key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.ToBytes">
            <summary>
            Convert the VolumeKey structure as a byte array
            </summary>
            
            <returns>The byte array containing the VolumeKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.ToStream">
            <summary>
            Convert the VolumeKey structure to a MemoryStream
            </summary>
            
            <returns>The MemoryStream containing the VolumeKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Add(System.IO.Stream,System.Int32,System.Byte[],System.Byte[])">
            <summary>
            Add a new file id, and key/iv pair to the VolumeKey
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="Id">The file id</param>
            <param name="Key">The key</param>
            <param name="Iv">The vector</param>
            
            <returns>Returns true if the file id is known, otherwizse false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.AtIndex(System.IO.Stream,System.Int32)">
            <summary>
            Get the key/iv at a given index
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="Index">The index value</param>
            
            <returns>A populated KeyParams class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Contains(System.IO.Stream,System.Int32)">
            <summary>
            Test if the VolumeKey contains a file id
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="Id">The file id</param>
            
            <returns>Returns true if the file id is known, otherwizse false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.FromId(System.IO.Stream,System.Int32)">
            <summary>
            Get the key/iv associated with a file id
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="Id">The file id</param>
            
            <returns>A populated KeyParams class, or null if the key is not found</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.KeyCount(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Enumeration.VolumeKeyStates)">
            <summary>
            Returns the number of keys in the volume with the specified state value
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="KeyState">The state to search</param>
            
            <returns>The number of keys with that state</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.GetIndex(System.IO.Stream,System.Int32)">
            <summary>
            Get the index of the file id in the VolumeKey
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="Id">The file id</param>
            
            <returns>Returns the index, or <c>-1</c> if not found</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.NextSubKey(System.IO.Stream)">
            <summary>
            Get the index of the next unused key/iv in the volume key
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            
            <returns>The index of the next available key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Remove(System.IO.Stream,System.Int32)">
            <summary>
            Remove a file id, and key/iv pair from the VolumeKey
            </summary>
            
            <param name="KeyStream">The stream containing the VolumeKey</param>
            <param name="Id">The file id</param>
            
            <returns>Returns true if the file id is known, otherwizse false</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the Id does not exist</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.op_Equality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey)">
            <summary>
            Compare this object instance is equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey.op_Inequality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey)">
            <summary>
            Compare this object instance is not equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Not equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">
            <summary>
            Wraps exceptions thrown within a Processing operational context.
            <para>This exception is used throughout the CompressionCipher, PacketCipher, StreamCipher, StreamDigest, StreamMac, and VolumeCipher classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory">
            <summary>
            <h3>A helper class used to create or extract a CipherKey file.</h3>
            
            <list type="bullet">
            <item><description>Constructors may use a fully qualified path to a key file, or the keys file stream.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> method requires a populated KeyParams class.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)"/> method auto-generate keying material.</description></item>
            <item><description>The Extract() method retrieves a populated cipher key (CipherKey), and key material (KeyParams), from the key file.</description></item>
            </list>
            </summary>
            
            <example>
            <description>Example using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)"/> overload:</description>
            <code>
            // create the key file
            new KeyFactory(KeyPath).Create(description);
            </code>
            
            <description>Example using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Extract(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey@,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams@)"/> method:</description>
            <code>
            // local vars
            keyparam KeyParams;
            CipherKey header;
            
            new KeyFactory(KeyPath).Extract(out header, out keyparam);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherKey Structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription Structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator">VTDev.Libraries.CEXEngine.Crypto.Processing.Factory KeyGenerator class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams">VTDev.Libraries.CEXEngine.Crypto.Processing.Structure KeyParams class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">VTDev.Libraries.CEXEngine.Crypto.Processing StreamCipher class</seealso>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.#ctor(System.String)">
            <summary>
            Initialize this class with a key file path; key will be written to the path
            </summary>
            
            <param name="KeyPath">The fully qualified path to the key file to be read or created</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the key path is invalid, a key file exists at the path specified, or file path is read only</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.#ctor(System.IO.Stream)">
            <summary>
            Initialize this class with a stream; key will be written to the stream
            </summary>
            
            <param name="KeyStream">The fully qualified path to the key file to be read or created</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null stream is passed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Finalize">
            <summary>
            Finalizer: ensure resources are destroyed
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Create a single use key file using automatic key material generation.
            <para>The Key, and optional IV and IKM are generated automatically using the cipher description contained in the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/>.
            This overload creates keying material using the seed and digest engines specified with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator"/> class</para>
            </summary>
            
            <param name="Description">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">Cipher Description</see> containing the cipher implementation details</param>
            <param name="SeedEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">Random Generator</see> used to create the stage I seed material during key generation.</param>
            <param name="HashEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest Engine</see> used in the stage II phase of key generation.</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a KeyParams member is null, but specified in the Header</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if a Header parameter does not match a KeyParams value</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Create a single use key file using a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> containing the key material, and a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> containing the cipher implementation details
            </summary>
            
            <param name="Description">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">Cipher Description</see> containing the cipher details</param>
            <param name="KeyParam">An initialized and populated key material container</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a KeyParams member is null, but specified in the Header or a Header parameter does not match a KeyParams value</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams,VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes,VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Create a single use Key file using a manual description of the cipher parameters.
            </summary>
            
            <param name="KeyParam">An initialized and populated key material container</param>
            <param name="EngineType">The Cryptographic <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Engine</see> type</param>
            <param name="KeySize">The cipher Key Size in bytes</param>
            <param name="IvSize">Size of the cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.IVSizes">Initialization Vector</see></param>
            <param name="CipherType">The type of <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.CipherModes">Cipher Mode</see></param>
            <param name="PaddingType">The type of cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes">Padding Mode</see></param>
            <param name="BlockSize">The cipher <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockSizes">Block Size</see></param>
            <param name="Rounds">The number of diffusion <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.RoundCounts">Rounds</see></param>
            <param name="KdfEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to power the key schedule Key Derivation Function in HX and M series ciphers</param>
            <param name="MacSize">The size of the HMAC message authentication code; a zeroed parameter means authentication is not enabled with this key</param>
            <param name="MacEngine">The HMAC <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engine used to authenticate a message file encrypted with this key</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a KeyParams member is null, but specified in the Header</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if a Header parameter does not match a KeyParams value</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Extract(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey@,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams@)">
            <summary>
            Extract a KeyParams and CipherKey
            </summary>
            
            <param name="KeyHeader">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey"/> that receives the cipher description, key id, and extension key</param>
            <param name="KeyParam">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> container that receives the key material from the file</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the key file could not be found or a Header parameter does not match the keystream length</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.KeyFactory.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.StreamCiphers">
            <summary>
            Stream Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.StreamCiphers.ChaCha">
            <summary>
            An implementation of the ChaCha Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.StreamCiphers.Fusion">
            <summary>
            An implementation of the Twofish and Rijndael Merged Stream Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.StreamCiphers.Salsa">
            <summary>
            A Salsa20 Stream Cipher
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">
            <summary>
            Message Digests
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Blake256">
            <summary>
            The Blake digest with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Blake512">
            <summary>
            The Blake digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Keccak256">
            <summary>
            The SHA-3 digest based on Keccak with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Keccak512">
            <summary>
            The SHA-3 digest based on Keccak with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Keccak1024">
            <summary>
            The SHA-3 digest based on Keccak with a 1024 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.SHA256">
             <summary>
            The SHA-2 digest with a 256 bit return size
             </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.SHA512">
            <summary>
            The SHA-2 digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Skein256">
            <summary>
            The Skein digest with a 256 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Skein512">
            <summary>
            The Skein digest with a 512 bit return size
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests.Skein1024">
            <summary>
            The Skein digest with a 1024 bit return size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM">
            <summary>
            <h3>TSM: An implementation based on the Twofish and Serpent Merged block ciphers, extended with an HKDF powered Key Schedule.</h3>
            <para>TSM is Twofish<cite>Twofish</cite> and Serpent<cite>Serpent</cite> ciphers, merged within the rounds function.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new TSM()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 16, 24, and 32, default is 16.</description></item>
            </list>
            
            <para>The transform combines the two ciphers within the rounds function processing loop. 
            In the rounds functions, a round of Twofish is processed; the permuted product of that transformation is then transformed again by a round of Serpent.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and creates a cipher 
            that is very resistant to cryptanalysis.</para>
            
            <para>The key schedule in TSM powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            TSM is capable of processing up to 32 rounds, that is twice the number of rounds used in a standard implementation of Twofish. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Twofish: <see href="https://www.schneier.com/paper-twofish-paper.pdf">Specification</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">Fips 198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds"/> property contains available sizes. Default is 16 rounds.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.TSM.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets">
            <summary>
            Contains sets of predefined Generalized Merkle Signature Scheme parameters.
            <para>Use the FromId(byte[]) or FromName(GMSSParamSets) to return a deep copy of a parameter set.</para>
            </summary>
            
            <revisionHistory>
            <revision date="2015/06/07" version="1.0.1.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSSign Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Parameter Sets:</h4></description>
            <list type="table">
            <listheader>
                <term>Strength</term>
                <term>N</term>
                <term>V1, V2, V3, V4</term>
            </listheader>
            
            <item><description>Low</description></item>
            <item><description>33</description></item>
            <item><description>6, 12, 17, 22</description></item>
            
            <item><description>Medium</description></item>
            <item><description>49</description></item>
            <item><description>19, 26, 32, 38</description></item>
            
            <item><description>Medium</description></item>
            <item><description>54</description></item>
            <item><description>21, 27, 34, 44</description></item>
            
            <item><description>High</description></item>
            <item><description>58</description></item>
            <item><description>24, 30, 37, 44</description></item>
            
            <item><description>High</description></item>
            <item><description>60</description></item>
            <item><description>24, 30, 37, 45</description></item>
            
            <item><description>High</description></item>
            <item><description>63</description></item>
            <item><description>26, 33, 40, 51</description></item>
            
            <item><description>High</description></item>
            <item><description>66</description></item>
            <item><description>27, 35, 43, 54</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Selecting Parameters for the Generalized Merkle Signature Scheme Signature Scheme<cite>Generalized Merkle Signature Scheme Parameters</cite>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.FromId(System.Byte[])">
            <summary>
            Retrieve a parameter set by its identity code
            </summary>
            
            <param name="OId">The 4 byte parameter set identity code</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.FromName(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSParamNames)">
            <summary>
            Retrieve a parameter set by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GetID(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSParamNames)">
            <summary>
            Retrieve the parameter OId by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>The 4 byte OId field</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSN2P10">
            <summary>
            Creates 2^10 (1024) signatures using the parameter set: (P(2, (5, 5), (3, 3), (3, 3)))
            <para>H: 10, W: 3, K: 2, PublicKey Size: 36, PrivateKey Size: 1806</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSN2P20">
            <summary>
            Creates 2^20 (1048576) signatures using the parameter set: (P(2, (10, 10), (5, 4), (2, 2)))
            <para>H: 10,10, W: 5,4, K: 2,2, PublicKey Size: 36, PrivateKey Size: 6846</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSN2P40">
            <summary>
            Creates 2^40 (1099511627776) signatures using the parameter set: (P(2, (10, 10, 10, 10), (9, 9, 9, 3), (2, 2, 2, 2)))
            <para>H: 10, 10, 10, 10, W: 9, 9, 9, 3 K: 2, 2, 2, 2, PublicKey Size: 36, PrivateKey Size: 14534</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSParamNames">
            <summary>
            Set id is defined as: N: 2 <c>pow</c> base maximum signatures
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSParamNames.N2P10">
            <summary>
            Creates 2^10 (1024) signatures using the parameter set: (P(2, (5, 5), (3, 3), (3, 3)))
            <para>H: 10, W: 3, K: 2, PublicKey Size: 36, PrivateKey Size: 1806</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSParamNames.N2P20">
            <summary>
            Creates 2^20 (1048576) signatures using the parameter set: (P(2, (10, 10), (5, 4), (2, 2)))
            <para>H: 10,10, W: 5,4, K: 2,2, PublicKey Size: 36, PrivateKey Size: 6846</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParamSets.GMSSParamNames.N2P40">
            <summary>
            Creates 2^40 (1099511627776) signatures using the parameter set: (P(2, (10, 10, 10, 10), (9, 9, 9, 3), (2, 2, 2, 2)))
            <para>H: 10, 10, 10, 10, W: 9, 9, 9, 3 K: 2, 2, 2, 2, PublicKey Size: 36, PrivateKey Size: 14534</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmMessageFlags">
            <summary>
            The flag indicating the state of a transfer operation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmMessageFlags.Transmission">
            <summary>
            The payload is a post-exchange encrypted datagram
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Queue.WaitQueue">
            <summary>
            <h3>WaitQueue: An implementation of a delayed Wait Queue.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.#ctor(System.Int32,System.Double)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Size">Queue size, should be a multible of cipher block size, e.g. 16 block = 1440 queue</param>
            <param name="CTime">Constant time value for each queue processed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.DeQueue">
            <summary>
            Empty the queue
            </summary>
            
            <returns>Queued values</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Final(System.Byte[])">
            <summary>
            Process a partial queue size, then trigger wait
            </summary>
            
            <param name="Data">Queue input</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Initialize">
            <summary>
            Initialize the queue
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Queue(System.Byte[])">
            <summary>
            Add data to the queue
            </summary>
            
            <param name="Data">Queue input</param>
            
            <returns>Returns true if queue is full</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Queue.WaitQueue.ProcessingTimes">
            <summary>
            Contains high and low processing times
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Queue.WaitQueue.ProcessingTimes.Low">
            <summary>
            Low order time
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Queue.WaitQueue.ProcessingTimes.High">
            <summary>
            Maximum time
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue">
            <summary>
            <h3>Test WaitQueue to calculate time threshhold measurements.</h3>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue.Samples">
            <summary>
            Timing samples, maximum and minimum times
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue.#ctor(System.Int32,System.Double)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Size">Size of queue</param>
            <param name="CTime">Not used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue.Initialize">
            <summary>
            Initialize the queue
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.WaitQueue.SampleQueue.SQueue(System.Byte[])">
            <summary>
            Add data to the queue
            </summary>
            
            <param name="Data">Queue input</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Queue.JitterQueue">
            <summary>
            <h3>JitterQueue: Adds a small amount of random delay time to a queuing operation.</h3>
            <para>Note v1.3: Not Tested</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.#ctor(System.Int32,System.Int16)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Size">Queue size, should be a multible of cipher block size, e.g. 16 block = 1440 queue</param>
            <param name="MaxTime">Maximum delay time in milliseconds. Range is 1 to 65535</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.DeQueue">
            <summary>
            Empty the queue
            </summary>
            
            <returns>Queued values</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Final(System.Byte[])">
            <summary>
            Process a partial queue size, then trigger wait
            </summary>
            
            <param name="Data">Queue input</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Initialize">
            <summary>
            Initialize the queue
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Queue(System.Byte[])">
            <summary>
            Add data to the queue
            </summary>
            
            <param name="Data">Queue input</param>
            
            <returns>Returns true if queue is full</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Queue.JitterQueue.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Conversion">
            <summary>
            Static library that provides BigInteger base conversion from/to any integer represented in an String Object
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.BigInteger2Double(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or 
            Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <param name="Value">The value to convert</param>
            
            <returns>Returns a BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            The double representation has a mantissa of length 53. For example, 2^53+1 = 9007199254740993 is returned as double 9007199254740992.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.BigInteger2String(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a string containing a string representation of this  BigInteger with base radix.
            <para>If Radix &lt; CharHelper.MIN_RADIX} or Radix > CharHelper.MAX_RADIX then a decimal representation is returned.
            The CharHelpers of the string representation are generated with method CharHelper.forDigit.</para>
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Radix">Base to be used for the string representation</param>
            
            <returns>Returns a string representation of this with radix 10</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.ToDecimalScaledString(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Scale">The scale</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Conversion.ToDecimalScaledString(System.Int64,System.Int32)">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="Value">The value to convert</param>
            <param name="Scale">The scale</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket">
            <summary>
            The DTM Packet structure.
            The primary packet header used in a DTM key exchange; used to classify and describe the message content.
            </summary>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmClient structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmIdentity structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmSession structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmParameters class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmKex class</seealso>
            
            <revisionHistory>
            <revision date="2015/06/14" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.PacketType">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes"/> message type; describes the packet classification
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.PayloadLength">
            <summary>
            The length of the payload contained in the packet
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.Sequence">
            <summary>
            The packet sequence number
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.PacketFlag">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags"/> exchange state; indicates the exchange state position
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.OptionFlag">
            <summary>
            This flag can be used as a time stamp indicating the expiry time of the corresponding session key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes,System.Int64,System.Int64,System.Int16,System.Int64)">
            <summary>
            CTKEPacket primary constructor
            </summary>
            
            <param name="PacketType">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes"/> message type; describes the packet classification</param>
            <param name="PayloadLength">The length of the payload contained in the packet</param>
            <param name="Sequence">The packet sequence number</param>
            <param name="PacketFlag">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags"/> exchange state; indicates the exchange state position</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.#ctor(System.Byte[])">
            <summary>
            Extracts a DtmPacket from a byte array
            </summary>
            
            <param name="PacketArray">The byte array containing the DtmPacket structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.#ctor(System.IO.Stream)">
            <summary>
            Extracts a DtmPacket from a Stream
            </summary>
            
            <param name="PacketStream">The Stream containing the DtmPacket structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.ToBytes">
            <summary>
            Returns the DtmPacket as a byte array
            </summary>
            
            <returns>The serialized DtmPacket</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.ToStream">
            <summary>
            Returns the DtmPacket as a MemoryStream
            </summary>
            
            <returns>The serialized DtmPacket</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.DeSerialize(System.IO.Stream)">
            <summary>
            Deserialize a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/>
            </summary>
            
            <param name="PacketStream">Stream containing a serialized CTKEPacket</param>
            
            <returns>A populated CTKEPacket</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.Serialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket)">
            <summary>
            Serialize a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/> structure
            </summary>
            
            <param name="Packet">A CTKEPacket structure</param>
            
            <returns>A stream containing the CTKEPacket data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey">
             <summary>
             The CipherKey structure.
             <para>Used in conjunction with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher"/> class. 
             This structure is used as the header for a single use key and vector set.</para>
             </summary>
             
             <example>
             <description>Example of populating a CipherKey structure:</description>
             <code>
             CipherKey ck = new CipherKey(description);
             </code>
             </example>
            
             <revisionHistory>
             <revision date="2015/05/22" version="1.3.6.0">Initial release</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory">VTDev.Libraries.CEXEngine.Crypto KeyFactory class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription structure</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">VTDev.Libraries.CEXEngine.Crypto.Processing StreamCipher class</seealso>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.Description">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">CipherDescription</see> structure containing a complete description of the cipher instance
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.KeyID">
            <summary>
            The unique 16 byte ID field used to identify this key. A null value auto generates this field
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.ExtensionKey">
            <summary>
            An array of random bytes used to encrypt a message file extension. A null value auto generates this field
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.#ctor(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,System.Byte[],System.Byte[])">
            <summary>
            CipherKey structure constructor.
            <para>KeyID and ExtRandom values must each be 16 bytes in length.
            If they are not specified they will be populated automatically.</para>
            </summary>
            
            <param name="Description">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">CipherDescription</see> structure containing a complete description of the cipher instance</param>
            <param name="KeyId">The unique 16 byte ID field used to identify this key. A null value auto generates this field</param>
            <param name="ExtensionKey">An array of random bytes used to encrypt a message file extension. A null value auto generates this field</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if either the KeyId or ExtensionKey fields are null or invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.#ctor(System.IO.Stream)">
            <summary>
            Initialize the CipherKey structure using a Stream
            </summary>
            
            <param name="KeyStream">The Stream containing the CipherKey</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.#ctor(System.Byte[])">
            <summary>
            Initialize the CipherKey structure using a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the CipherKey</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.Reset">
            <summary>
            Reset all members of the CipherKey structure, including the CipherDescription
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.ToBytes">
            <summary>
            Convert the CipherKey structure as a byte array
            </summary>
            
            <returns>The byte array containing the CipherKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.ToStream">
            <summary>
            Convert the CipherKey structure to a MemoryStream
            </summary>
            
            <returns>The MemoryStream containing the CipherKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.GetCipherDescription(System.IO.Stream)">
            <summary>
            Get the cipher description header
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            
            <returns>CipherDescription structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.GetExtensionKey(System.IO.Stream)">
            <summary>
            Get the extension key (16 bytes)
            </summary>
            
            <param name="KeyStream">The stream containing the cipher key</param>
            
            <returns>The file extension key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.GetKeyId(System.IO.Stream)">
            <summary>
            Get the key id (16 bytes)
            </summary>
            
            <param name="KeyStream">The stream containing a cipher key</param>
            
            <returns>The file extension key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.SetCipherDescription(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription)">
            <summary>
            Set the CipherDescription structure
            </summary>
            
            <param name="KeyStream">The stream containing a key package</param>
            <param name="Description">The CipherDescription structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.SetExtensionKey(System.IO.Stream,System.Byte[])">
            <summary>
            Set the ExtensionKey
            </summary>
            
            <param name="KeyStream">The stream containing a cipher key</param>
            <param name="ExtensionKey">Array of 16 bytes containing the ExtensionKey</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.SetKeyId(System.IO.Stream,System.Byte[])">
            <summary>
            Set the ExtensionKey
            </summary>
            
            <param name="KeyStream">The stream containing a cipher key</param>
            <param name="KeyId">Array of 16 bytes containing the key id</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.op_Equality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey)">
            <summary>
            Compare this object instance is equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey.op_Inequality(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.CipherKey)">
            <summary>
            Compare this object instance is not equal to another
            </summary>
            
            <param name="X">The first object</param>
            <param name="Y">The second object</param>
            
            <returns>Not equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng">
            <summary>
            <h3>SP20Prng: An implementation of a Encryption Counter based Deterministic Random Number Generator.</h3>
            <para>Uses the Salsa20 Key stream as a source of random input.</para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new SP20Prng([SeedGenerators], [BufferSize], [SeedSize], [RoundsCount]))
            {
                // get random int
                num = rnd.Next([Minimum], [Maximum]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/14" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            <item><description>Parallel block size is 64,000 bytes by default; but is configurable.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="SeedEngine">The Seed engine used to create keyng material (default is CSPRsg)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="SeedSize">The size of the seed to generate in bytes; can be 32 for a 128 bit key or 48 for a 256 bit key</param>
            <param name="Rounds">The number of diffusion rounds to use when generating the key stream</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if the seed is null or invalid, or rounds count is out of range</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is key size + iv of 16 bytes)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="Rounds">The number of diffusion rounds to use when generating the key stream</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if the seed is null or invalid, or rounds count is out of range</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Reset">
            <summary>
            Reset the SP20Prng instance
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.SP20Prng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes">
            <summary>
            Block Cipher Padding Modes
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes.ISO7816">
            <summary>
            ISO7816 Padding Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes.PKCS7">
            <summary>
            PKCS7 Padding Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes.TBC">
            <summary>
            Trailing Bit Complement Padding Mode
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PaddingModes.X923">
            <summary>
            X923 Padding Mode
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20">
            <summary>
            <h3>Salsa20+: A parallelized Salsa20 stream cipher implementation.</h3>
            <para>A Salsa20 cipher extended to use up to 30 rounds.</para>
            </summary>
            
            <example>
            <description>Example using an <c>IStreamCipher</c> interface:</description>
            <code>
            using (IStreamCipher cipher = new Salsa20())
            {
                // initialize for encryption
                cipher.Initialize(new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/06/14" version="1.4.0.0">Added parallel processing</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 256 (16 and 32 bytes).</description></item>
            <item><description>Block size is 64 bytes wide.</description></item>
            <item><description>Valid rounds are 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28 and 30.</description></item>
            <item><description>Parallel block size is 64,000 bytes by default; but is configurable.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Salsa20 <see href="http://www.ecrypt.eu.org/stream/salsa20pf.html">Specification</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/design.pdf">Design</see>.</description></item>
            <item><description>Salsa20 <see href="http://cr.yp.to/snuffle/security.pdf">Security</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalRounds"/> property contains available sizes. Default is 20 rounds.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="KeyParam">Cipher key container. 
            <para>Uses the Key and IV fields of KeyParam. 
            The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes"/> property contains valid Key sizes. 
            IV must be 8 bytes in size.</para>
            </param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null key or iv  is used</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Thrown if an invalid key or iv size is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Reset">
            <summary>
            Reset the primary internal counter
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Byte[])">
            <summary>
            Encrypt/Decrypt an array of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Input bytes, plain text for encryption, cipher text for decryption</param>
            <param name="Output">Output bytes, array of at least equal size of input that receives processed bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Transform(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt/Decrypt an array of bytes with offset and length parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Length">Number of bytes to process</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Counter">
            <summary>
            Get the current counter value
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.DistributionCode">
            <summary>
            Get/Set: Sets the Nonce value in the initialization parameters (Tau-Sigma). 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code must be 16 bytes in length and sufficiently asymmetric (no more than 2 repeats, of 2 bytes, at a distance of 2 intervals).</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, or  block size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.ProcessorCount">
            <remarks>
            Get: Processor count
            </remarks>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.Rounds">
            <summary>
            Get: Number of rounds
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.Salsa20.VectorSize">
            <summary>
            Get: Initialization vector size
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters">
            <summary>
            Creates, reads and writes parameter settings for MPKCEncrypt.
            <para>Predefined parameter sets are available and new ones can be created as well.
            These predefined settings are accessable through the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets"/> class</para>
            </summary>
            
            <example>
            <description>Create a parameter set and write to stream:</description>
            <code>
            MemoryStream ks = new MemoryStream();
            using (MPKCParameters mp = new MPKCParameters(new byte[] { 1, 1, 11, 1 }, 11, 40, McElieceCiphers.Fujisaki, Digests.SHA256))
               mp.WriteTo(ks);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.0.1.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCEncrypt">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece MPKCEncrypt Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.McElieceCiphers Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>MPKC Parameter Description:</h4></description>
            <list type="table">
            <item><description><c>OId</c> - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The McEliece family must be <c>1</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</description></item>
            <item><description><c>M</c> - The degree of the finite field GF(2^m).</description></item>
            <item><description><c>T</c> - The error correction capability of the code.</description></item>
            <item><description><c>Engine</c> - The McEliece CCA2 cipher engine.</description></item>
            <item><description><c>Digest</c> - The digest used by the cipher engine.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>McEliece Handbook of Applied Cryptography: Chapter 8<cite>McEliece Handbook of Applied Cryptography</cite>.</description></item>
            <item><description>Selecting Parameters for Secure McEliece-based Cryptosystems<cite>McEliece Parameters</cite>.</description></item>
            <item><description>Weak keys in the McEliece public-key cryptosystem<cite>McEliece Weak keys</cite>.</description></item>
            <item><description>McBits: fast constant-time code-based cryptography<cite>McEliece McBits</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> versions McEliece implementation.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Set the default parameters: extension degree
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The McEliece family must be <c>1</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="CCA2Engine">The McEliece CCA2 cipher engine</param>
            <param name="Digest">The digest used by the cipher engine</param>
            <param name="Prng">The prng used by the cipher engine</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.#ctor(System.Byte[],System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The McEliece family must be <c>1</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="Keysize">The length of a Goppa code</param>
            <param name="CCA2Engine">The McEliece CCA2 cipher engine</param>
            <param name="Digest">The digest used by the cipher engine</param>
            <param name="Prng">The Prng used by the cipher</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the OId is invalid, or <c>keysize &lt; 1</c></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.#ctor(System.Byte[],System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The McEliece family must be <c>1</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="M">The degree of the finite field GF(2^m)</param>
            <param name="T">The error correction capability of the code</param>
            <param name="CCA2Engine">The McEliece CCA2 cipher engine</param>
            <param name="Digest">The digest used by the cipher engine</param>
            <param name="Prng">The Prng used by the cipher</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the OId is invalid or; <c>m &lt; 1</c>, <c>m &gt; 32</c>, <c>t &lt; 0</c> or <c>t &gt; n</c></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="OId">OId - Unique identifier; <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Designator</c>. The McEliece family must be <c>1</c> corresponding with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</param>
            <param name="M">The degree of the finite field GF(2^m)</param>
            <param name="T">The error correction capability of the code</param>
            <param name="FieldPoly">The field polynomial</param>
            <param name="CCA2Engine">The McEliece CCA2 cipher engine</param>
            <param name="Digest">The digest used by the cipher engine</param>
            <param name="Prng">The Prng used by the cipher</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the OId is invalid or; <c>t &lt; 0</c>, <c>t &gt; n</c>, or <c>poly</c> is not an irreducible field polynomial</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.#ctor(System.IO.Stream)">
            <summary>
            Builds a parameter set from an encoded input stream
            </summary>
            
            <param name="ParamStream">Stream containing a parameter set</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the Stream is unreadable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.#ctor(System.Byte[])">
            <summary>
            Builds a parameter set from an encoded byte array
            </summary>
            
            <param name="ParamArray">Byte array containing a parameter set</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.From(System.Byte[])">
            <summary>
            Read an encoded Parameter set from a byte array
            </summary>
            
            <param name="ParamArray">The byte array containing the parameters</param>
            
            <returns>An initialized MPKCParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.From(System.IO.Stream)">
            <summary>
            Read an encoded Parameters set from a Stream
            </summary>
            
            <param name="ParamStream">The Stream containing the encoded Parameter set</param>
            
            <returns>An initialized MPKCParameters class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.ToBytes">
            <summary>
            Converts the current Parameter set to an encoded byte array
            </summary>
            
            <returns>McElieceParameters as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.ToStream">
            <summary>
            Converts the current Parameter set to an encoded Stream
            </summary>
            
            <returns>McElieceParameters as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.WriteTo(System.Byte[])">
            <summary>
            Writes the MPKCParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the MPKCParameters to a byte array
            </summary>
            
            <param name="Output">Output array receiving the encoded Parameters</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if The output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.WriteTo(System.IO.Stream)">
            <summary>
            Writes the MPKCParameters to a Stream
            </summary>
            
            <param name="Output">The Output stream receiving the encoded Parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.Clone">
            <summary>
            Create a shallow copy of this McElieceParameters instance
            </summary>
            
            <returns>The McElieceParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.DeepCopy">
            <summary>
            Create a deep copy of this MPKCParameters instance
            </summary>
            
            <returns>The MPKCParameters copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.Name">
            <summary>
            Get: Parameters name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.CCA2Engine">
            <summary>
            The cipher engine used for encryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.Digest">
            <summary>
            The digest engine used to power CCA2 variants
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid digest is specified</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.FieldPolynomial">
            <summary>
            Returns the field polynomial
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.M">
            <summary>
            Returns the extension degree of the finite field GF(2^m)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.N">
            <summary>
            Returns the length of the code _maxPlainText = (((MPKCPublicKey)AsmKey).K >> 3);
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.OId">
            <summary>
            Get: Three bytes that uniquely identify the parameter set
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.RandomEngine">
            <summary>
            The cipher Prng
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters.T">
            <summary>
            Return the error correction capability of the code
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Conversions">
            <summary>
            Provides methods for CCA2-Secure Conversions of McEliece PKCS
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Conversions.Encode(System.Int32,System.Int32,System.Byte[])">
            <summary>
            Encode a number between 0 and (n|t) (binomial coefficient) into a binary vector of length n with weight t. 
            <para>The number is given as a byte array. Only the first s bits are used, where s = floor[log(n|t)].</para>
            </summary>
            
            <param name="N">The "n" integer</param>
            <param name="T">The "t" integer</param>
            <param name="M">The message as a byte array</param>
            
            <returns>The encoded message as GF2Vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Conversions.Decode(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector)">
            <summary>
            Decode a binary vector of length n and weight t into a number between 0 and (n|t) (binomial coefficient).
            <para>The result is given as a byte array of length floor[(s+7)/8], where s = floor[log(n|t)].</para>
            </summary>
            
            <param name="N">The "n" integer</param>
            <param name="T">The "t" integer</param>
            <param name="GVector">The binary vector</param>
            
            <returns>The decoded vector as a byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Conversions.SignConversion(System.Int32,System.Int32,System.Byte[])">
            <summary>
            Compute a message representative of a message given as a vector of length <c>n</c> bit and of hamming weight <c>t</c>. 
            <para>The result is a byte array of length <c>(s+7)/8</c>, where <c>s = floor[log(n|t)]</c>.</para>
            </summary>
            
            <param name="N">The "n" integer</param>
            <param name="T">The "t" integer</param>
            <param name="M">The message vector as a byte array</param>
            
            <returns>A message representative for <c>m</c></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial">
            <summary>
            This class stores very long strings of bits and does some basic arithmetics.
            <para>It is used by <c>GF2nField</c>, <c>GF2nPolynomialField</c> and <c>GFnPolynomialElement</c>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.#ctor(System.Int32)">
            <summary>
            Creates a new GF2Polynomial of the given <c>Length</c> and value zero
            </summary>
            
            <param name="Length">The desired number of bits to store</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.#ctor(System.Int32,System.Random)">
            <summary>
            Creates a new GF2Polynomial of the given <c>Length</c> and random value
            </summary>
            
            <param name="Length">The desired number of bits to store</param>
            <param name="Rand">The Random instance to use for randomization</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.#ctor(System.Int32,System.String)">
            <summary>
            Creates a new GF2Polynomial of the given <c>Length</c> and value selected by <c>Value</c>
            <para>Values are: ZERO, ONE, RANDOM, X and ALL</para>
            </summary>
            
            <param name="Length">The desired number of bits to store</param>
            <param name="Value">The value described by a String</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.#ctor(System.Int32,System.Int32[])">
            <summary>
            Creates a new GF2Polynomial of the given <c>Length</c> using the given int[]. LSB is contained in bs[0].
            </summary>
            
            <param name="Length">The desired number of bits to store</param>
            <param name="Bs">Contains the desired value, LSB in bs[0]</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.#ctor(System.Int32,System.Byte[])">
            <summary>
            Creates a new GF2Polynomial by converting the given byte[] <c>Os</c> according to 1363 and using the given <c>Length</c>
            </summary>
            
            <param name="Length">The intended length of this polynomial</param>
            <param name="Os">The octet string to assign to this polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Creates a new GF2Polynomial by converting the given FlexiBigInt <c>Bi</c> according to 1363 and using the given <c>Length</c>
            </summary>
            
            <param name="Length">The intended length of this polynomial</param>
            <param name="Bi">The FlexiBigInt to assign to this polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Creates a new GF2Polynomial by cloneing the given GF2Polynomial <c>B</c>
            </summary>
            
            <param name="B">The GF2Polynomial to clone</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ToByteArray">
            <summary>
            Converts this polynomial to a byte[] (octet string) according to 1363
            </summary>
            
            <returns>Return a byte[] representing the value of this polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ToFlexiBigInt">
            <summary>
            Converts this polynomial to an integer according to 1363
            </summary>
            
            <returns>Returns a FlexiBigInt representing the value of this polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ToIntegerArray">
            <summary>
            Returns the value of this GF2Polynomial in an integer array
            </summary>
            
            <returns>Returns the value of this GF2Polynomial in a new int[], LSB in int[0]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ToString(System.Int32)">
            <summary>
            Returns a string representing this GF2Polynomials value using hexadecimal or binary radix in MSB-first order
            </summary>
            
            <param name="Radix">The radix to use (2 or 16, otherwise 2 is used)</param>
            
            <returns>Returns a String representing this GF2Polynomials value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Adds two GF2Polynomials, <c>this</c> and <c>B</c>, and returns the result. 
            <c>this</c> and <c>B</c> can be of different size.
            </summary>
            
            <param name="B">A GF2Polynomial</param>
            
            <returns>Returns a new GF2Polynomial (<c>this</c> + <c>B</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.AddToThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Adds <c>B</c> to this GF2Polynomial and assigns the result to this GF2Polynomial. 
            <c>B</c> can be of different size.
            </summary>
            
            <param name="B">GF2Polynomial to add to this GF2Polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.AssignAll">
            <summary>
            Sets all Bits to 1
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.AssignOne">
            <summary>
            Sets the LSB to 1 and all other to 0, assigning 'one' to this GF2Polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.AssignX">
            <summary>
            Sets Bit 1 to 1 and all other to 0, assigning 'x' to this GF2Polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.AssignZero">
            <summary>
            Resets all bits to zero
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Clone">
            <summary>
            Return a copy of this GF2Polynomial
            </summary>
            
            <returns>Returns a copy of <c>this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Divide(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Divides <c>this</c> by <c>G</c> and returns the quotient and remainder in a new GF2Polynomial[2], quotient in [0], remainder in [1]
            </summary>
            
            <param name="G">A GF2Polynomial != 0</param>
            
            <returns>Returns a new GF2Polynomial[2] containing quotient and remainder</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ExpandN(System.Int32)">
            <summary>
            Expands len and int[] value to <c>I</c>. This is useful before adding two GF2Polynomials of different size
            </summary>
            
            <param name="I">The intended length</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.GetBit(System.Int32)">
            <summary>
            Returns the bit at position <c>Index</c>
            </summary>
            
            <param name="Index">The index</param>
            
            <returns>Returns the bit at position <c>Index</c> if <c>Index</c> is a valid position, 0 otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Gcd(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Returns the greatest common divisor of <c>this</c> and <c>G</c> in a new GF2Polynomial
            </summary>
            
            <param name="G">A GF2Polynomial != 0</param>
            
            <returns>Returns a new GF2Polynomial gcd(<c>this</c>,<c>g</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Increase">
            <summary>
            Toggles the LSB of this GF2Polynomial, increasing the value by 'one' and returns the result in a new GF2Polynomial
            </summary>
            
            <returns>Returns <c>this + 1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.IncreaseThis">
            <summary>
            Toggles the LSB of this GF2Polynomial, increasing its value by 'one'
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.IsIrreducible">
            <summary>
            Checks if <c>this</c> is irreducible, according to IEEE P1363, A.5.5, p103.
            <para>Note: The algorithm from IEEE P1363, A5.5 can be used to check a polynomial with coefficients in GF(2^r) for irreducibility.
            As this class only represents polynomials with coefficients in GF(2), the algorithm is adapted to the case r=1.</para>
            </summary>
            
            <returns>Returns true if <c>this</c> is irreducible</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.IsOne">
            <summary>
            Tests if all bits are reset to 0 and LSB is set to 1
            </summary>
            
            <returns>Returns true if this GF2Polynomial equals 'one' (<c>this</c> == 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.IsZero">
            <summary>
            Tests if all bits equal zero
            </summary>
            
            <returns>Returns true if this GF2Polynomial equals 'zero' (<c>this</c> == 0)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Multiplies this GF2Polynomial with <c>B</c> and returns the result in a new GF2Polynomial. 
            This method does not reduce the result in GF(2^N).
            This method uses Karatzuba multiplication.
            </summary>
            
            <param name="B"> GF2Polynomial</param>
            
            <returns>Returns a new GF2Polynomial (<c>this</c> * <c>B</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.MultiplyClassic(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Multiplies this GF2Polynomial with <c>B</c> and returns the result in a new GF2Polynomial. This method does not reduce the result in GF(2^N).
            This method uses classic multiplication (schoolbook).
            </summary>
            
            <param name="B">A GF2Polynomial</param>
            
            <returns>Returns a new GF2Polynomial (<c>this</c> * <c>B</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Quotient(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Returns the absolute quotient of <c>this</c> divided by <c>G</c> in a new GF2Polynomial
            </summary>
            
            <param name="G">A GF2Polynomial != 0</param>
            
            <returns>Returns a new GF2Polynomial |_ <c>this</c> / <c>G</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Randomize">
            <summary>
            Fills all len bits of this GF2Polynomial with random values
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Randomize(System.Random)">
            <summary>
            Fills all len bits of this GF2Polynomial with random values using the specified source of randomness
            </summary>
            
            <param name="Rand">The source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ReduceN">
            <summary>
            Reduces len by finding the most significant bit set to one and reducing len and blocks
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ReducePentanomial(System.Int32,System.Int32[])">
            <summary>
            Reduces this GF2Polynomial using the pentanomial x^<c>M</c> + x^<c>Pc[2]</c> + x^<c>Pc[1]</c> + x^<c>Pc[0]</c> + 1
            </summary>
            
            <param name="M">The degree of the used field</param>
            <param name="Pc">The degrees of the middle x's in the pentanomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ReduceTrinomial(System.Int32,System.Int32)">
            <summary>
            Reduces this GF2Polynomial using the trinomial x^<c>M</c> + x^<c>Tc</c> + 1
            </summary>
            
            <param name="M">The degree of the used field</param>
            <param name="Tc">The degree of the middle x in the trinomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Remainder(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Returns the remainder of <c>this</c> divided by <c>G</c> in a new GF2Polynomial
            </summary>
            
            <param name="G">A GF2Polynomial != 0</param>
            
            <returns>Returns a new GF2Polynomial (<c>this</c> % <c>G</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ResetBit(System.Int32)">
            <summary>
            Resets the bit at position <c>Index</c>
            </summary>
            
            <param name="Index">The index</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.SetBit(System.Int32)">
            <summary>
            Sets the bit at position <c>Index</c>
            </summary>
            
            <param name="Index">The index</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ShiftLeft">
            <summary>
            Returns this GF2Polynomial shift-left by 1 in a new GF2Polynomial
            </summary>
            
            <returns>Returns a new GF2Polynomial (this &lt;&lt; 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ShiftLeft(System.Int32)">
            <summary>
            Returns this GF2Polynomial shift-left by <c>K</c> in a new GF2Polynomial
            </summary>
            
            <param name="K">The shift value</param>
            
            <returns>Returns a new GF2Polynomial (this &lt;&lt; <c>K</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ShiftLeftAddThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial,System.Int32)">
            <summary>
            Shifts left b and adds the result to Its a fast version of <c>this = Add(b.Shl(K));</c>
            </summary>
            
            <param name="B">GF2Polynomial to shift and add to this</param>
            <param name="K">The amount to shift</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ShiftLeftThis">
            <summary>
            Shifts-left this by one and enlarges the size of value if necesary.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ShiftRight">
            <summary>
            Returns this GF2Polynomial shift-right by 1 in a new GF2Polynomial
            </summary>
            
            <returns>Returns a new GF2Polynomial (this &lt;&lt; 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ShiftRightThis">
            <summary>
            Shifts-right this GF2Polynomial by 1
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.SquareThisBitwise">
            <summary>
            Squares this GF2Polynomial and expands it accordingly.
            <para>This method does not reduce the result in GF(2^N).
            There exists a faster method for squaring in GF(2^N).</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.SquareThisPreCalc">
            <summary>
            Squares this GF2Polynomial by using precomputed values of squaringTable.
            <para>This method does not reduce the result in GF(2^N).</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Subtract(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Subtracts two GF2Polynomials, <c>this</c> and <c>B</c>, and returns the result in a new GF2Polynomial.
            <c>this</c> and <c>B</c> can be of different size.
            </summary>
            
            <param name="B">A GF2Polynomial</param>
            
            <returns>Returns a new GF2Polynomial (<c>this</c> - <c>b</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.SubtractFromThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Subtracts <c>B</c> from this GF2Polynomial and assigns the result to this GF2Polynomial.
            <c>B</c> can be of different size.
            </summary>
            
            <param name="B">A GF2Polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.TestBit(System.Int32)">
            <summary>
            Tests the bit at position <c>Index</c>
            </summary>
            
            <param name="Index">he position of the bit to be tested</param>
            
            <returns>Returns true if the bit at position <c>i</c> is set (a(<c>Index</c>) == 1). False if (<c>Index</c> &lt; 0) || (<c>Index</c> &gt; (len - 1))</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.VectorMult(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Does a vector-multiplication modulo 2 and returns the result as boolean
            </summary>
            
            <param name="B">The GF2Polynomial</param>
            
            <returns>Returns this x <c>B</c> as boolean (1-&gt;true, 0-&gt;false)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Xor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Returns the bitwise exclusive-or of <c>this</c> and <c>B</c> in a new GF2Polynomial;
            <c>this</c> and <c>B</c> can be of different size.
            </summary>
            
            <param name="B">The GF2Polynomial</param>
            
            <returns>Returns a new GF2Polynomial (<c>this</c> ^ <c>B</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.XorBit(System.Int32)">
            <summary>
            Xors the bit at position <c>Index</c>
            </summary>
            
            <param name="Index">The index</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.XorThisBy(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Computes the bitwise exclusive-or of this GF2Polynomial and <c>B</c> and stores the result in this GF2Polynomial;
            <c>B</c> can be of different size.
            </summary>
            
            <param name="B">The GF2Polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ZeroUnusedBits">
            <summary>
            If Length is not a multiple of the block size (32), some extra bits of the last block might have been modified during a blockwise operation.
            This method compensates for that by restoring these "extra" bits to zero.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Equals(System.Object)">
            <summary>
            Compare this element with another object
            </summary>
            
            <param name="Obj">The object for comprison</param>
            
            <returns>Returns <c>true</c> if the two objects are equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.GetHashCode">
            <summary>
            Returns the hash code of this element
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.DoShiftBlocksLeft(System.Int32)">
            <summary>
            Shifts left this GF2Polynomial's value blockwise <c>B</c> blocks resulting in a shift-left by b*32.
            This method assumes that Length and blocks have already been updated to reflect the final state.
            </summary>
            
            <param name="B">The shift amount (in blocks)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.KaraMult(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial)">
            <summary>
            Does the recursion for Karatzuba multiplication
            </summary>
            
            <param name="B">A GF2Polynomial</param>
            
            <returns><c>this * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Lower(System.Int32)">
            <summary>
            Returns a new GF2Polynomial containing the lower <c>K</c> bytes of this GF2Polynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Mult32(System.Int32,System.Int32)">
            <summary>
            4-Byte Version of Karatzuba multiplication. Here the actual work is done
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Mult64(System.Int32[],System.Int32[])">
            <summary>
            2-Integer Version of Karatzuba multiplication
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Mult128(System.Int32[],System.Int32[])">
            <summary>
            4-Integer Version of Karatzuba multiplication
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Mult256(System.Int32[],System.Int32[])">
            <summary>
            8-Integer Version of Karatzuba multiplication
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Mult512(System.Int32[],System.Int32[])">
            <summary>
            16-Integer Version of Karatzuba multiplication
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.ShiftBlocksLeft">
            <summary>
            Shifts-left this GF2Polynomial's value blockwise 1 block resulting in a shift-left by 32
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Upper(System.Int32)">
            <summary>
            Returns a new GF2Polynomial containing the upper <c>K</c> bytes of this GF2Polynomial
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial.Length">
            <summary>
            Returns the length of this GF2Polynomial. The length can be greater than the degree.
            To get the degree call ReduceN() before calling Length property.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.SystemUtils">
            <summary>
            System utilities class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.SystemUtils.Is64Bit">
            <summary>
            Test for 64 bit architecture
            </summary>
            
            <returns>True if 64 bit architecture</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.SystemUtils.IsMultiProcessor">
            <summary>
            Test for multi processor system
            </summary>
            
            <returns>True if processor count i more than 1</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BitLevel">
            <summary>
            Static library that provides all the bit level operations for BigInteger. 
            
            <description>The operations are:</description>
            <list type="number">
            <item><description>Left Shifting</description></item>
            <item><description>Right Shifting</description></item>
            <item><description>Bit Clearing</description></item>
            <item><description>Bit Setting</description></item>
            <item><description>Bit Counting</description></item>
            <item><description>Bit Testing</description></item>
            <item><description>Getting of the lowest bit set</description></item>
            </list>
            
            <para>All operations are provided in immutable way, and some in both mutable and immutable.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.BitCount(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the number of bits in the binary representation of this which differ from the sign bit. 
            <para>Use BitLength(0) if you want to know the length of the binary value in bits.
            If this is positive the result is equivalent to the number of bits set in the binary representation of this.
            If this is negative the result is equivalent to the number of bits set in the binary representation of -this - 1.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.BitLength(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the length of the value's two's complement representation without 
            leading zeros for positive numbers / without leading ones for negative values.
            <para>The two's complement representation of this will be at least BitLength() + 1 bits long.
            The value will fit into an int if <c>bitLength() &lt; 32</c> or into a long if <c>bitLength() &lt; 64</c>.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.FlipBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation 
            as this but with the bit at position N flipped. 
            <para>The result is equivalent to this ^ 2^N.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Position where the bit in this has to be flipped</param>
            
            <returns>Returns <c>this ^ 2^N</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.InplaceShiftLeft(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs val &lt;= count, val should have enough place (and one digit more)
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.InplaceShiftRight(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Performs Value >>= count where Value is a positive number.
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.NonZeroDroppedBits(System.Int32,System.Int32[])">
            <summary>
            Check if there are 1s in the lowest bits of this BigInteger
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeft(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
            
            <returns>Returns <c>this &lt;&lt; N</c> if n >= 0, <c>this >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeft(System.Int32[],System.Int32[],System.Int32,System.Int32)">
            <summary>
            Abstractly shifts left an array of integers in little endian (i.e. shift it right).
            Total shift distance in bits is intCount * 32 + count
            </summary>
            
            <param name="Result">The result</param>
            <param name="Value">The source BigIntger</param>
            <param name="IntCount">The number integers</param>
            <param name="N">The number of bits to shift</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeftOneBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Shifts the source digits left one bit, creating a value whose magnitude is doubled.
            </summary>
            
            <param name="Value">The source BigIntger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftLeftOneBit(System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Shifts the source digits left one bit, creating a value whose magnitude is doubled.
            </summary>
            
            <param name="Result">The result</param>
            <param name="Value">The source BigIntger</param>
            <param name="ValueLen">The value length</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftRight(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.
            </para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Shift distance</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.ShiftRight(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.
            </para>
            </summary>
            
            <param name="Result">The result</param>
            <param name="ResultLen">The result length</param>
            <param name="Value">The source BigIntger</param>
            <param name="IntCount">The number integers</param>
            <param name="N">Shift distance</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BitLevel.TestBit(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Tests whether the bit at position N in this is set.
            <para>The result is equivalent to <c>this &amp; (2^n) != 0</c>.</para>
            </summary>
            
            <param name="Value">The source BigIntger</param>
            <param name="N">Position where the bit in this has to be inspected.</param>
            
            <returns>Returns this &amp; (2^n) != 0</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            <h3>This class represents immutable integer numbers of arbitrary length</h3>
            
            <description>Immutable arbitrary-precision integers.</description>
            <para>All operations behave as if BigIntegers were represented in two's-complement notation.  
            BigInteger provides operations for modular arithmetic, GCD calculation, primality testing, prime generation, bit manipulation, and a few other miscellaneous operations.</para>
            </summary>
            
            <example>
            <description>Creating a random prime example:</description>
            <code>
            BigInteger p = BigInteger.ProbablePrime(BitLength, new SecureRandom());
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.2.0">Updated and expanded the implementation</revision>
            </revisionHistory>
            
            <remarks>
            <para>Semantics of arithmetic operations exactly mimic those of Java's integer arithmetic operators, as defined in The Java Language Specification.
            For example, division by zero throws an ArithmeticException, and division of a negative by a positive yields a negative (or zero) remainder.
            All of the details in the Spec concerning overflow are ignored, as BigIntegers are made as large as necessary to accommodate the results of an operation.</para>
            
            <para>Semantics of shift operations allow for negative shift distances.  
            A right-shift with a negative shift distance results in a left shift, and vice-versa.</para>
            
            <para>The binary operators (<c>And</c>, <c>Or</c>, <c>Xor</c>) implicitly perform sign extension on the shorter of the two operands prior to performing the operation.</para>
            
            <para>Modular arithmetic operations are provided to compute residues, perform exponentiation, and compute multiplicative inverses.  
            These methods always return a non-negative result, between <c>0</c> and <c>(Modulus - 1)</c>, inclusive.</para>
            
            <para>Bit operations operate on a single bit of the two's-complement representation of their operand.  
            If necessary, the operand is sign-extended so that it contains the designated bit.  
            None of the single-bit operations can produce a BigInteger with a different sign from the BigInteger being operated on, as they affect only a single bit, 
            and the "infinite word size" abstraction provided by this class ensures that there are infinitely many "virtual sign bits" preceding each BigInteger.</para>
            <para>Large numbers are typically used in security applications and therefore BigIntegers offer dedicated functionality like the generation of large 
            prime numbers or the computation of modular inverse.</para>
            <para>Since the class was modeled to offer all the functionality as the Integer class does, it provides even methods that operate bitwise 
            on a two's complement representation of large integers. 
            Note however that the implementations favors an internal representation where magnitude and sign are treated separately. 
            Hence such operations are inefficient and should be discouraged. 
            In simple words: Do NOT implement any bit fields based on BigInteger.</para>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Zero">
            <summary>
            The BigInteger constant 0
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.One">
            <summary>
            The BigInteger constant 1
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Ten">
            <summary>
            The BigInteger constant 10
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#cctor">
            <summary>
            Static constructor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Byte[])">
            <summary>
            Constructs a new BigInteger from the given two's complement representation.
            <para>The most significant byte is the entry at index 0.
            The most significant bit of this entry determines the sign of the new BigInteger instance.
            The given array must not be empty.</para>
            </summary>
            
            <param name="Value">Two's complement representation of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Byte[])">
            <summary>
            Constructs a new BigInteger instance with the given sign and the given magnitude.
            <para>The sign is given as an integer (-1 for negative, 0 for zero, 1 for positive).
            The magnitude is specified as a byte array. The most significant byte is the entry at index 0.</para>
            </summary>
            
            <param name="Signum">Sign of the new BigInteger (-1 for negative, 0 for zero, 1 for positive)</param>
            <param name="Magnitude">Magnitude of the new BigInteger with the most significant byte first</param>
            
            <exception cref="T:System.FormatException">Thrown if an invalid Signum or Magnitude is passed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Random)">
            <summary>
            Constructs a random non-negative BigInteger instance in the range [0, 2^(numBits)-1]
            </summary>
            
            <param name="NumBits">Maximum length of the new BigInteger in bits</param>
            <param name="Rand">The random generator instance (insecure)</param>
            
            <exception cref="T:System.ArgumentException">Thrown  if NumBits &gt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Constructs a random non-negative BigInteger instance in the range [0, 2^(numBits)-1]
            </summary>
            
            <param name="NumBits">Maximum length of the new BigInteger in bits</param>
            <param name="SecRand">The secure random generator</param>
            
            <exception cref="T:System.ArgumentException">Thrown  if NumBits &gt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32,System.Random)">
            <summary>
            Constructs a random BigInteger instance in the range [0, 2^(bitLength)-1] which is probably prime. 
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^certainty).</para>
            </summary>
            
            <param name="BitLength">Length of the new BigInteger in bits</param>
            <param name="Certainty">Tolerated primality uncertainty</param>
            <param name="Rnd">An optional random generator to be used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Constructs a random BigInteger instance in the range [0, 2^(bitLength)-1] which is probably prime. 
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^certainty).</para>
            </summary>
            
            <param name="BitLength">Length of the new BigInteger in bits</param>
            <param name="Certainty">Tolerated primality uncertainty</param>
            <param name="Rnd">An optional random generator to be used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.String)">
            <summary>
            Constructs a new BigInteger instance from the string representation. 
            <para>The string representation consists of an optional minus sign 
            followed by a non-empty sequence of decimal digits.</para>
            </summary>
            
            <param name="Value">String representation of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.String,System.Int32)">
            <summary>
            Constructs a new BigInteger instance from the string representation.
            <para>The string representation consists of an optional minus sign 
            followed by a non-empty sequence of digits in the specified radix.
            For the conversion the method CharHelper.Digit(char, radix) is used.</para>
            </summary>
            
            <param name="Value">String representation of the new BigInteger</param>
            <param name="Radix">The base to be used for the conversion</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32[])">
            <summary>
            Creates a new BigInteger with the given sign and magnitude.
            <para>This constructor does not create a copy, so any changes to the reference will affect the new number.</para>
            </summary>
            
            <param name="Signum">The sign of the number represented by digits</param>
            <param name="Digits">The magnitude of the number</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a number which array is of size 1
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="Value">The only one digit of array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int64)">
            <summary>
            Creates a new BigInteger whose value is equal to the specified long
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="Value">The value of the new BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Int32,System.Int32,System.Int32[])">
            <summary>
            Constructs a number without to create new space.
            <para>This construct should be used only if the three fields of representation are known.</para>
            </summary>
            
            <param name="Sign">The sign of the number</param>
            <param name="NumberLength">The length of the internal array</param>
            <param name="Digits">A reference of some array created before</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Abs">
            <summary>
            Returns a (new) BigInteger whose value is the absolute value of this
            </summary>
            
            <returns><c>Abs(this)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Add(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this + val</c>
            </summary>
            
            <param name="Augend">Value to be added to this</param>
            
            <returns><c>this + val</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.And(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one
            </summary>
            
            <param name="Value">The value to be and'ed with the current.</param>
            
            <returns>
            Returns a new BigInteger whose value is <c>this &amp; Value</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.AndNot(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this &amp; ~Value</c>.
            <para>Evaluating <c>x.AndNot(Value)</c> returns the same result as <c>x.And(Value.Not())</c>.</para>
            </summary>
            
            <param name="Value">Value to be not'ed and then and'ed with this</param>
            
            <returns><c>this &amp; ~Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ClearBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N cleared.
            <para>The result is equivalent to this <c>&amp; ~(2^n)</c>.
            </para>
            </summary>
            
            <param name="N">Position where the bit in this has to be cleared</param>
            
            <returns><c>this &amp; ~(2^n)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.CompareTo(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Compares this BigInteger with Value.
            <para>Returns one of the three values 1, 0, or -1.</para>
            </summary>
            
            <param name="Value">Value to be compared with this</param>
            
            <returns>Returns 1 if this > Value, -1 if this &lt; Value, 0 if this == Value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Divide(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this / Divisor</c>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns><c>this / Divisor</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a BigInteger array which contains <c>this / Divisor</c> at index 0 and <c>this % Divisor</c> at index 1
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns><c>[this / Divisor, this % Divisor]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.FlipBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N flipped. 
            <para>The result is equivalent to this ^ 2^N.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be flipped</param>
            
            <returns>Returns <c>this ^ 2^N</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Gcd(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is greatest common divisor of this and Value.
            <para>If this==0 and Value==0 then zero is returned, otherwise the result is positive.</para>
            </summary>
            
            <param name="Value">Value with which the greatest common divisor is computed.</param>
            <returns><c>Gcd(this, Value)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.IsProbablePrime(System.Int32)">
            <summary>
            Tests whether this BigInteger is probably prime.
            <para>If true is returned, then this is prime with a probability beyond <c>(1-1/2^certainty)</c>.
            If false is returned, then this is definitely composite.
            If the argument Certainty &lt;= 0, then this method returns true.</para>
            </summary>
            
            <param name="Certainty">Tolerated primality uncertainty</param>
            
            <returns>Returns true, if this is probably prime, false  otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Max(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the maximum of this BigInteger and Value
            </summary>
            
            <param name="Value">Value to be used to compute the maximum with this</param>
            
            <returns>Max(this, Value)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Min(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns the minimum of this BigInteger and Value
            </summary>
            
            <param name="Value">Value to be used to compute the minimum with this</param>
            
            <returns><c>Min(this, Value)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Mod(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this Mod M</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            The behavior of this function is not equivalent to the behavior of the % operator defined for the built-in int's.</para>
            </summary>
            
            <param name="M">The modulus</param>
            
            <returns>Returns <c>this Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M == null or M &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ModPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this^Exponent Mod M</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            If the Exponent is negative, then <c>this.ModInverse(M)^(-Exponent) Mod M)</c> is computed.
            The inverse of this only exists if this is relatively prime to M, otherwise an exception is thrown.</para>
            </summary>
            
            <param name="Exponent">The exponent</param>
            <param name="M">The modulus</param>
            
            <returns><c>this^Exponent Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M &lt; 0 or if Exponent&lt;0 and this is not relatively prime to M</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ModInverse(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>1/this Mod M</c>. 
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, M exclusive).
            If this is not relatively prime to M, then an exception is thrown.</para>
            </summary>
            
            <param name="M">The modulus</param>
            
            <returns>Returns <c>1/this Mod M</c></returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if M &lt; 0 or, if this is not relatively prime to code M</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this * Value</c>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            <returns>Returns <c>this * Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Negate">
            <summary>
            Returns a new BigInteger whose value is the <c>-this</c>
            </summary>
            
            <returns><c>-this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.NextProbablePrime">
            <summary>
            Returns the smallest integer x &gt; this which is probably prime as a BigInteger instance.
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^80).</para>
            </summary>
            
            <returns>Smallest integer &gt; this which is robably prime</returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if this &lt; 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Not">
            <summary>
            Returns a new BigInteger whose value is <c>~this</c>.
            <para>The result of this operation is <c>-this-1</c>.</para>
            </summary>
            
            <returns>Returns <c>~this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Or(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this | Value</c>
            </summary>
            
            <param name="Value">Value to be Or'ed with this</param>
            
            <returns>Returns <c>this | Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Pow(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Exponent</c>
            </summary>
            
            <param name="Exponent">Exponent to which this is raised</param>
            
            <returns>Returns <c>this ^ Exponent</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ProbablePrime(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom)">
            <summary>
            Returns a random positive BigInteger instance in the range <c>[0, 2^(bitLength)-1]</c> which is probably prime.
            <para>The probability that the returned BigInteger is prime is beyond (1-1/2^80).</para>
            </summary>
            
            <param name="BitLength">Length of the new BigInteger in bits</param>
            <param name="Rnd">Random generator used to generate the new BigInteger</param>
            
            <returns>Returns probably prime random BigInteger instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this % Divisor</c>.
            <para>Regarding signs this methods has the same behavior as the % operator on int's, 
            i.e. the sign of the remainder is the same as the sign of this.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>Returns <c>this % Divisor</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.SetBit(System.Int32)">
            <summary>
            Returns a new BigInteger which has the same binary representation as this but with the bit at position N set.
            <para>The result is equivalent to <c>this | 2^n</c>.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be set</param>
            
            <returns>Returns <c>this | 2^n</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ShiftLeft(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>this &lt;&lt; N</c> if n >= 0, <c>this >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ShiftRight(System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>.
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.</para>
            </summary>
            
            <param name="N">The shift distance in bits</param>
            
            <returns>this >> N, if N >= 0; this &lt;&lt; (-n) otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Signum">
            <summary>
            Returns the sign of this BigInteger
            </summary>
            
            <returns>Returns -1 if this &lt; 0, 0 if this == 0, 1 if this > 0</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this - val</c>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            
            <returns><c>this - val</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.TestBit(System.Int32)">
            <summary>
            Tests whether the bit at position N in this is set.
            <para>The result is equivalent to <c>this &amp; (2^n) != 0</c>.</para>
            </summary>
            
            <param name="N">Position where the bit in this has to be inspected.</param>
            
            <returns>Returns this &amp; (2^n) != 0</returns>
            
            <remarks>
            Implementation Note: Usage of this method is not 
            recommended as the current implementation is not efficient.
            </remarks>
            
            <exception cref="T:System.ArithmeticException">Thrown if a negative bit address is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToByteArray">
            <summary>
            Returns the two's complement representation of this BigInteger in a byte array
            </summary>
            
            <returns>Two's complement representation of this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToDouble">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            <para>The double representation has a mantissa of length 53. For example, <c>2^53+1 = 9007199254740993</c> is returned as double <c>9007199254740992.0</c>.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToInt32">
            <summary>
            Returns this BigInteger as an int value. 
            <para>If this is too big to be represented as an int, then <c>this % 2^32</c> is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToInt64">
            <summary>
            Returns this BigInteger as an long value. 
            <para>If this is too big to be represented as an long, then <c>this % 2^64</c> is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToSingle">
            <summary>
            Returns this BigInteger as an float value.
            <para>If this is too big to be represented as an float, then Float.POSITIVE_INFINITY 
            or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>Returns this BigInteger as a float value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Float.MAX_VALUE, Float.MAX_VALUE] can be represented as a float. 
            The float representation has a mantissa of length 24.
            For example, 2^24+1 = 16777217 is returned as float 16777216.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToString(System.Int32)">
            <summary>
            Returns a string containing a string representation of this  BigInteger with base radix.
            <para>If Radix &lt; CharHelper.MIN_RADIX} or Radix > CharHelper.MAX_RADIX then a decimal representation is returned.
            The CharHelpers of the string representation are generated with method CharHelper.forDigit.</para>
            </summary>
            
            <param name="Radix">Base to be used for the string representation</param>
            
            <returns>Returns a string representation of this with radix 10</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ValueOf(System.Int64)">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value 
            </summary>
            
            <param name="Value">The value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Xor(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Value</c>
            </summary>
            
            <param name="Value">Value to be xor'ed with this</param>
            
            <returns>Returns <c>this ^ Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Parse(System.String)">
            <summary>
            Parse a BigInteger from a string
            </summary>
            
            <param name="S">The string containing the BigInteger</param>
            
            <returns>The BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.TryParse(System.String,VTDev.Libraries.CEXEngine.Numeric.BigInteger@)">
            <summary>
            Try to parse a BigInteger from a string
            </summary>
            
            <param name="S">The string containing the BigInteger</param>
            <param name="Value">[out] The BigInteger</param>
            
            <returns>Returns <c>true</c> if the operation succeeded</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.TryParse(System.String,System.Int32,VTDev.Libraries.CEXEngine.Numeric.BigInteger@)">
            <summary>
            Try to parse a BigInteger from a string
            </summary>
            
            <param name="S">The string containing the BigInteger</param>
            <param name="Radix">The radix value</param>
            <param name="Value">[out] The BigInteger</param>
            
            <returns>Returns <c>true</c> if the operation succeeded</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Parse(System.String,System.Int32)">
            <summary>
            Try to parse a BigInteger from a string
            </summary>
            
            <param name="S">The string containing the BigInteger</param>
            <param name="Radix">The radix value</param>
            
            <returns>The BigInteger</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Create a BigInteger from a stream
            </summary
            >
            <param name="Info">The serialization info</param>
            <param name="Context">The streaming context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Get streaming object info
            </summary>
            
            <param name="Info">The serialization info</param>
            <param name="Context">The streaming context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.Equals(System.Object)">
            <summary>
            Returns true if Obj is a BigInteger instance and if this instance is equal to this BigInteger
            </summary>
            
            <param name="Obj">Object to be compared with this</param>
            
            <returns>Returns true if Obj is a BigInteger and this == Obj,  false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.GetHashCode">
            <summary>
            Returns a hash code for this BigInteger
            </summary> 
            
            <returns>Returns hash code for this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.ToString">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Addition(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A + B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A + B</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Subtraction(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A - B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A - B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A * B</c>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The multiplicand value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Division(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A / B</c>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The divisor value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A / B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Modulus(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A Mod B</c>.
            <para>The modulus M must be positive.
            The result is guaranteed to be in the interval (0, M) (0 inclusive, m exclusive).
            The behavior of this function is not equivalent to the behavior of the % operator 
            defined for the built-in int's.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The modulus value B</param>
            
            <returns>Returns a new BigInteger whose value is <c>A Mod B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_BitwiseAnd(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Computes the bit per bit operator between this number and the given one
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value to be and'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A &amp; B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_BitwiseOr(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A | B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value to be Or'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A | B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_ExclusiveOr(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is <c>A ^ B</c>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">Value to be xor'ed with "A"</param>
            
            <returns>Returns a new BigInteger whose value is <c>A ^ B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_OnesComplement(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is ~X.
            <para>The result of this operation is <c>-X-1</c>.</para>
            </summary>
            
            <param name="X">Value to be unary reversed</param>
            
            <returns>Returns a new BigInteger whose value is <c>-X-1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_UnaryNegation(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns a new BigInteger whose value is the <c>-X</c>
            </summary>
            
            <param name="X">The value to be negated</param>
            
            <returns>Returns a new BigInteger whose value is <c>-X</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_RightShift(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this >> N</c>
            <para>For negative arguments, the result is also negative. 
            The shift distance may be negative which means that this is shifted left.</para>
            </summary>
            
            <param name="X">The value to be shifted</param>
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>X >> N</c>, if <c>N >= 0</c>; <c>X &lt;&lt; (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LeftShift(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is this &lt;&lt; N.
            <para>The result is equivalent to <c>this * 2^n</c> if n >= 0.
            The shift distance may be negative which means that this is shifted right.
            The result then corresponds to <c>Floor(this / 2^(-n))</c>.</para>
            </summary>
            
            <param name="X">The value to be shifted</param>
            <param name="N">The shift distance in bits</param>
            
            <returns>Returns <c>X &lt;&lt; N</c> if N >= 0, <c>X >> (-N)</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_GreaterThan(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is more than BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A > B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LessThan(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is less than BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A &lt; B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Equality(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if "A" is a BigInteger instance and if this instance is equal to the BigInteger "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if "B" is a BigInteger and <c>A == B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Inequality(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is not equal to BigInteger "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A != B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_GreaterThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is more than or equal to BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A >= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_LessThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Returns true if BigInteger value "A" is less than or equal to BigInteger value "B"
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns true if <c>A &lt;= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Int32">
            <summary>
            Returns this BigInteger as an int value. 
            <para>If this is too big to be represented as an int, then <c>this % 2^32</c> is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Int64">
            <summary>
            Returns this BigInteger as an long value. 
            <para>If this is too big to be represented as an long, then <c>this % 2^64</c> is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Single">
            <summary>
            Returns this BigInteger as an float value.
            <para>If this is too big to be represented as an float, then Float.POSITIVE_INFINITY 
            or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a float value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Float.MAX_VALUE, Float.MAX_VALUE] can be represented as a float. 
            The float representation has a mantissa of length 24.
            For example, 2^24+1 = 16777217 is returned as float 16777216.0.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.Double">
            <summary>
            Returns this BigInteger as an double value.
            <para>If this is too big to be represented as an double, then Double.POSITIVE_INFINITY or 
            Double.NEGATIVE_INFINITY} is returned.</para>
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns this BigInteger as a double value</returns>
            
            <remarks>
            Note, that not all integers x in the range [-Double.MAX_VALUE, Double.MAX_VALUE] can be represented as a double. 
            <para>The double representation has a mantissa of length 53. For example, <c>2^53+1 = 9007199254740993</c> is returned as double <c>9007199254740992.0</c>.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~System.String">
            <summary>
            Returns a string representation of this BigInteger in decimal form
            </summary>
            
            <param name="X">The BigInteger to convert</param>
            
            <returns>Returns a string representation of this in decimal form</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(System.Int32)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value
            </summary>
            
            <param name="Value">The int value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigInteger.op_Implicit(System.Int64)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns a new BigInteger instance whose value is equal to Value
            </summary>
            
            <param name="Value">The long value to be converted to a BigInteger</param>
            
            <returns>Returns a BigInteger instance with the value</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.BitCount">
            <summary>
            Returns the number of bits in the binary representation of this which differ from the sign bit. 
            <para>Use BitLength(0) if you want to know the length of the binary value in bits.
            If this is positive the result is equivalent to the number of bits set in the binary representation of this.
            If this is negative the result is equivalent to the number of bits set in the binary representation of -this - 1.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.BitLength">
            <summary>
            Returns the length of the value's two's complement representation without 
            leading zeros for positive numbers / without leading ones for negative values.
            <para>The two's complement representation of this will be at least BitLength() + 1 bits long.
            The value will fit into an int if <c>bitLength() &lt; 32</c> or into a long if <c>bitLength() &lt; 64</c>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigInteger.LowestSetBit">
            <summary>
            Returns the position of the lowest set bit in the two's complement representation of this BigInteger.
            <para>If all bits are zero (this=0) then -1 is returned as result.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest">
            <summary>
            <h3>Digest stream helper class.</h3>
            <para>Wraps Message Digest stream functions in an easy to use interface.</para>
            </summary> 
            
            <example>
            <description>Example of hashing a Stream:</description>
            <code>
            byte[] hash;
            using (IDigest digest = new SHA512())
            {
                using (StreamDigest dstrm = new StreamDigest(digest, [false]))
                {
                    // assign the input stream
                    dstrm.Initialize(InputStream, [true]);
                    // get the digest
                    hash = dstrm.ComputeHash([Length], [InOffset]);
                }
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digests</see> using either the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">interface, or a Digests enumeration member</see>.</description></item>
            <item><description>Digest can be Disposed when this class is <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.Dispose">Disposed</see>, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Input Stream can be Disposed when this class is Disposed, set the DisposeStream parameter in the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.Initialize(System.IO.Stream,System.Boolean)"/> call to true to dispose automatically.</description></item>
            <item><description>Implementation has a Progress counter that returns total sum of bytes processed per either <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.ComputeHash(System.Int64,System.Int64)">ComputeHash([InOffset], [OutOffset])</see> calls.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Boolean)">
            <summary>
            Initialize the class with a digest instance
            <para>Digest must be fully initialized before calling this method.</para>
            </summary>
            
            <param name="Digest">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest"/> instance</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.Dispose"/> on this class is called; default is false</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests,System.Boolean)">
            <summary>
            Initialize the class with a digest enumeration
            </summary>
            
            <param name="Digest">The digest enumeration member</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.Dispose"/> on this class is called; default is false</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.Initialize(System.IO.Stream,System.Boolean)">
            <summary>
            Initialize internal state
            </summary>
            
            <param name="InStream">The Source stream to be transformed</param>
            <param name="DisposeStream">Dispose of streams when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a null Input stream is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.ComputeHash">
            <summary>
            Process the entire length of the Input Stream
            </summary>
            
            <returns>The Message Digest</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if ComputeHash is called before Initialize(), or if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.ComputeHash(System.Int64,System.Int64)">
            <summary>
            Process a length within the Input stream using an Offset
            </summary>
            
            <returns>The Message Digest</returns>
            
            <param name="Length">The number of bytes to process</param>
            <param name="Offset">The Input Stream positional offset</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if ComputeHash is called before Initialize(), or if Size + Offset is longer than Input stream</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.IsConcurrent">
            <summary>
            Enable file reads and digest processing to run concurrently
            <para>The default is true, but will revert to false if the stream is not a FileStream, 
            or the file size is less that 65535 bytes in length.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamDigest.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.TBC">
            <summary>
            <h3>The Trailing Bit Compliment Padding Scheme.</h3>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.TBC.AddPadding(System.Byte[],System.Int32)">
            <summary>
            Add padding to input array
            </summary>
            
            <param name="Input">Array to modify</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.TBC.GetPaddingLength(System.Byte[])">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.TBC.GetPaddingLength(System.Byte[],System.Int32)">
            <summary>
            Get the length of padding in an array
            </summary>
            
            <param name="Input">Padded array of bytes</param>
            <param name="Offset">Offset into array</param>
            
            <returns>Length of padding</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Padding.TBC.Name">
            <summary>
            Get: Padding name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers">
            <summary>
            The McEliece CCA2 Secure ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers.Fujisaki">
            <summary>
            The Fujisaki/Okamoto conversion of the McEliece PKCS
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers.KobaraImai">
            <summary>
            The Kobara/Imai conversion of the McEliece PKCS
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers.Pointcheval">
            <summary>
            The Pointcheval conversion of the McEliece PKCS
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM">
            <summary>
            <h3>RSM: An implementation based on the Rijndael and Serpent Merged block ciphers, extended with an HKDF powered Key Schedule.</h3>
            <para>RSM is the Rijndael<cite>Rijndael</cite> and Serpent<cite>Serpent</cite> ciphers, merged within the rounds function.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new RSM()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/09/18" version="1.2.0.0">Initial release using a fixed Digest key schedule generator</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release using an assignable Digest in the HKDF engine</revision>
            <revision date="2015/03/15" version="1.3.2.0">Added the IkmSize optional parameter to the constructor, and the DistributionCode property</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Generator.HKDF">HKDF</see> Digest <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">engine</see> is definable through the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">Constructor</see> parameter: KeyEngine.</description></item>
            <item><description>Key Schedule is powered by a Hash based Key Derivation Function using a definable <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">Digest</see>.</description></item>
            <item><description>Minimum key size is (IKm + Salt) (N * Digest State Size) + (Digest Hash Size) in bytes.</description></item>
            <item><description>Valid block sizes are 16 and 32 byte wide.</description></item>
            <item><description>Valid Rounds assignments are 10, 18, 26, 34 and 42, default is 18.</description></item>
            </list>
            
            <para>The transform combines the two ciphers within the rounds function processing loop. 
            In the Transform functions rounds loop, a round of Serpent is processed; the permuted product of that transformation is then transformed again by a full round of Rijndael.
            This alternating of state transformations between two very strong cryptographic primitives, both creates a highly diffused output, and a cipher 
            that is very resistant to differential cryptanalysis.</para>
            
            <para>The key schedule in RSM powered by an HKDF<cite>RFC 5869</cite> generator, using a Digest HMAC<cite>RFC 2104</cite> (Hash based Message Authentication Code) as its random engine. 
            This is one of the strongest<cite>Fips 198-1</cite> methods available for generating pseudo-random keying material, and far superior in entropy dispersion to Rijndael, or even Serpents key schedule. 
            HKDF uses up to three inputs; a nonce value called an information string, an Ikm (Input keying material), and a Salt value. 
            The HMAC RFC 2104, recommends a key size equal to the digest output, in the case of SHA512, 64 bytes, anything larger gets passed through the hash function to get the required 512 bit key size. 
            The Salt size is a minimum of the hash functions block size, with SHA-2 512 that is 128 bytes.</para>
            
            <para>When using SHA-2 512, a minimum key size for RSM is 192 bytes, further blocks of salt can be added to the key so long as they align; ikm + (n * blocksize), ex. 192, 320, 448 bytes.. there is no upper maximum. 
            This means that you can create keys as large as you like so long as it falls on these boundaries, this effectively eliminates brute force as a means of attack on the cipher, even in quantum terms.</para> 
            
            <para>The Digest that powers HKDF, can be any one of the Hash Digests implemented in the CEX library; Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, SHA-2<cite>Fips 180-4</cite>, or Skein<cite>Skein</cite>.
            The default Digest Engine is SHA-2 512.</para>
            
            <para>The legal key sizes are determined by a combination of the (Hash Size + a Multiplier * the Digest State Size); <math>klen = h + (n * s)</math>, this will vary between Digest implementations. 
            Correct key sizes can be determined at runtime using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes"/> property.</para>
            
            <para>The number of diffusion rounds processed within the ciphers rounds function can also be defined; adding rounds creates a more diffused cipher output, making the resulting cipher-text more difficult to cryptanalyze. 
            RSM is capable of processing up to 42 rounds, that is three times the number of rounds used in an implementation of AES-256. 
            Valid rounds assignments can be found in the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds"/> static property.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf">AES Fips 197</see>.</description></item>
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            <item><description>HMAC: <see href="http://tools.ietf.org/html/rfc2104">RFC 2104</see>.</description></item>
            <item><description>Fips: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">198.1</see>.</description></item>
            <item><description>HKDF: <see href="http://tools.ietf.org/html/rfc5869">RFC 5869</see>.</description></item>
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">SP800-90B</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Mono: <see href="https://github.com/mono/mono/blob/effa4c07ba850bedbe1ff54b2a5df281c058ebcb/mcs/class/corlib/System.Security.Cryptography/RijndaelManagedTransform.cs">RijndaelManagedTransform</see> class, 
            and the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds"/> property contains available sizes. Default is 18 rounds.</param>
            <param name="Block">Cipher input <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/>. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalBlockSizes"/> property contains available sizes. Default is 16 bytes.</param>
            <param name="KeyEngine">The Key Schedule KDF digest engine; can be any one of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> implementations. The default engine is <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.SHA512"/>.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid block size or invalid rounds count are used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.ExpandKey(System.Byte[],System.Boolean)">
            <remarks>
            Expand the key and set state variables
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LinearTransform(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Apply the linear transformation to the register set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.InverseTransform(System.UInt32@,System.UInt32@,System.UInt32@,System.UInt32@)">
            <summary>
            Apply the inverse of the linear transformation to the register set
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.BlockSize">
            <summary>
            Get: Unit block size of internal cipher in bytes.
            <para>Block size must be 16 or 32 bytes wide. 
            Value set in class constructor.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.DistributionCode">
            <summary>
            Get/Set: Sets the Info value in the HKDF initialization parameters. 
            <para>Must be set before <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called.
            Changing this code will create a unique distribution of the cipher.
            Code can be either a zero byte array, or a multiple of the HKDF digest engines return size.</para>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid distribution code is used</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IkmSize">
            <summary>
            Get/Set: Specify the size of the HMAC key; extracted from the cipher key.
            <para>This property can only be changed before the Initialize function is called.</para>
            <para>Default is the digest return size; can only be a multiple of that length.
            Maximum size is the digests underlying block size; if the key
            is longer than this, the size will default to the block size.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalKeySizes">
            <summary>
            Get: Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.RSM.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey">
            <summary>
            A Rainbow Private Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.#ctor(System.Int16[][],System.Int16[],System.Int16[][],System.Int16[],System.Int32[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer[])">
            <summary>
            Initialize this class
            </summary>
            
            <param name="A1inv">The inverse of A1(the matrix part of the affine linear map L1) (n-v1 x n-v1 matrix)</param>
            <param name="B1">Translation vector, part of the linear affine map L1</param>
            <param name="A2inv">The inverse of A2(the matrix part of the affine linear map L2) (n x n matrix)</param>
            <param name="B2">Translation vector, part of the linear affine map L2</param>
            <param name="Vi">The number of Vinegar-variables per layer</param>
            <param name="Layers">The polynomials with their coefficients of private map F</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.#ctor(System.IO.Stream)">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.#ctor(System.Byte[])">
            <summary>
            Reconstructs a public key from its <c>byte</c> array representation.
            </summary>
            
            <param name="Key">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.From(System.Byte[])">
            <summary>
            Read a Private key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized RNBWPrivateKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.From(System.IO.Stream)">
            <summary>
            Read a Private key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized RNBWPrivateKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.ToBytes">
            <summary>
            Converts the Private key to an encoded byte array
            </summary>
            
            <returns>The encoded RNBWPrivateKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.ToStream">
            <summary>
            Converts the RNBWPrivateKey to an encoded MemoryStream
            </summary>
            
            <returns>The Private Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the RNBWPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded RNBWPrivateKey to an output byte array
            </summary>
            
            <param name="Output">The Private Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded RNBWPrivateKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Private Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.Clone">
            <summary>
            Create a shallow copy of this MPKCPublicKey instance
            </summary>
            
            <returns>MPKCPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.DeepCopy">
            <summary>
            Create a deep copy of this RNBWPrivateKey instance
            </summary>
            
            <returns>The RNBWPrivateKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.B1">
            <summary>
            Get: Returns the private key as a byte array
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.InvA1">
            <summary>
            Get: Returns the inverse matrix of A1
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.B2">
            <summary>
            Get: Returns the translation part of the private quadratic map L2
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.InvA2">
            <summary>
            Get: Returns the inverse matrix of A2
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.Layers">
            <summary>
            Get: Returns the layers contained in the private key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey.VI">
            <summary>
            Get: Returns the array of vi-s
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign">
             <summary>
             An Generalized Merkle Signature Scheme Asymmetric Signature Scheme implementation
             </summary>
             
             <example>
             <description>Example of using the signing and verifying an array:</description>
             <code>
             byte[] code;
             byte[] data = new byte[100];
             
             GMSSKeyGenerator kpm = (GMSSParameters)GMSSParamSets.GMSSN2P10.DeepCopy();
             GMSSKeyGenerator gen = new GMSSKeyGenerator(kpm);
             IAsymmetricKeyPair keyPair = gen.GenerateKeyPair();
            
             // get the message code for an array of bytes
             using (GMSSSign sign = new GMSSSign(kpm))
             {
                 sign.Initialize(kp.PrivateKey);
                 code = sign.Sign(data, 0, data.Length);
             }
            
             // test the message for validity
             using (GMSSSign sign = new GMSSSign(kpm))
             {
                 sign.Initialize(kp.PublicKey);
                 bool valid = sign.Verify(data, 0, data.Length, code);
             }
             </code>
             </example>
             
             <revisionHistory>
             <revision date="2015/07/06" version="1.4.0.0">Initial release</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSSign Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSPublicKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSPrivateKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Prngs Enumeration</seealso>
             
             <remarks>
             <description><h4>Guiding Publications:</h4></description>
             <list type="number">
             <item><description>Selecting Parameters for the Generalized Merkle Signature Scheme Signature Scheme<cite>Generalized Merkle Signature Scheme Parameters</cite>.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The GMSS cipher used to encrypt the hash</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the Key for Sign (Private) or Verify (Public)
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the Generalized Merkle Signature Scheme Public (verify) or Private (sign) key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Reset">
            <summary>
            Reset the underlying digest engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Sign(System.IO.Stream)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="InputStream">The stream containing the data</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if an invalid key is used, or signer has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Sign(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="Input">The byte array contining the data</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if input array is too short, signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Verify(System.IO.Stream,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="InputStream">The stream containing the data to test</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Verify(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="Input">The stream containing the data to test</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if input array is too short, signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.InitSign">
            <summary>
            Initializes the signature algorithm for signing a message
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.GenerateSignature(System.Byte[])">
            <summary>
            This function signs the message that has been updated, making use of the private key.
            <para>For computing the signature, L1 and L2 are needed, as well as LES should be solved 
            for each layer in order to find the Oil-variables in the layer.
            The Vinegar-variables of the first layer are random generated.</para>
            </summary>
            
            <param name="Message">The message</param>
            
            <returns>The signature of the message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.VerifySignature(System.Byte[],System.Byte[])">
            <summary>
            This function verifies the signature of the message that has been updated, with the aid of the public key
            </summary>
            
            <param name="Message">The message</param>
            <param name="Signature">The signature of the message</param>
            
            <returns>Returns true if the signature has been verified, false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.IsSigner">
            <summary>
            Get: This class is initialized for Signing with the Private key
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign.Name">
            <summary>
            Get: The Signer name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf">
            <summary>
            This class implements the distributed computation of the public key of the
            Winternitz one-time signature scheme (OTSS). The class is used by the GMSS
            classes for calculation of upcoming leafs.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[][],System.Int32[])">
            <summary>
            This constructor regenerates a prior GMSSLeaf object
            </summary>
            
            <param name="Digest">The hash function</param>
            <param name="OtsIndex">The status bytes</param>
            <param name="NumLeafs">The status ints</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Int32)">
            <summary>
            The constructor precomputes some needed variables for distributed leaf calculation
            </summary>
            
            <param name="Digest">The hash function</param>
            <param name="W">The winterniz parameter of that tree the leaf is computed for</param>
            <param name="NumLeafs">The number of leafs of the tree from where the distributed computation is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Int32,System.Byte[])">
            <summary>
            The constructor precomputes some needed variables for distributed leaf calculation
            </summary>
            
            <param name="Digest">The hash function</param>
            <param name="W">The winterniz parameter of that tree the leaf is computed for</param>
            <param name="NumLeafs">The number of leafs of the tree from where the distributed computation is called</param>
            <param name="Seed">The hash seed value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.GetLeaf">
            <summary>
            Returns the leaf value
            </summary>
            
            <returns>The leaf value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.GetStatByte">
            <summary>
            Returns the status byte array used by the GMSSPrivateKeyASN.1 class
            </summary>
            
            <returns>The status bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.GetStatInt">
            <summary>
            Returns the status int array used by the GMSSPrivateKeyASN.1 class
            </summary>
            
            <returns>The status ints</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.InitLeafCalc(System.Byte[])">
            <summary>
            Initialize the distributed leaf calculation reset i,j and compute OTSseed with seed0
            </summary>
            
            <param name="Seed">The starting seed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.UpdateLeafCalc">
            <summary>
            Processes <c>steps</c> steps of distributed leaf calculation
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.GetLog(System.Int32)">
            <summary>
            This method returns the least integer that is greater or equal to the logarithm to the base 2 of an integer <c>intValue</c>
            </summary>
            
            <param name="Value">An integer</param>
            
            <returns>The least integer greater or equal to the logarithm to the base 2 of <c>Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSLeaf.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2">
            <summary>
            A polynomial class that combines two coefficients into one <c>long</c> value for
            faster multiplication in 64 bit environments.
            <para>Coefficients can be between 0 and 2047 and are stored in pairs in the bits 0..10 and 24..34 of a <c>long</c> number.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Coeffs">
            <summary>
            Each representing two coefficients in the original IntegerPolynomial
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Constructs a <c>LongPolynomial2</c> from a <c>IntegerPolynomial</c>. The two polynomials are independent of each other.
            </summary>
            <param name="P">The original polynomial. Coefficients must be between 0 and 2047.</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Clear">
            <summary>
            Clear the Coefficients
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Clone">
            <summary>
            Makes a copy of the polynomial that is independent of the original.
            </summary>
            <returns>The cloned polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2)">
            <summary>
            Multiplies the polynomial with another, taking the indices mod N and the values mod 2048.
            </summary>
            
            <param name="Factor">The polynomial factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Mult2And(System.Int32)">
            <summary>
            Multiplies this polynomial by 2 and applies an AND mask to the upper and 
            lower halves of each coefficients.
            </summary>
            
            <param name="Mask">A bit mask less than 2048 to apply to each 11-bit coefficient</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.SubAnd(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2,System.Int32)">
            <summary>
            Subtracts another polynomial which must have the same number of coefficients,
            and applies an AND mask to the upper and lower halves of each coefficients.
            </summary>
            
            <param name="B">Another polynomial</param>
            <param name="Mask">A bit mask less than 2048 to apply to each 11-bit coefficient</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.Equals(System.Object)">
            <summary>
            Compare this big integer polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.LongPolynomial2.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher">
            <summary>
            This class implements the Pointcheval conversion of the McEliecePKCS.
            <para>Pointcheval presents a generic technique to make a CCA2-secure cryptosystem 
            from any partially trapdoor one-way function in the random oracle model.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.OID">
            <summary>
            The OID of the algorithm
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Parameters">The cipher parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.GetKeySize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Return the key size of the working key
            </summary>
            
            <returns>The size of the key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey"/> for encryption, or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey"/> for decryption</para>
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the McEliece public or private key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.PointchevalCipher.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can decrypt
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTrustStates">
            <summary>
            For future use in an Auth-Stage encryption scheme
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTrustStates.None">
            <summary>
            No trust relationship exists
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTrustStates.Partial">
            <summary>
            A partial trust has been established
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTrustStates.Full">
            <summary>
            Full trust has been established
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.Throttle(System.IO.MemoryStream)">
            <summary>
            Sends a packet with increasing wait times. 
            <para>After 4 attempts fires a SessionError.</para>
            </summary>
            
            <param name="PacketStream">The packet to send</param>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.DataReceived">
            <summary>
            The Data Received event; fires each time data has been received through the post-exchange encrypted channel
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.FileTransferred">
            <summary>
            The File Transferred event; fires when the file transfer operation has completed
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.PacketReceived">
            <summary>
            The Packet Received event; fires each time a valid packet has been received
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.PacketSent">
            <summary>
            The Packet Sent event; fires each time a valid packet has been sent
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.SessionError">
            <summary>
            The Session Error event; fires when an error has occured
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.DataReceivedDelegate">
            <summary>
            The Packet Received delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmDataReceivedEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.FileTransferredDelegate">
            <summary>
            The File Transferred delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmFileRequestEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.PacketReceivedDelegate">
            <summary>
            The Packet Received delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.PacketSentDelegate">
            <summary>
            The Packet Sent delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Support.DtmFileTransfer.SessionErrorDelegate">
            <summary>
            The Session Error delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags">
            <summary>
            The flag indicating the type of service request
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.InternalError">
            <summary>
            The host had an unexpected error
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.ConnectionRefused">
            <summary>
            The client refused the connection
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.ConnectionDropped">
            <summary>
            Connection was dropped
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.ConnectionTimedOut">
            <summary>
            The connection timed out
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.UnrecoverableDataLoss">
            <summary>
            Session encountered unrecoverable data loss
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.MaxResendExceeded">
            <summary>
            The maximum number of retransmission attempts for the session was exceeded
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.NetworkError">
            <summary>
            Unspecified network error
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.SendTimeoutExceeded">
            <summary>
            Transmission could not be sent in a timely manner
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorFlags.ReceivedBadData">
            <summary>
            The session received bad data and can not recover
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoFileTransferException">
            <summary>
            Wraps exceptions thrown within an encrypted file transfer operation.
            <para>This exception is used in the DtmKex class.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoFileTransferException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoFileTransferException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoFileTransferException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoFileTransferException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoFileTransferException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.CharUtils">
            <summary>
            This class is a utility class for manipulating char arrays
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.CharUtils.MIN_RADIX">
            <summary>
            Min radix
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Utility.CharUtils.MAX_RADIX">
            <summary>
            Max radix
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.CharAt(System.String,System.Int32)">
            <summary>
            Get the char value at a specified index within a string
            </summary>
            
            <param name="Value">String to parse</param>
            <param name="Index">Index of value</param>
            
            <returns>Char value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.Clone(System.Char[])">
            <summary>
            Return a clone of the given char array. No null checks are performed.
            </summary>
            
            <param name="A">The array to clone</param>
            
            <returns>The clone of the given array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.Equals(System.Char[],System.Char[])">
            <summary>
            Compare two char arrays. No null checks are performed.
            </summary>
            
            <param name="A">The char byte array</param>
            <param name="B">The second char array</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ForDigit(System.Int32,System.Int32)">
            <summary>
            Get the char representation of an iteger
            </summary>
            
            <param name="Digit">The digit to convert</param>
            <param name="Radix">The radix</param>
            
            <returns>New char value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToByteArray(System.Char[])">
            <summary>
            Convert the given char array into a byte array.
            </summary>
            
            <param name="A">The char array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToByteArrayForPBE(System.Char[])">
            <summary>
            Convert the given char array into a byte array for use with PBE encryption
            </summary>
            
            <param name="A">The char array</param>
            
            <returns>The converted array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.Char)">
            <summary>
            Convert a char to an integer
            </summary>
            
            <param name="Value">Char to convert</param>
            
            <returns>Integer representation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.Char,System.Int32)">
            <summary>
            Convert a char to an integer
            </summary>
            
            <param name="Value">Char to convert</param>
            <param name="Radix">The radix</param>
            
            <returns>New integer value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.CharUtils.ToDigit(System.String)">
            <summary>
            Convert a string to an integer
            </summary>
            
            <param name="Value">String to convert</param>
            
            <returns>Integer representation</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.RoundingModes">
            <summary>
            MathContext RoundingModes used by BigInteger and BigDecimal
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Up">
            <summary>
            Rounding mode where positive values are rounded towards positive infinity
            and negative values towards negative infinity.
            <para>Rule: <c>x.Round().Abs() >= x.Abs()</c></para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Down">
            <summary>
            Rounding mode where the values are rounded towards zero.
            <para>Rule: x.Round().Abs() &lt;= x.Abs()</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Ceiling">
            <summary>
            Rounding mode to round towards positive infinity.
            <para>For positive values this rounding mode behaves as Up, for negative values as Down.
            Rule: x.Round() >= x</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Floor">
            <summary>
            Rounding mode to round towards negative infinity.
            <para>For positive values this rounding mode behaves as Down, for negative values as Up.
            Rule: x.Round() &lt;= x</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfUp">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding up.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfDown">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding down.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.HalfEven">
            <summary>
            Rounding mode where values are rounded towards the nearest neighbor.
            <para>Ties are broken by rounding to the even neighbor.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.RoundingModes.Unnecessary">
            <summary>
            Rounding mode where the rounding operations throws an ArithmeticException for 
            the case that rounding is necessary, i.e. for the case that the value cannot be represented exactly.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.Multiplication">
            <summary>
            Static library that provides all multiplication of BigInteger methods
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.Multiplication.bigTenPows">
            <summary>
            An array with the first powers of ten in BigInteger version: 10^0,10^1,...,10^31)
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.Multiplication.bigFivePows">
            <summary>
            An array with the first powers of five in {@code BigInteger} version: (5^0,5^1,...,5^31)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Performs a multiplication of two BigInteger and hides the algorithm used
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Y">A positive exponent</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyArraysPAP(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32[])">
            <summary>
            Multiply a member of array X with array Y
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="XLength">Length of X array to process</param>
            <param name="Y">A positive exponent</param>
            <param name="YLength">Length of Y array to process</param>
            <param name="ResDigits">The result</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByInt(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Multiplies an array of integers by an integer value
            </summary>
            
            <param name="X">The array of integers</param>
            <param name="Size">The number of elements of intArray to be multiplied</param>
            <param name="Factor">The multiplier</param>
            
            <returns>The top digit of production</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByFivePow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Multiplies a number by a power of five.
            <para>This method is used in BigDecimal class.</para>
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Exponent">A positive int exponent</param>
            
            <returns>X * 5 pow Exponent</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByPositiveInt(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Multiplies a number by a positive integer.
            </summary>
            
            <param name="X">An arbitrary BigInteger</param>
            <param name="Factor">A positive int number</param>
            
            <returns>X * Factor</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.MultiplyByTenPow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int64)">
            <summary>
            Multiplies a number by a power of ten.
            <para>This method is used in BigDecimal class.</para>
            </summary>
            
            <param name="X">The number to be multiplied</param>
            <param name="Exponent">A positive long exponent</param>
            
            <returns>X * 10 pow Exponent</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.Pow(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Returns a new BigInteger whose value is <c>this ^ Exponent</c>
            </summary>
            
            <param name="X">The BigInteger</param>
            <param name="Exponent">Exponent to which this is raised</param>
            
            <returns>Returns <c>this ^ Exponent</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.PowerOf10(System.Int64)">
            <summary>
            It calculates a power of ten, which exponent could be out of 32-bit range.
            <para>Note that internally this method will be used in the worst case with
            an exponent equals to: Integer.Max - Integer.Min.</para>
            </summary>
            
            <param name="Exponent">The exponent of power of ten, it must be positive</param>
            
            <returns>BigInteger with value 10<sup>exp</sup>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.Multiplication.UnsignedMultAddAdd(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the value unsigned ((uint)a*(uint)b + (uint)c + (uint)d).
            <para>This method could improve the readability and performance of the code.</para>
            </summary>
            
            <param name="A">Operand 1</param>
            <param name="B">Operand 2</param>
            <param name="C">Operand 3</param>
            <param name="D">Operand 4</param>
            <returns></returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory">
             <summary>
             <h3>A helper class used to create or extract a Key Package file.</h3>
             <para>This class works in conjunction with the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/> structure to create and manage key package files; encryption key bundles, that contain cipher Key and IV material, 
             and optionally an HMAC key used for message authentication.</para>
             </summary>
             
             <example>
             <description>Example using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)"/> method:</description>
             <code>
             // populate a KeyAuthority structure
             KeyAuthority authority =  new KeyAuthority(domainId, originId, packageId, packageTag, keyPolicy);
             // create a key file
             new PackageFactory(KeyPath, authority).Create(PackageKey);
             </code>
             
             <description>Example using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Extract(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription@,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams@,System.Byte[]@)"/> method to get an existing key for decryption:</description>
             <code>
             // populate a KeyAuthority structure
             KeyAuthority authority =  new KeyAuthority(domainId, originId, packageId, packageTag, keyPolicy);
             KeyParams keyparam;
             CipherDescription description;
             byte[] extKey;
             byte[] keyId;
             
             // extract a key for decryption
             using (PackageFactory factory = new PackageFactory(KeyPath, authority))
                 factory.Extract(keyId, out description, out keyparam, out extKey);
             </code>
             
             <description>Example using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.NextKey(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription@,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams@,System.Byte[]@)"/> method to get an unused key for encryption:</description>
             <code>
             // populate a KeyAuthority structure
             KeyAuthority authority =  new KeyAuthority(domainId, originId, packageId, packageTag, keyPolicy);
             KeyParams keyparam;
             CipherDescription description;
             byte[] extKey;
            
             // get the next available encryption subkey
             using (PackageFactory factory = new PackageFactory(KeyPath, authority))
                 keyId = factory.NextKey(out description, out keyparam, out extKey)
             </code>
             </example>
             
             <revisionHistory>
             <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
             <revision date="2015/02/23" version="1.3.2.0">Reconstructed and expanded to process CipherDescription, KeyAuthority, and PackageKey structures</revision>
             <revision date="2015/05/18" version="1.3.5.0">Renamed to PackageFactory</revision>
             <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures PackageKey Structure</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures KeyAuthority structure</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription Structure</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">VTDev.Libraries.CEXEngine.Crypto.Enumeration KeyPolicies Enumeration</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates">VTDev.Libraries.CEXEngine.Crypto KeyStates Enumeration</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator">VTDev.Libraries.CEXEngine.Crypto.KeyGenerator class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams">VTDev.Libraries.CEXEngine.Crypto.Processing.Structure KeyParams class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.StreamCipher">VTDev.Libraries.CEXEngine.Crypto.Processing StreamCipher class</seealso>
             
             <remarks>
             <description><h4>Implementation Notes:</h4></description>
             <para>A PackageKey file contains a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority"/> structure that defines its identity and security settings, 
             a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> that contains the settings required to create a specific cipher instance, and the 'subkey set', an array of unique subkey id strings and 
             policy flags that identify and control each subkey.</para>
             <para>A PackageKey file can contain one subkey, or many thousands of subkeys. Each subkey provides a unique keying material, and can only be used once for encryption; 
             guaranteeing a unique Key, IV, and HMAC key is used for every single encryption cycle.</para>
             <para>Each subkey in the Key Package contains a unique policy flag, which can be used to mark a key as locked(decryption) or expired(encryption), or trigger an erasure 
             of a specific subkey after the key is read for decryption using the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Extract(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription@,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams@,System.Byte[]@)"/> function.</para>
             
             <list type="bullet">
             <item><description>Constructors may use a fully qualified path to a key file and the local <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority"/>.</description></item>
             <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)"/> method auto-generates the keying material.</description></item>
             <item><description>The Extract() method retrieves a populated cipher description (CipherDescription), key material (KeyParams), and the file extension key from the key file.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.#ctor(System.String,VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.KeyAuthority)">
            <summary>
            Initialize this class with a key file path. 
            <para>If the key exixts, permissions are tested, otherwise this path is used as the new key path and file name.</para>
            </summary>
            
            <param name="KeyPath">The fully qualified path to the key file to be read or created</param>
            <param name="Authority">The local KeyAuthority credentials structure</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if an empty KeyPath is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Finalize">
            <summary>
            Finalizer: ensure resources are destroyed
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Authenticate">
            <summary>
            Authentication tests; specific target domain or identity, passphrase, 
            and export permissions within the PackageKey key policy settings are checked
            </summary>
            
            <returns>Authorized to use this key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.ContainsSubKey(System.Byte[])">
            <summary>
            Test a key to see if it contains a subkey with a specific id
            </summary>
            
            <param name="KeyId">The subkey id to test</param>
            
            <returns>The index of the subkey, or -1 if key is not in the PackageKey</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the user has insufficient access rights to access this PackageKey</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Create(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Create a key file using a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/> structure; containing the cipher description and operating ids and flags.
            </summary>
            
            <param name="Package">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey">Key Header</see> containing the cipher description and operating ids and flags</param>
            <param name="SeedEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">Random Generator</see> used to create the stage I seed material during key generation.</param>
            <param name="DigestEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest Engine</see> used in the stage II phase of key generation.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a key file exists at the path specified, the path is read only, the CipherDescription or KeyAuthority structures are invalid, or
            number of SubKeys specified is either less than 1 or more than the maximum allowed (100,000)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Extract(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription@,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams@,System.Byte[]@)">
            <summary>
            Extract a subkey set (KeyParam), a file extension key, and a CipherDescription. 
            <para>Used only when calling a Decryption function to get a specific subkey 
            The KeyId field corresponds with the KeyId field contained in a MessageHeader structure.</para>
            </summary>
            
            <param name="KeyId">The KeyId array used to identify a subkey set; set as the KeyId in a MessageHeader structure</param>
            <param name="Description">out: The CipherDescription structure; the properties required to create a specific cipher instance</param>
            <param name="KeyParam">out: The KeyParams class containing a unique key, initialization vector and HMAC key</param>
            <param name="ExtensionKey">out: The random key used to encrypt the message file extension</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the user has insufficient access rights to access this PackageKey, or the PackageKey does not contain the KeyId specified</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.HasExpired">
            <summary>
            Test the PackageKey for remaining valid subkeys
            </summary>
            
            <returns>PackageKey contains subkeys that are valid for encryption</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the user has insufficient access rights to access this PackageKey</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.HasExpired(System.Byte[])">
            <summary>
            Test a PackageKey subkey for expired status
            </summary>
            
            <param name="KeyId">The subkey id to test</param>
            
            <returns>Returns true if subkey has expired and can not be used for encryption, false if a valid key</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the user has insufficient access rights to access this PackageKey</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.KeyInfo">
            <summary>
            Get information about the key file in the form of an <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo"/> structure
            </summary>
            
            <returns>A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo"/> structure</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the user has insufficient access rights to access this PackageKey</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.NextKey(VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription@,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams@,System.Byte[]@)">
            <summary>
            Extract the next valid subkey set (Expired flag not set) as a KeyParam, and a CipherDescription structure. 
            <para>Used only when calling a Encryption function.</para>
            </summary>
            
            <param name="Description">out: The CipherDescription structure; the properties required to create a specific cipher instance</param>
            <param name="KeyParam">out: The KeyParams class containing a unique key, initialization vector and HMAC key</param>
            <param name="ExtensionKey">out: The random key used to encrypt the message file extension</param>
            
            <returns>The KeyId array used to identify a subkey set; set as the KeyId in a MessageHeader structure</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the user has insufficient access rights to perform encryption with this key.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Policy(System.Byte[])">
            <summary>
            Get the policy flags for a subkey
            </summary>
            
            <param name="KeyId">Id of the subkey to query</param>
            
            <returns>Sub key policy flag, or -1 if not key id found</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the user has insufficient access rights to access this PackageKey</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Erase(System.Int64,System.Int64)">
            <remarks>
            4 stage overwrite: random, reverse random, ones, zeros. 
            Last overwrite stage is zeros in Extract() method.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.GetPackage">
            <remarks>
            Returns the PackageKey structure
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.GetKeySet(System.IO.MemoryStream,VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription,System.Int64)">
            <remarks>
            Returns the populated KeyParams class
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.GetKeyStream">
            <remarks>
            Get the working copy of the key package as a stream
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.GetSalt">
            <remarks>
            Get the salt value used to encrypt the key.
            Salt is derived from authentication fields in the package header.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Overwrite(System.Byte[],System.Int64,System.Int64)">
            <remarks>
            Overwrite a section of the key file, used by the PostOverwrite policy
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.TransformBuffer(System.Byte[],System.Byte[])">
            <remarks>
            Encrypts the key package buffer
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.WriteKeyStream(System.IO.MemoryStream)">
            <remarks>
            Writes a memorystream to the key package file
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.AccessScope">
            <summary>
            The access rights available to the current user of this <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.IsCreator">
            <summary>
            Are we the Creator of this PackageKey
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.KeyPolicy">
            <summary>
            The PackageKey <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">policy flags</see>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory.LastError">
            <summary>
            The last error string
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash">
            <summary>
            This class implements a treehash instance for the Merkle tree traversal algorithm.
            The first node of the stack is stored in this instance itself,
            additional tail nodes are stored on a tailstack.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[][],System.Int32[])">
            <summary>
            This constructor regenerates a prior treehash object
            </summary>
            
            <param name="Digest">The initialized hash function</param>
            <param name="StatByte">The status bytes</param>
            <param name="StatInt">The status ints</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.IO.Stream)">
            <summary>
            This constructor regenerates a prior treehash object from an encoded stream
            </summary>
            
            <param name="Digest">The initialized hash function</param>
            <param name="TreeStream">The stream containing the encoded TreeHash</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[])">
            <summary>
            Reconstructs a Treehash from its <c>byte</c> array representation.
            </summary>
            
            <param name="Digest">The hash digest</param>
            <param name="TreeArray">The encoded tree hash</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.#ctor(System.Collections.Generic.List{System.Byte[]},System.Int32,VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="TailStack">The vector element where the stack nodes are stored</param>
            <param name="MaxHeight">The maximal height of the treehash instance</param>
            <param name="Digest">The initialized hash function</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.Destroy">
            <summary>
            Destroys a treehash instance after the top node was taken for authentication path
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.InitializeSeed(System.Byte[])">
            <summary>
            Method to initialize the seeds needed for the precomputation of right nodes.
            Should be initialized with index 3*2^i for treehash_i
            </summary>
            
            <param name="Seed">The seed value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.Initialize">
            <summary>
            Initializes the treehash instance. The seeds must already have been initialized to work correctly.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.GetFirstNode">
            <summary>
            Returns the first node stored in treehash instance itself
            </summary>
            
            <returns>Return the first node stored in treehash instance itself</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.GetFirstNodeHeight">
            <summary>
            Returns the top node height
            </summary>
            
            <returns>Height of the first node, the top node</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.GetLowestNodeHeight">
            <summary>
            Returns the height of the lowest node stored either in treehash or on the stack. 
            It must not be set to infinity (as mentioned in the paper) because this cases are 
            considered in the computeAuthPaths method of JDKGMSSPrivateKey
            </summary>
            
            <returns>Height of the lowest node</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.GetSeedActive">
            <summary>
            Returns the active seed
            </summary>
            
            <returns>Return the active seed</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.GetStatByte">
            <summary>
            Returns the status byte array used by the GMSSPrivateKeyASN.1 class
            </summary>
            
            <returns>The status bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.GetStatInt">
            <summary>
            Returns the status int array used by the GMSSPrivateKeyASN.1 class
            </summary>
            
            <returns>The status ints</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.GetTailStack">
            <summary>
            Returns the tailstack
            </summary>
            
            <returns>Return the tailstack</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.IsFinished">
            <summary>
            Method to check whether the instance has been finished or not
            </summary>
            
            <returns>Return true if treehash has reached its maximum height</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.IsInitialized">
            <summary>
            Method to check whether the instance has been initialized or not
            </summary>
            
            <returns>Return true if treehash was already initialized</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.SetFirstNode(System.Byte[])">
            <summary>
            This method sets the first node stored in the treehash instance itself
            </summary>
            
            <param name="Hash">The hash value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.ToBytes">
            <summary>
            Converts the Treehash to an encoded byte array
            </summary>
            
            <returns>The encoded Treehash</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.ToStream">
            <summary>
            Converts the Treehash to an encoded MemoryStream
            </summary>
            
            <returns>The Treehash encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.Update(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSRandom,System.Byte[])">
            <summary>
            Calculates one update of the treehash instance, i.e. creates a new leaf and hashes if possible
            </summary>
            
            <param name="GmssRand">An instance of the PRNG</param>
            <param name="Leaf">The byte value of the leaf needed for the update</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.UpdateNextSeed(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Utility.GMSSRandom)">
            <summary>
            Updates the nextSeed of this treehash instance one step needed for the schedulng of the seeds
            </summary>
            
            <param name="GmssRand">The prng used for the seeds</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.Treehash.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair">
            <summary>
            An McEliece Key-Pair container
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="PublicKey">The public key</param>
            <param name="PrivateKey">The corresponding private key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Key">The public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.#ctor(System.IO.MemoryStream)">
            <summary>
            Reads a key pair from an input stream.
            <para>Note: both keys must be present in the stream; ordered Public, Private.</para>
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key pair</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.#ctor(System.Byte[])">
            <summary>
            Reads a key pair  from a byte array.
            <para>Note: both keys must be present in the stream; ordered Public, Private.</para>
            </summary>
            
            <param name="KeyArray">An byte array containing an encoded key pair</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.Clone">
            <summary>
            Create a copy of this key pair instance
            </summary>
            
            <returns>The IAsymmetricKeyPair copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.Name">
            <summary>
            Get: KeyPair name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.PublicKey">
            <summary>
            Get: Returns the public key parameters
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyPair.PrivateKey">
            <summary>
            Get: Returns the private key parameters
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator">
            <summary>
            This class implements the key pair generation of the McEliece Public Key Crypto System (McEliece PKCS) using CCA2 Secure variants
            </summary>
            
            <example>
            <description>Example of creating a keypair:</description>
            <code>
            MPKCParameters encParams = MPKCParamSets.MPKCFM11T40S256;
            MPKCKeyGenerator keyGen = new MPKCKeyGenerator(encParams);
            IAsymmetricKeyPair keyPair = keyGen.GenerateKeyPair();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines">VTDev.Libraries.CEXEngine.Crypto AsymmetricEngines Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece MPKCPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece MPKCPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <description>The algorithm is given the parameters m and t or the key size n as input. Then, the following matrices are generated:</description> 
            <list type="table">
            <item><description>The public key is <c>(n, t, G)</c>. The private key is <c>(m, k, field polynomial, Goppa polynomial, H, S, P, setJ)</c>.</description></item>
            <item><description><c>G</c> is a k x n generator matrix of a binary irreducible (n,k) Goppa code GC which can correct up to t errors where n = 2^m and k is chosen maximal, i.e. k &lt;= n - mt.</description></item>
            <item><description><c>H</c> is an mt x n check matrix of the Goppa code GC.</description></item>
            <item><description><c>S</c> is a k x k random binary non-singular matrix.</description></item>
            <item><description><c>P</c> is an n x n random permutation matrix.</description></item>
            <item><description>Then, the algorithm computes the k x n matrix <c>G = SG'P.</c>.</description></item>
            </list> 
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>McEliece Handbook of Applied Cryptography: Chapter 8<cite>McEliece Handbook of Applied Cryptography</cite>.</description></item>
            <item><description>Selecting Parameters for Secure McEliece-based Cryptosystems<cite>McEliece Parameters</cite>.</description></item>
            <item><description>Weak keys in the McEliece public-key cryptosystem<cite>McEliece Weak keys</cite>.</description></item>
            <item><description>McBits: fast constant-time code-based cryptography<cite>McEliece McBits</cite>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters,System.Boolean)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The MPKCParameters instance containing thecipher settings</param>
            <param name="Parallel">Use parallel processing when generating a key; set to false if using a passphrase type generator (default is true)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if a Prng that requires pre-initialization is specified; (wrong constructor)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,System.Boolean)">
            <summary>
            Use an initialized prng to generate the key; use this constructor with an Rng that requires pre-initialization, i.e. PBPrng
            </summary>
            
            <param name="CipherParams">The RLWEParameters instance containing the cipher settings</param>
            <param name="RngEngine">An initialized Prng instance</param>
            <param name="Parallel">Use parallel processing when generating a key; set to false if using a passphrase type generator (default is true)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.GenerateKeyPair">
            <summary>
            Generate an encryption Key pair
            </summary>
            
            <returns>A McElieceKeyPair containing public and private keys</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.GenerateKeyPair(System.Byte[],System.Byte[])">
            <summary>
            Generates an encryption key pair using a passphrase based prng.
            <para>Invoking this method with the same passphrase and salt will always return the same key pair.</para>
            </summary>
            
            <param name="Passphrase">The passphrase</param>
            <param name="Salt">Salt for the passphrase; can be <c>null</c> but this is strongly discouraged</param>
            
            <returns>A populated IAsymmetricKeyPair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the prng type is unknown or unsupported</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCKeyGenerator.Name">
            <summary>
            Get: Generator name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector">
            <summary>
            This class implements the abstract class <c>Vector</c> for the case of vectors over the finite field GF(2). 
            <para>For the vector representation the array of type int[] is used, thus one element of the array holds 32 elements of the vector.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.#ctor(System.Int32)">
            <summary>
            Construct the zero vector of the given length
            </summary>
            
            <param name="Length">The length of the vector</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Construct a random GF2Vector of the given length
            </summary>
            
            <param name="Length">The length of the vector</param>
            <param name="SecRnd">The source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Construct a random GF2Vector of the given length with the specified number of non-zero coefficients
            </summary>
            
            <param name="Length">The length of the vector</param>
            <param name="T">The number of non-zero coefficients</param>
            <param name="SecRnd">The source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.#ctor(System.Int32,System.Int32[])">
            <summary>
            Construct a GF2Vector of the given length and with elements from the given array.
            <para>The array is copied and unused bits are masked out.</para>
            </summary>
            
            <param name="Length">The length of the vector</param>
            <param name="V">The element array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector)">
            <summary>
            Copy constructor
            </summary>
            
            <param name="G">The GF2Vector to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.#ctor(System.Int32[],System.Int32)">
            <summary>
            Construct a new GF2Vector of the given length and with the given element array. 
            <para>The array is not changed and only a reference to the array is stored. No length checking is performed either.</para>
            </summary>
            
            <param name="V">The element array</param>
            <param name="Length">The length of the vector</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.ExtractVector(System.Int32[])">
            <summary>
            Return a new vector consisting of the elements of this vector with the indices given by the set <c>SetJ</c>
            </summary>
            
            <param name="SetJ">The set of indices of elements to extract</param>
            
            <returns>Return the new GF2Vector <c>[SetJ[0], SetJ[1], ..., SetJ[#SetJ-1]]</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.ExtractLeftVector(System.Int32)">
            <summary>
            Return a new vector consisting of the first <c>K</c> elements of this vector
            </summary>
            
            <param name="K">The number of elements to extract</param>
            
            <returns>Returns a new GF2Vector consisting of the first <c>K</c> elements of this vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.ExtractRightVector(System.Int32)">
            <summary>
            Return a new vector consisting of the last <c>k</c> elements of this vector
            </summary>
            
            <param name="K">The number of elements to extract</param>
            
            <returns>Returns a new GF2Vector consisting of the last <c>K</c> elements of this vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.GetBit(System.Int32)">
            <summary>
            Return the value of the bit of this vector at the specified index
            </summary>
            
            <param name="Index">The index</param>
            
            <returns>Returns the value of the bit (0 or 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.HammingWeight">
            <summary>
            Return the Hamming weight of this vector, i.e., compute the number of units of this vector
            </summary>
            
            <returns>Returns the Hamming weight of this vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.OS2VP(System.Int32,System.Byte[])">
            <summary>
            Construct a new GF2Vector with the given length out of the encoded vector
            </summary>
            
            <param name="Length">The length of the vector</param>
            <param name="EncVec">The encoded vector</param>
            
            <returns>Returns the decoded vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.SetBit(System.Int32)">
            <summary>
            Set the coefficient at the given index to 1. If the index is out of bounds, do nothing
            </summary>
            
            <param name="Index">The index of the coefficient to set</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.ToExtensionFieldVector(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Rewrite this vector as a vector over <c>GF(2^m)</c> with <c>t</c> elements
            </summary>
            
            <param name="Field">The finite field <c>GF(2<sup>m</sup>)</c></param>
            
            <returns>Returns the converted vector over <c>GF(2<sup>m</sup>)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Adds another GF2Vector to this vector
            </summary>
            
            <param name="V">The GF2Vector to add</param>
            
            <returns>Returns <c>this + V</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.GetEncoded">
            <summary>
            Encode this vector as byte array
            </summary>
            
            <returns>Returns the encoded vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.IsZero">
            <summary>
            Get: Return whether this is the zero vector (i.e., all elements are zero)
            </summary>
            <returns></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Multiply this vector with a permutation
            </summary>
            
            <param name="P">The permutation</param>
            
            <returns>Returns <c>this*p = p*this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.ToString">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal radix in MSB-first order
            </summary>
            
            <returns>Returns a String representing this Bitstrings value</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Vector.VectorArray">
            <summary>
            Get: Returns the int array representation of this vector
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial">
            <summary>
            This class implements polynomials over GF2nElements
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement)">
            <summary>
            Creates a new PolynomialGF2n of size <c>Degree</c> and elem as coefficients
            </summary>
            
            <param name="Degree">The maximum degree + 1</param>
            <param name="Element">A GF2nElement</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.#ctor(System.Int32)">
            <summary>
            Creates a new PolynomialGF2n of size <c>Degree</c>
            </summary>
            
            <param name="Degree">The maximum degree + 1</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Creates a new PolynomialGF2n by cloning the given PolynomialGF2n <c>G</c>
            </summary>
            
            <param name="G">The PolynomialGF2n to clone</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Polynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nField)">
            <summary>
            Creates a new PolynomialGF2n from the given Bitstring <c>G</c> over the GF2nField <c>B1</c>
            </summary>
            
            <param name="G">The Bitstring to use</param>
            <param name="B1">The field</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Adds the PolynomialGF2n <c>G</c> to <c>this</c> and returns the result in a new <c>PolynomialGF2n</c>
            </summary>
            
            <param name="P">The <c>PolynomialGF2n</c> to add</param>
            
            <returns>Returns <c>this + b</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.AssignZeroToElements">
            <summary>
            Assign the value 0 to these elements
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.At(System.Int32)">
            <summary>
            Returns the coefficient at <c>Index</c>
            </summary>
            
            <param name="Index">The index</param>
            
            <returns>Returns the GF2nElement stored as coefficient <c>Index</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Divide(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Divides <c>this</c> by <c>b</c> and stores the result in a new PolynomialGF2n[2], quotient in result[0] and remainder in result[1]
            </summary>
            
            <param name="B">The divisor</param>
            
            <returns>Retuens the quotient and remainder of <c>this</c> / <c>b</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Enlarge(System.Int32)">
            <summary>
            Enlarges the size of this PolynomialGF2n to <c>k</c> + 1
            </summary>
            
            <param name="K">The new maximum degree</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Gcd(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Computes the greatest common divisor of <c>this</c> and <c>g</c> and returns the result in a new PolynomialGF2n
            </summary>
            
            <param name="G">The GF2nPolynomial</param>
            
            <returns>Returns gcd(<c>this</c>, <c>g</c>)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.IsZero">
            <summary>
            Returns true if all coefficients equal zero
            </summary>
            
            <returns>Returns true if all coefficients equal zero</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Multiplies <c>this</c> by <c>P</c> and returns the result in a new PolynomialGF2n
            </summary>
            
            <param name="P">The PolynomialGF2n to multiply</param>
            
            <returns>Returns <c>this</c> * <c>P</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.MultiplyAndReduce(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Multiplies <c>this</c> by <c>B</c>, reduces the result by <c>G</c> and returns it in a new PolynomialGF2n
            </summary>
            
            <param name="B">The PolynomialGF2n to multiply</param>
            <param name="G">The modulus</param>
            
            <returns>Returns <c>this</c> * <c>B</c> mod <c>G</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Quotient(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Divides <c>this</c> by <c>B</c> and stores the quotient in a new PolynomialGF2n
            </summary>
            
            <param name="B">The divisor</param>
            
            <returns>Returns the quotient <c>this</c> / <c>B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Reduce(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Reduces <c>this</c> by <c>G</c> and returns the result in a newPolynomialGF2n
            </summary>
            
            <param name="G">The modulus</param>
            
            <returns>Returns <c>this</c> % <c>G</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Remainder(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial)">
            <summary>
            Divides <c>this</c> by <c>b</c> and stores the remainder in a new PolynomialGF2n
            </summary>
            
            <param name="B">The divisor</param>
            
            <returns>Returns The remainder <c>this</c> % <c>b</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.ScalarMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement)">
            <summary>
            Multiplies the scalar <c>E</c> to each coefficient of this PolynomialGF2n and returns the result in a new PolynomialGF2n
            </summary>
            
            <param name="E">The scalar to multiply</param>
            
            <returns>Returns <c>this</c> x <c>E</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Set(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nElement)">
            <summary>
            Sets the coefficient at <c>Index</c> to <c>Element</c>
            </summary>
            
            <param name="Index">The index</param>
            <param name="E">The GF2nElement to store as coefficient <c>Index</c></param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.ShiftLeft(System.Int32)">
            <summary>
            Shifts left <c>this</c> by <c>N</c> and stores the result in <c>this</c> PolynomialGF2n
            </summary>
            
            <param name="N">The amount the amount to shift the coefficients</param>
            
            <returns>The shifted polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.ShiftThisLeft(System.Int32)">
            <summary>
            Shifts left <c>this</c> by <c>N</c> and stores the result in <c>this</c> PolynomialGF2n
            </summary>
            
            <param name="N">The amount the amount to shift the coefficients</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Shrink">
            <summary>
            Shrink the size of this PolynomialGF2n
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Equals(System.Object)">
            <summary>
            Compare this element with another object
            </summary>
            
            <param name="Obj">The object for comprison</param>
            
            <returns>Returns <c>true</c> if the two objects are equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.GetHashCode">
            <summary>
            Returns the hash code of this element
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Degree">
            <summary>
            Get: Returns the degree of this PolynomialGF2n
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nPolynomial.Size">
            <summary>
            Get: Returns the size (=maximum degree + 1) of this PolynomialGF2n; this is not the degree, use Degree instead.
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector">
            <summary>
            This class implements vectors over the finite field <c>GF(2^m)</c> for small <c>m</c> (i.e., <c>1&lt;m&lt;32</c>). It extends the abstract class Vector.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,System.Byte[])">
            <summary>
            Creates the vector over GF(2^m) of given length and with elements from array V (beginning at the first bit)
            </summary>
            
            <param name="Field">The finite field</param>
            <param name="V">An array with elements of vector</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField,System.Int32[])">
            <summary>
            Create a new vector over <c>GF(2^m)</c> of the given length and element array
            </summary>
            
            <param name="Field">The finite field <c>GF(2^m)</c></param>
            <param name="Vector">The element array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector)">
            <summary>
            The copy constructor
            </summary>
            
            <param name="GF">The GF2mVector to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Vector)">
            <summary>
            Not implemented
            </summary>
            
            <param name="Addend">The other vector</param>
            <returns>throws NotImplementedException</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.Equals(System.Object)">
            <summary>
            Compare this vector with another object
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>The result of the comparison</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.GetEncoded">
            <summary>
            Return a byte array encoding of this vector
            </summary>
            
            <returns>The encoded vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.GetHashCode">
            <summary>
            Computes the hash code of this vector
            </summary>
            
            <returns>The hsh code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.IsZero">
            <summary>
            Returns whether this is the zero vector (i.e., all elements are zero)
            </summary>
            
            <returns>Returns <c>true</c> if this is a zero vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Multiply this vector with a permutation
            </summary>
            
            <param name="P">he permutation</param>
            
            <returns>Returns <c>this*p = p*this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.ToString">
            <summary>
            Return a human readable form of this vector
            </summary>
            
            <returns>The vector as a string</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.Field">
            <summary>
            The finite field this vector is defined over
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mVector.IntArrayForm">
            <summary>
            The int[] form of this vector
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField">
            <summary>
            This class describes operations with elements from the finite field F = GF(2^m).
            <para>GF(2^m)= GF(2)[A] where A is a root of irreducible polynomial with degree m,
            each field element B has a polynomial basis representation,
            is represented by a different binary polynomial of degree less than m, B = poly(A)</para>
            </summary>
            
            <remarks>
            All operations are defined only for field with 1&lt; m &lt;32.
            <para>For the representation of field elements the map f: F-&gt;Z, poly(A)-&gt;poly(2) is used,
            where integers have the binary representation. For example: A^7+A^3+A+1 -&gt;
            (00...0010001011)=139 Also for elements type Integer is used.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.#ctor(System.Int32)">
            <summary>
            Create a finite field GF(2^m)
            </summary>
            
            <param name="Degree">The degree of the field</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.#ctor(System.Int32,System.Int32)">
            <summary>
            Create a finite field GF(2^m) with the fixed field polynomial
            </summary>
            
            <param name="Degree">The degree of the field</param>
            <param name="Polynomial">The field polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.#ctor(System.Byte[])">
            <summary>
            Create a finite field GF(2^m) using an encoded array
            </summary>
            
            <param name="Encoded">The polynomial and degree encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField)">
            <summary>
            Create a finite field GF(2^m) using another GF2mField class
            </summary>
            
            <param name="Field">The GF2mField class to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Add(System.Int32,System.Int32)">
            <summary>
            Return the Xor sum of two elements
            </summary>
            
            <param name="A">Integer value A</param>
            <param name="B">Integer value b</param>
            
            <returns>The sum: <c>a^b</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Clear">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.ElementToString(System.Int32)">
            <summary>
            Help method for visual control
            </summary>
            <param name="A">Element value A</param>
            <returns>Element as a string value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Exp(System.Int32,System.Int32)">
            <summary>
            Compute exponentiation of a^k
            </summary>
            
            <param name="A">The field element A</param>
            <param name="K">The K degree</param>
            
            <returns>The sum: <c>a pow k</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.GetEncoded">
            <summary>
            Returns the encoded form of this field
            </summary>
            
            <returns>The encoded field</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Inverse(System.Int32)">
            <summary>
            Compute the multiplicative inverse of a
            </summary>
            
            <param name="A">The field element A</param>
            
            <returns>The inverse value A</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.GetRandomElement(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create a random field element using PRNG
            </summary>
            
            <param name="SecRnd">The IRandom instance</param>
            
            <returns>A random element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.GetRandomNonZeroElement(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create a random non-zero field element
            </summary>
            
            <param name="SecRnd">The IRandom instance</param>
            
            <returns>A random non zero element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.IsElementOfThisField(System.Int32)">
            <summary>
            Test if E is encoded element of this field
            </summary>
            
            <param name="E">Encoded element</param>
            
            <returns>Returns true if e is encoded element of this field, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Multiply(System.Int32,System.Int32)">
            <summary>
            Return the product of two elements
            </summary>
            
            <param name="A">Integer value A</param>
            <param name="B">Integer value b</param>
            
            <returns>The sum: <c>a*b</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Sqrt(System.Int32)">
            <summary>
            Compute the square root of an integer
            </summary>
            
            <param name="A">The field element A</param>
            
            <returns>The square root of A</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Equals(System.Object)">
            <summary>
            Checks if the given object is equal to this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns false if the object is not equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.GetHashCode">
            <summary>
            Get a unique hash code for this class instance 
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.ToString">
            <summary>
            Get a human readable form of this field
            </summary>
            
            <returns>Degree and polynomial in readable form</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Degree">
            <summary>
            Get: The degree of the field polynomial ring over the finite field GF(2)
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2mField.Polynomial">
            <summary>
            Get: Returns the polynomial field
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo">
            <summary>
            The DtmFileInfo structure.
            <para>The DtmFileInfo structure is a header that preceedes a file.</para>
            </summary>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmParameters class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmClient structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmIdentity structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmPacket structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmSession structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmKex class</seealso>
            
            <revisionHistory>
            <revision date="2015/05/23" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.FileName">
            <summary>
            The file name
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.FileSize">
            <summary>
            The total number of file bytes in the file
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.OptionsFlag">
            <summary>
            Flag used to identify the type of payload and options
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.#ctor(System.String,System.Int64,System.Int64)">
            <summary>
            The DtmFileInfo primary constructor
            </summary>
            
            <param name="FileName">The file name</param>
            <param name="FileSize">The total number of file bytes in the file</param>
            <param name="OptionsFlag">The total length of the stream</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.#ctor(System.Byte[])">
            <summary>
            Constructs a DtmFileInfo from a byte array
            </summary>
            
            <param name="FragmentArray">The byte array containing the DtmFileInfo structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.#ctor(System.IO.Stream)">
            <summary>
            Constructs a DtmIdentity from a stream
            </summary>
            
            <param name="InfoStream">Stream containing a serialized DtmFileInfo</param>
            
            <returns>A populated DtmFileInfo</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.DeSerialize(System.IO.Stream)">
            <summary>
            Deserialize an DtmFileInfo
            </summary>
            
            <param name="InfoStream">Stream containing a serialized DtmFileInfo</param>
            
            <returns>A populated DtmFileInfo</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.Serialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo)">
            <summary>
            Serialize an DtmFileInfo structure
            </summary>
            
            <param name="FileInfo">A DtmFileInfo structure</param>
            
            <returns>A stream containing the DtmFileInfo data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.ToBytes">
            <summary>
            Returns the DtmFileInfo as an encoded byte array
            </summary>
            
            <returns>The serialized DtmFileInfo</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmFileInfo.ToStream">
            <summary>
            Returns the DtmFileInfo as an encoded MemoryStream
            </summary>
            
            <returns>The serialized DtmFileInfo</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.NetworkTools.IsPrivateAddress(System.Net.IPAddress)">
            <summary>
            Tests if an address is a private ip
            </summary>
            
            <param name="Address">The ip address to test</param>
            
            <returns>Returns <c>true</c> if the address is a private ip address, otherwise <c>false</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.NetworkTools.TraceRoute(System.Net.IPAddress,System.Int32,System.Int32)">
            <summary>
            Performs a trace route on an ip address
            </summary>
            
            <param name="Address">The target ip address</param>
            <param name="MaxHops">The maximum hopcount</param>
            <param name="PingTimeout">The timeout for each ping</param>
            
            <returns>An array of PingReplys for the whole path</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator">
            <summary>
            <h3>A helper class for generating cryptographically strong keying material.</h3>
            <para>Generates an array or a populated KeyParams class, using a definable Digest(Prng) dual stage generator.</para>
            
            </summary>
            
            <example>
            <description>Create an array of pseudo random keying material:</description>
            <code>
            byte[] rand;
            using (KeyGenerator gen = new KeyGenerator([Prng], [Digest]))
                // generate pseudo random bytes
                rand = gen.Generate(Size);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Assignable digests and Prng parameters added</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Prng">VTDev.Libraries.CEXEngine.Crypto.Prng Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>SHA-2 Generates key material using a two stage Hmac_k(Prng()) process.</description></item>
            <item><description>Blake<cite>Blake</cite>, Keccak<cite>Keccak</cite>, and Skein<cite>Skein</cite> also use a two stage generation method; Hash(Prng()).</description></item>
            <item><description>Prng can be any of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs"/> generators.</description></item>
            <item><description>Hash can be any of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests"/> digests.</description></item>
            <item><description>Default Prng is CSPRng<cite>RNGCryptoServiceProvider</cite>, default digest is SHA512.</description></item>
            <item><description>Resources are disposed of automatically.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.#ctor">
            <summary>
            <para>Initializes the class with default generators; SHA-2 512, and RNGCryptoServiceProvider</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize the class and generators
            </summary>
            <param name="SeedEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">Prng</see> that supplies the key and seed material to the hash function</param>
            <param name="HashEngine">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> type used to create the pseudo random keying material</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.GetKeyParams(System.Int32,System.Int32,System.Int32)">
            <summary>
            Create a populated KeyParams class
            </summary>
            
            <param name="KeySize">Size of Key to generate in bytes</param>
            <param name="IVSize">Size of Optional IV in bytes</param>
            <param name="IKMSize">Size of Optional IKM in bytes</param>
            
            <returns>A populated <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.GetBytes(System.Int32)">
            <summary>
            Return an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.Reset">
            <summary>
            Reset the seed <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">PRNG</see> and the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">Digest</see> engines
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.GetBlock">
            <remarks>
            Create keying material using a two stage generator
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Common.KeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg">
            <summary>
            <h3>CTRDrbg: An implementation of a Encryption Counter based Deterministic Random Byte Generator.</h3>
            <para>A Block Cipher Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90B</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IGenerator</c> interface:</description>
            <code>
            using (IGenerator rnd = new CTRDrbg(new RDX()))
            {
                // initialize
                rnd.Initialize(Salt, [Ikm], [Nonce]);
                // generate bytes
                rnd.Generate(Output, [Offset], [Size]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">cipher</see>.</description></item>
            <item><description>Parallelized by default on a multi processer system when an input byte array of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMinimumSize"/> bytes or larger is used.</description></item>
            <item><description>Parallelization can be disabled using the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsParallel"/> property.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean,System.Int32)">Constructors</see> DisposeEngine parameter determines if Cipher engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>Combination of [Salt, Ikm, Nonce] must be: cipher key size +  cipher block size in length.</description></item>
            <item><description>Nonce and Ikm are optional, (but recommended).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean,System.Int32)">
            <summary>
            Creates a CTR Bytes Generator using a block cipher
            </summary>
            
            <param name="Cipher">The block cipher</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose"/> on this class is called</param>
            <param name="KeySize">The key size (in bytes) of the symmetric cipher; a <c>0</c> value will auto size the key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null block cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if an invalid or null salt is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Initialize(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Initialize the generator
            </summary>
            
            <param name="Salt">Salt value</param>
            <param name="Ikm">Key material</param>
            <param name="Info">Nonce value</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null salt or ikm is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Generate(System.Byte[])">
            <summary>
            Generate a block of pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            
            <returns>Number of bytes generated</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Generate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Generate pseudo random bytes
            </summary>
            
            <param name="Output">Output array filled with random bytes</param>
            <param name="OutOffset">Position within Output array</param>
            <param name="Size">Number of bytes to generate</param>
            
            <returns>Number of bytes generated</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if the output buffer is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Update(System.Byte[])">
            <summary>
            <para>Update the Seed material. Two state Seed paramater: 
            If Seed size is equal to cipher key size plus counter size, both are updated. 
            If Seed size is equal to counter size (16 bytes) counter is updated.</para>
            </summary>
            
            <param name="Seed">Pseudo random seed material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoGeneratorException">Thrown if a null Seed is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsInitialized">
            <summary>
            Get: Generator is ready to produce data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.IsParallel">
            <summary>
            Get/Set Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.KeySize">
            <summary>
            <para>The key size (in bytes) of the symmetric cipher</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ProcessorCount">
            <summary>
            Processor count
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.Name">
            <summary>
            Get: Algorithm Name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Generator.CTRDrbg.ParallelMinimumSize">
            <summary>
            Get: Minimum input size to trigger parallel processing
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates">
            <summary>
            <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/> subkey policy flags describing the current state of that subkey set.
            <para>Used by the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory"/> class to set a subkey operational state flag.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates.Expired">
            <summary>
            The subkey set is no longer valid for encryption
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates.Erased">
            <summary>
            The subkey was set to the PostOverwrite policy and has been used for decryption and subsequently erased
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates.Locked">
            <summary>
            The subkey was set to the SingleUse policy and has been used for decryption and subsequently locked for access
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.PackageKeyStates.Destroyed">
            <summary>
            An action has caused the erasure of the entire subkey set array
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers">
            <summary>
            Block Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.RDX">
            <summary>
            An extended implementation of the Rijndael Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.RHX">
            <summary>
            An implementation based on the Rijndael Block Cipher, using HKDF with a SHA512 HMAC for expanded key generation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.RSM">
            <summary>
            An implementation based on the Rijndael and Serpent Merged Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.SPX">
            <summary>
            An extended implementation of the Serpent Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.SHX">
            <summary>
            The Serpent Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.TFX">
            <summary>
            An extended implementation of the Twofish Block Cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.THX">
            <summary>
            A Twofish Block Cipher Extended with an HKDF Key Schedule
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers.TSM">
            <summary>
            An implementation based on the Twofish and Serpent Merged Block Ciphers, using an HKDF Key Schedule
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines">
            <summary>
            Asymmetric Encryption Ciphers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines.McEliece">
            <summary>
            An McEliece CCA2 cipher implementation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines.NTRU">
            <summary>
            An NTRU cipher implementation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines.RingLWE">
            <summary>
            An Ring-LWE cipher implementation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines.Rainbow">
            <summary>
            A Rainbow signing implementation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines.GMSS">
            <summary>
            A Generalized Merkle Signature Scheme implementation
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX">
            <summary>
            <h3>SPX: An extended implementation of the Serpent encryption cipher.</h3>
            <para>SPX is an implementation of the Serpent<cite>Serpent</cite> block cipher, extended to use a 512 bit key.</para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new CTR(new SPX()))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/14" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Secondary release; updates to layout and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Valid Key sizes are 128, 192, 256 and 512 bits (16, 24, 32 and 64 bytes).</description></item>
            <item><description>Block size is 16 bytes wide.</description></item>
            <item><description>Valid Rounds assignments are 32, 40, 48, 56, and 64, default is 32.</description></item>
            </list>
            
            <para>The Key Schedule has been written so that it can both accept a larger key size of 512 bits, 
            and produce the required number of working keys with a variable number of diffusion rounds.</para>
            
            <para>The diffusion rounds, (the portion of the cipher that does the actual mixing of plaintext into ciphertext),
            is exactly the same with every key length, only it can now process an increased number of rounds, from 32; 
            the standard, up to 64 rounds. 
            This increase in the ciphers diffusion cycles makes linear and differential analysis more difficult, 
            and the larger key size ensures that it can not be brute forced.</para>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Serpent: <see href="http://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf">Specification</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired in part by the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.#ctor(System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="Rounds">Number of diffusion rounds. The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalRounds"/> property contains available sizes.  Default is 32 rounds.</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if an invalid rounds count is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.DecryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Decrypt a single block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="Output">Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.DecryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>false</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Encrypted bytes</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Decrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.EncryptBlock(System.Byte[],System.Byte[])">
            <summary>
            Encrypt a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="Output">Encrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.EncryptBlock(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encrypt a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called with the Encryption flag set to <c>true</c> before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher.
            </summary>
            
            <param name="Encryption">Using Encryption or Decryption mode</param>
            <param name="KeyParam">Cipher key container. <para>The <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalKeySizes"/> property contains valid sizes.</para></param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null or invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Transform(System.Byte[],System.Byte[])">
            <summary>
            Transform a block of bytes.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output array lengths must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt or Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Transform a block of bytes with offset parameters.
            <para><see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.
            Input and Output arrays with Offsets must be at least <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize"/> in length.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LinearTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.InverseTransform(System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <remarks>
            Apply the inverse of the linear transformation to the register set
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.BlockSize">
            <summary>
            Get: Unit block size of internal cipher.
            <para>Block size is 16 bytes wide.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption.
            <para>Value set in <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/>.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalBlockSizes">
            <summary>
            Get: Available block sizes for this cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalKeySizes">
            <summary>
            Available Encryption Key Sizes in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.LegalRounds">
            <summary>
            Get: Available diffusion round assignments
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.SPX.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial">
            <summary>
            A polynomial of the form <c>f1*f2+f3</c>, where 
            <c>f1,f2,f3</c> are very sparsely populated ternary polynomials.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.SparseTernaryPolynomial)">
            <summary>
            Constructs a new polynomial from three sparsely populated ternary polynomials
            </summary>
            
            <param name="F1">F1 polynomial</param>
            <param name="F2">F2 polynomial</param>
            <param name="F3">F3 polynomial</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Clear">
            <summary>
            Clear the state data
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.GenerateRandom(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a <c>ProductFormPolynomial</c> from three random ternary polynomials.
            </summary>
            
            <param name="N">Number of coefficients</param>
            <param name="Df1">Number of ones in the first polynomial; also the number of negative ones</param>
            <param name="Df2">Number of ones in the second polynomial; also the number of negative ones</param>
            <param name="Df3Ones">Number of ones in the third polynomial</param>
            <param name="Df3NegOnes">Number of negative ones in the third polynomial</param>
            <param name="Rng">Random number generator</param>
            
            <returns>A random <c>ProductFormPolynomial</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.FromBinary(System.Byte[],System.Int32)">
            <summary>
            Decodes a byte array encoded with ToBinary() to a polynomial.
            </summary>
            
            <param name="Data">An encoded <c>ProductFormPolynomial</c></param>
            <param name="N">Number of coefficients in the polynomial</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.FromBinary(System.IO.MemoryStream,System.Int32)">
            <summary>
            Decodes a polynomial encoded with ToBinary()
            </summary>
            
            <param name="InputStrem">An input stream containing an encoded polynomial</param>
            <param name="N">Number of coefficients in the polynomial</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.ToBinary">
            <summary>
            Encodes the polynomial to a byte array
            </summary>
            
            <returns>The encoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the coefficient values mod <c>modulus</c> and the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            <param name="Modulus">The modulus to apply</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.BigIntPolynomial)">
            <summary>
            Multiplies the polynomial by an <c>IntegerPolynomial</c>,
            taking the indices mod <c>N</c>.
            </summary>
            
            <param name="Factor">A polynomial factor</param>
            
            <returns>The product of the two polynomials</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.ToIntegerPolynomial">
            <summary>
            Returns a polynomial that is equal to this polynomial (in the sense that mult(IntegerPolynomial, int) 
            returns equal <c>IntegerPolynomial</c>s). The new polynomial is guaranteed to be independent of the original.
            </summary>
            
            <returns>The polynomial product</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.GetHashCode">
            <summary>
            Get the hash code
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.ProductFormPolynomial.Equals(System.Object)">
            <summary>
            Compare this polynomial to another for equality
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean">
            <summary>
            Extended Euclidean Algorithm in BigIntegers
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.X">
            <summary>
            Coefficient X
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.Y">
            <summary>
            Coefficient Y
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.GCD">
            <summary>
            Greatest Common Divisor
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Arithmetic.BigIntEuclidean.Calculate(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Runs the EEA on two BigIntegers
            </summary>
            <param name="A">Quotient A</param>
            <param name="B">Quotient B</param>
            <returns>Return a BigIntEuclidean object that contains the result in the variables X, Y, and GCD</returns>
            
            <remarks>
            Implemented from pseudocode on <a href="http://en.wikipedia.org/wiki/Extended_Euclidean_algorithm"/>Wikipedia
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign">
             <summary>
             An MPKCS One Time Sign (OTS) message sign and verify implementation.
             <para>Sign: uses the specified digest to hash a message; the hash value is then encrypted with a McEliece public key.
             Verify: decrypts the McEliece cipher text, and then compares the value to a hash of the message.</para>
             </summary>
             
             <example>
             <description>Example of using the signing and verifying an array:</description>
             <code>
             MPKCParameters ps = MPKCParamSets.MPKCFM11T40S256;
             MPKCKeyGenerator gen = new MPKCKeyGenerator(ps);
             IAsymmetricKeyPair kp = gen.GenerateKeyPair();
             byte[] code;
             byte[] data = new byte[100];
            
             // get the message code for an array of bytes
             using (MPKCSign sgn = new MPKCSign(ps))
             {
                 sgn.Initialize(kp.PublicKey);
                 code = sgn.Sign(data, 0, data.Length);
             }
            
             // test the message for validity
             using (MPKCSign sgn = new MPKCSign(ps))
             {
                 sgn.Initialize(kp.PrivateKey);
                 bool valid = sgn.Verify(data, 0, data.Length, code);
             }
             </code>
             </example>
             
             <revisionHistory>
             <revision date="2015/01/23" version="1.4.0.0">Initial release</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines">VTDev.Libraries.CEXEngine.Crypto AsymmetricEngines Enumeration</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece MPKCPublicKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece MPKCPrivateKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
             
             <remarks>
             <description><h4>Implementation Notes:</h4></description>
             <list type="bullet">
             <item><description>Signing is intended as a one time only key implementation (OTS); keys should never be re-used.</description></item>
             <item><description>Uses the McEliece CCA2 variants; Fujisaki, KobriImai, or PointCheval ciphers.</description></item>
             <item><description>Digests can be any of the implemented digests; Blake, Keccak, SHA-2 or Skein.</description></item>
             </list> 
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The McEliece cipher used to encrypt the hash</param>
            <param name="Digest">The type of digest engine used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the McEliece Public (Sign) or Private (Verify) key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid keypair is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Reset">
            <summary>
            Reset the underlying digest engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Sign(System.IO.Stream)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="InputStream">The stream containing the data</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the signer is not initialized or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Sign(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="Input">The byte array contining the data</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the signer is not initialized, the length is out of range, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Verify(System.IO.Stream,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="InputStream">The stream containing the data to test</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Verify(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="Input">The stream containing the data to test</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Compute(System.IO.Stream)">
            <summary>
            Compute the hash from a stream
            </summary>
            
            <param name="InputStream">The input stream</param>
            
            <returns>The hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compute the hash from a byte array
            </summary>
            
            <param name="Input">The data byte array</param>
            <param name="Offset">The starting offset within the array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Engine">Engine type</param>
            
            <returns>Instance of digest</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the digest is unrecognized or unsupported</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.GetEngine(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParameters)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="CipherParams">The engine type</param>
            
            <returns>An initialized cipher</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.IsSigner">
            <summary>
            Get: This class is initialized for Signing with the Public key
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can decrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the signer is not initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCSign.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey">
            <summary>
            A McEliece Public Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.#ctor(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2Matrix)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="N">The length of the code</param>
            <param name="T">The error correction capability of the code</param>
            <param name="G">The generator matrix</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.#ctor(System.Int32,System.Int32,System.Byte[])">
            <summary>
            Constructor used by McElieceKeyFactory
            </summary>
            
            <param name="N">The length of the code</param>
            <param name="T">The error correction capability of the code</param>
            <param name="G">The encoded generator matrix</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.#ctor(System.IO.Stream)">
            <summary>
            Read a Public Key from a Stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.#ctor(System.Byte[])">
            <summary>
            Read a Public Key from a byte array
            </summary>
            
            <param name="KeyArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized MPKCPublicKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.From(System.IO.Stream)">
            <summary>
            Read a Public key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized MPKCPublicKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.ToBytes">
            <summary>
            Converts the Public key to an encoded byte array
            </summary>
            
            <returns>The encoded MPKCPublicKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.ToStream">
            <summary>
            Converts the Public key to an encoded MemoryStream
            </summary>
            
            <returns>The Public Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.WriteTo(System.Byte[])">
            <summary>
            Writes encoded the MPKCPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded MPKCPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded MPKCPublicKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Public Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.Equals(System.Object)">
            <summary>
            Decides whether the given object <c>other</c> is the same as this field
            </summary>
            
            <param name="Obj">The object for comparison</param>
            
            <returns>Returns <c>(this == other)</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.GetHashCode">
            <summary>
            Returns the hash code of this field
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.Clone">
            <summary>
            Create a shallow copy of this MPKCPublicKey instance
            </summary>
            
            <returns>The MPKCPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.DeepCopy">
            <summary>
            Create a deep copy of this MPKCPublicKey instance
            </summary>
            
            <returns>The MPKCPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.N">
            <summary>
            Get: Returns the length of the code
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.T">
            <summary>
            Get: Returns the error correction capability of the code
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.G">
            <summary>
            Get: Returns the generator matrix
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCPublicKey.K">
            <summary>
            Get: Returns the dimension of the code
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation">
            <summary>
            This class implements permutations of the set {0,1,...,n-1} for some given n &gt; 0.
            <para>i.e., ordered sequences containing each number <c>m</c> (<c>0 &lt;= m &lt; n</c>) once and only once.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.#ctor(System.Int32)">
            <summary>
            Create the identity permutation of the given size
            </summary>
            
            <param name="N">The size of the permutation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.#ctor(System.Int32[])">
            <summary>
            Create a permutation using the given permutation vector
            </summary>
            
            <param name="Perm">The permutation vector</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.#ctor(System.Byte[])">
            <summary>
            Create a permutation using an encoded permutation
            </summary>
            
            <param name="Encoded">The encoded permutation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Create a random permutation of the given size
            </summary>
            
            <param name="N">The size of the permutation</param>
            <param name="SecRnd">The source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.Clear">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.ComputeInverse">
            <summary>
            Compute the inverse permutation <c>P pow -1</c>
            </summary>
            
            <returns>Returns <c>this pow -1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.GetEncoded">
            <summary>
            Encode this permutation as byte array
            </summary>
            
            <returns>The encoded permutation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.GetVector">
            <summary>
            The permutation vector <c>(perm(0),perm(1),...,perm(n-1))</c>
            </summary>
            
            <returns>The permutation vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.RightMultiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation)">
            <summary>
            Compute the product of this permutation and another permutation
            </summary>
            
            <param name="p">The other permutation</param>
            
            <returns>Returns <c>this * P</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.Equals(System.Object)">
            <summary>
            Checks if given object is equal to this permutation
            </summary>
            
            <param name="Obj">The object to compare this with</param>
            
            <returns>Returns false whenever the given object is not equl to this</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.GetHashCode">
            <summary>
            Returns the hash code of this permutation
            </summary>
            <returns></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.Permutation.ToString">
            <summary>
            Creates a human readable form of the permutation
            </summary>
            
            <returns>Returns the permutation in readable form</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs">
            <summary>
            An event arguments class containing the exchange state information.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs.Message">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags">Exchange State</see> (Auth or Primary), from which this message originated
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs.OptionFlag">
            <summary>
            The option flag containing optional state information
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs.Cancel">
            <summary>
            The Cancel token; setting this value to true instructs the server to shutdown the exchange (Terminate)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs.#ctor(System.Int16,System.Int64)">
            <summary>
            The DTM packet event args constructor; contains the current exchange state
            </summary>
            
            <param name="Message">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags">Exchange State</see> (Auth or Primary), from which this message originated</param>
            <param name="OptionFlag">The option flag containing optional state information</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmEstablishedEventArgs">
            <summary>
            An event arguments class containing the final symmetric keys from a completed exchange.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmEstablishedEventArgs.ForwardSession">
            <summary>
            The initialized Forward session encryption cipher; used to encrypt a stream sent to the remote host
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmEstablishedEventArgs.ReturnSession">
            <summary>
            The initialized Return session encryption cipher; used to decrypt a stream sent from the remote host
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmEstablishedEventArgs.OptionFlag">
            <summary>
            An option flag that can contain additional information about the exchange
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmEstablishedEventArgs.#ctor(System.Net.Sockets.Socket,VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode,VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode,System.Int64)">
            <summary>
            The DTM Established event arguments constructor
            </summary>
            
            <param name="ForwardSession">The initialized Forward session encryption cipher; used to encrypt data sent to the remote host</param>
            <param name="ReturnSession">The initialized Return session encryption cipher; used to decrypt data sent from the remote host</param>
            <param name="Flag">An option flag that can contain additional information about the exchange</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmDataReceivedEventArgs">
            <summary>
            An event arguments class containing the error state information.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmDataReceivedEventArgs.Message">
            <summary>
            The stream containing decrypted data from a post-exchange channel
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmDataReceivedEventArgs.OptionFlag">
            <summary>
            The option flag containing optional state information
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmDataReceivedEventArgs.Cancel">
            <summary>
            The Cancel token; setting this value to true instructs the server to shutdown the exchange (Terminate)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmDataReceivedEventArgs.#ctor(System.IO.MemoryStream,System.Int64)">
            <summary>
            The DTM error event args constructor; contains the current error state
            </summary>
            
            <param name="Message">The <see cref="T:System.Exception"/></param>
            <param name="OptionFlag">The option flag containing optional state information</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Tools.Compare">
            <summary>
            Compare arrays for equality
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.False(System.Boolean)">
            <summary>
            Returns true if condition is false
            </summary>
            
            <param name="B">Test variable</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.True(System.Boolean)">
            <summary>
            Returns true if condition is true
            </summary>
            
            <param name="B">Test variable</param>
            
            <returns>State</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal[],VTDev.Libraries.CEXEngine.Numeric.BigDecimal[])">
            <summary>
            Compare BigDecimal Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Compare BigInteger Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Byte[],System.Byte[])">
            <summary>
            Compare Byte Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Char[],System.Char[])">
            <summary>
            Compare Char Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int16[],System.Int16[])">
            <summary>
            Compare short integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int32[],System.Int32[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Int64[],System.Int64[])">
            <summary>
            Compare Integer Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Single[],System.Single[])">
            <summary>
            Compare float Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Tools.Compare.AreEqual(System.Double[],System.Double[])">
            <summary>
            Compare double Arrays
            </summary>
            
            <param name="A">Array A</param>
            <param name="B">Array B</param>
            
            <returns>Equal</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            <h3>This class represents immutable arbitrary precision decimal numbers</h3>
            
            
            <description>Immutable, arbitrary-precision signed decimal numbers.</description> 
            <para>A BigDecimal consists of an arbitrary precision integer unscaled valueand a 32-bit integer scale.  
            If zero or positive, the scale is the number of digits to the right of the decimal point.  
            If negative, the unscaled value of the number is multiplied by ten to the power of the negation of the scale.  
            The value of the number represented by the BigDecimal is therefore (unscaledValue times; 10 pow -scale).</para>
            </summary>
            
            <example>
            <description>Creating a BigDecimal:</description>
            <code>
            BigDecimal p = BigDecimal(bigInt);
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.2.0">Initial release</revision>
            </revisionHistory>
            
            <remarks>
            <para>The BigDecimal class provides operations for arithmetic, scale manipulation, rounding, comparison, hashing, and format conversion.  
            The ToString() method provides a canonical representation of a BigDecimal.</para>
            
            <para>The BigDecimal class gives its user complete control over rounding behavior.  
            If no rounding mode is specified and the exact result cannot be represented, an exception is thrown;
            otherwise, calculations can be carried out to a chosen precision and rounding mode by supplying an appropriate MathContext object to the operation.  
            In either case, eight rounding modes are provided for the control of rounding.  
            Using the integer fields in this class (such as HalfUp) to represent rounding mode is largely obsolete; 
            the enumeration values of the RoundingMode enum, (such as HalfUp) should be used instead.</para>
            
            <para>When a MathContext object is supplied with a precision setting of 0 (for example, Unnecessary), arithmetic operations are exact, 
            as are the arithmetic methods which take no MathContext object. 
            As a corollary of computing the exact result, the rounding mode setting of a MathContext object with a precision setting of 0 is not used and thus irrelevant.  
            In the case of divide, the exact quotient could have an infinitely long decimal expansion; for  example, 1 divided by 3.  
            If the quotient has a nonterminating decimal expansion and the operation is specified to return an exact result, an ArithmeticException is thrown.  
            Otherwise, the exact result of the division is returned, as done for other operations.</para>
            
            <para>When the precision setting is not 0, the rules of BigDecimal arithmetic are broadly compatible with selected 
            modes of operation of the arithmetic defined in ANSI X3.274-1996 and ANSI X3.274-1996/AM 1-2000 (section 7.4).  
            Unlike those standards, BigDecimal includes many rounding modes. Any conflicts between these ANSI standards and the BigDecimal specification are resolved in favor of BigDecimal.</para>
            
            <para>Since the same numerical value can have different representations (with different scales), the rules of arithmetic
            and rounding must specify both the numerical result and the scale used in the result's representation.</para>
            
            <para>In general the rounding modes and precision setting determine how operations return results with a limited number of digits when
            the exact result has more digits (perhaps infinitely many in the case of division) than the number of digits returned.</para>
            
            <para>First, the total number of digits to return is specified by the MathContext's Precision} setting; this determines the result's <c>Precision</c>.  
            The digit count starts from the leftmost nonzero digit of the exact result.  The rounding mode determines how any discarded trailing digits affect the returned result.</para>
            
            <para>For all arithmetic operators , the operation is carried out as though an exact intermediate result were first calculated and then
            rounded to the number of digits specified by the precision setting (if necessary), using the selected rounding mode.  
            If the exact result is not returned, some digit positions of the exact result are discarded.  
            When rounding increases the magnitude of the returned result, it is possible for a new digit position to be created by a carry propagating to a leading "9" digit.
            For example, rounding the value 999.9 to three digits rounding up would be numerically equal to one thousand, represented as <c>100 times 10 pow 1</c>.  
            In such cases, the new "1" is the leading digit position of the returned result.</para>
            
            <para>Besides a logical exact result, each arithmetic operation has a preferred scale for representing a result.  
            The preferred scale for each operation is listed in the table below.</para>
            
            <description>Preferred Scales for Results of Arithmetic Operations</description>
            <list type="table">
            <item><description>Operation: Preferred Scale of Result</description></item>
            <item><description>Add: Max(Addend.Scale(), Augend.Scale())</description></item>
            <item><description>Subtract: Max(Minuend.Scale(), Subtrahend.Scale())</description></item>
            <item><description>Multiply: Multiplier.Scale() + Multiplicand.Scale()</description></item>
            <item><description>Divide: Dividend.Scale() - Divisor.Scale()</description></item>
            </list>
            
            <para>These scales are the ones used by the methods which return exact arithmetic results; 
            except that an exact divide may have to use a larger scale since the exact result may have more digits.  
            For example, <c>1/32</c> is <c>0.03125</c>.</para>
            
            <para>Before rounding, the scale of the logical exact intermediate result is the preferred scale for that operation.  
            If the exact numerical result cannot be represented in Precision digits, rounding selects the set of digits to return and the scale
            of the result is reduced from the scale of the intermediate result to the least scale which can represent the Precision digits actually returned. 
            If the exact result can be represented with at most Precision digits, the representation of the result with the scale closest to the preferred scale is returned.  
            In particular, an exactly representable quotient may be represented in fewer than Precision digits by removing trailing zeros and decreasing the scale.  
            For example, rounding to three digits using the Floor rounding mode.</para>
            
            <para>Note that for add, subtract, and multiply, the reduction in scale will equal the number of digit positions of the exact result which are discarded. 
            If the rounding causes a carry propagation to create a new high-order digit position, an additional digit of the result is discarded than when no new digit position is created.</para>
            
            <para>Other methods may have slightly different rounding semantics.
            For example, the result of the Pow method using the Pow(int, MathContext) specified algorithm can occasionally differ from the rounded mathematical result by more
            than one unit in the last place, one Ulp.</para>
            
            <para>Two types of operations are provided for manipulating the scale of a BigDecimal: scaling/rounding operations and decimal point motion operations.  
            Scaling/rounding operations SetScale and Round}) return a BigDecimal whose value is approximately (or exactly) equal
            to that of the operand, but whose scale or precision is the specified value; that is, they increase or decrease the precision
            of the stored number with minimal effect on its value.  
            Decimal point motion operations (MovePointLeft and MovePointRight) return a BigDecimal created from the operand by moving the decimal point a specified distance in the specified direction.</para>
            
            Each BigDecimal instance is represented with a unscaled arbitrary precision mantissa (the unscaled value) and a scale. 
            <para>The value of the "BigDecimal is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue"/> 10^(-<see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale"/>).
            Since the ToString() method is overriden by this class and it changes the state of the object causing Heisenbugs
            for debuggability we add the attribute DebuggerDisplay that points to a method that doesn't change it.</para>
            </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Zero">
            <summary>
            The constant zero as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.One">
            <summary>
            The constant one as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Ten">
            <summary>
            The constant ten as a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#cctor">
            <summary>
            Initializes static members of the BigDecimal class.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal, 
            accepting the same sequence of characters as the BigDecimal(String) constructor,
            while allowing a sub-array to be specified.
            <para>Note that if the sequence of characters is already available within a character array, 
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">Array that is the source of characters</param>
            <param name="Offset">Offset first character in the array to inspect.</param>
            <param name="Length">Number of characters to consider.</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null data array is passed</exception>
            <exception cref="T:System.FormatException">Thrown if an invalid char array is passed, or scale is out of range</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
            <param name="Offset">Offset of the first character in the array to inspect</param>
            <param name="Length">Number of characters to consider</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[])">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Char[],VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a character array representation of a BigDecimal into a BigDecimal,
            accepting the same sequence of characters as the BigDecimal(String)constructor,
            while allowing a sub-array to be specified and with rounding according to the context settings.
            <para>Note that if the sequence of characters is already available within a character array,
            using this constructor is faster than converting the char array to string and using the BigDecimal(String) constructor.</para>
            </summary>
            
            <param name="Data">The source of characters used to build the BigDecimal</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)">
            <summary>
            Translates a string representation of a BigDecimal into a BigDecimal
            </summary>
            
            <param name="Value">The source string used to build the BigDecimal</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Translates a string representation of a BigDecimal into a BigDecimal
            </summary>
            
            <param name="Value">The source string used to build the BigDecimal</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Double)">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance</param>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
            
            <exception cref="T:System.FormatException">Thown if <paramref name="Value"/> is infinity or not a number.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Double,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance.</param>
            <param name="Context">The context to use</param>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32)">
            <summary>
            Constructs a new BigDecimal instance from a given unscaled value and a given scale.
            <para>The value of this instance is 10^-scale</para>
            </summary>
            
            <param name="UnscaledValue">Representing the unscaled value of this BigDecimal instance</param>
            <param name="Scale">Scale of this BigDecimal instance</param>
            
            <exception cref="T:System.NullReferenceException">Throws if UnscaledValue == null</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from a given unscaled value and a given scale.
            <para>The value of this instance is 10^(-scale). 
            The result is rounded according to the specified math context</para>
            </summary>
            
            <param name="UnscaledValue">Representing the unscaled value of this BigDecimal instance</param>
            <param name="Scale">Scale of this BigDecimal instance</param>
            <param name="Context">The context to use</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32)">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0. The result is rounded according to the specified math context.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64)">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.
            The result is rounded according to the specified math context.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int64,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class.
            </summary>
            
            <param name="SmallValue">The small value</param>
            <param name="Scale">The scale</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class.
            </summary>
            
            <param name="SmallValue">The small value</param>
            <param name="Scale">The scale</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Abs">
            <summary>
            Returns a new BigDecimal whose value is the absolute value of this.
            <para>The scale of the result is the same as the scale of Abs(this).</para>
            </summary>
            
            <returns>
            <c>Abs(this)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Abs(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the absolute value of this.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>Abs(this)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Add(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Adds a value to the current instance of <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Augend">The value to be added to this instance</param>
            
            <returns>
            Returns a new BigDecimal whose value is <c>this + <paramref name="Augend"/></c>.
            </returns>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the given <paramref name="Augend"/> is <c>null</c>.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Add(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Adds a value to the current instance of <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Augend">The value to be added to this instance</param>
            <param name="Context">The rounding mode and precision for the result of this operation</param>
            
            <returns>
            Returns a new BigDecimal whose value is <c>this + <paramref name="Augend"/></c>.
            </returns>
            
            <exception cref="T:System.ArgumentNullException">Thrown if the given <paramref name="Augend"/> or <paramref name="Context"/> is <c>null</c>.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.AddAndMult10(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32)">
            <summary>
            Add and Multiply by 10
            </summary>
            
            <param name="Value">The value to add and multiply</param>
            <param name="Augend">The value to be added</param>
            <param name="DiffScale">The differential scale</param>
            
            <returns>
            The result of the Add and Multiply operation
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.CompareTo(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Compares this BigDecimal with Value.
            <para>Returns one of the three values 1, 0, or -1.
            The method behaves as if Subtract(Value) is computed.
            If this difference is > 0 then 1 is returned, if the difference is &lt; 0 then -1 is returned, 
            and if the difference is 0 then 0 is returned.
            This means, that if two decimal instances are compared which are equal in value but differ in scale, 
            then these two instances are considered as equal.</para>
            </summary>
            <param name="Value">Value to be compared with this</param>
            
            <returns>
            ReturnS 1 if this > Value, -1 if this &lt; Value, 0 if this == Value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the difference of the scales of this and Divisor.
            If the exact result requires more digits, then the scale is adjusted accordingly.
            For example, <c>1/128 = 0.0078125</c> which has a scale of 7 and precision 5.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0 or the result cannot be represented exactly.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The result is rounded according to the passed context.
            If the passed math context specifies precision 0, then this call is equivalent to <c>Divide(Divisor)</c></para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this / divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the scale of this.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
            
            <exception cref="T:System.ArgumentException">Thrown if an invalid rounding mode is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32,System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>As scale of the result the parameter Scale is used.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Scale">The scale of the result returned</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>The scale of the result is the scale of this.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Divide(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal whose value is <c>this / divisor</c>.
            <para>As scale of the result the parameter Scale is used.
            If rounding is required to meet the specified scale, then the specified rounding mode is applied.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Scale">The scale of the result returned</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            <c>this / divisor</c> rounded according to the given rounding mode
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a BigDecimal array which contains the integral part of <c>this / divisor</c> at index 0 and the remainder <c>this % divisor</c> at index 1. 
            <para>The quotient is rounded down towards zero to the next integer.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            DivideToIntegralValue(Divisor), Remainder(divisor)]
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideAndRemainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a BigDecimal array which contains the integral part of <c>this / divisor</c> at index 0 and the remainder at index 1.
            <para>The quotient is rounded down towards zero to the next integer.
            The rounding mode passed with the parameter Context is not considered.
            But if the precision of Context > 0 and the integral part requires more digits, then an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Math context which determines the maximal precision of the result</param>
            
            <returns>
            [DivideToIntegralValue(Divisor), Remainder(Divisor)]
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideToIntegralValue(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is the integral part of <c>this / divisor</c>.
            <para>The quotient is rounded down towards zero to the next integer.
            For example, <c>0.5/0.2 = 2</c>.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            Integral part of <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if Divisor == 0</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideToIntegralValue(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the integral part of <c>this / divisor</c>.
            <para>The quotient is rounded down towards zero to the next integer.
            The rounding mode passed with the parameter Context is not considered.
            But if the precision of <c>Context &gt; 0</c> and the integral part requires more digits, 
            then an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Math context which determines the maximal precision of the result</param>
            
            <returns>
            Integral part of <c>this / divisor</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if quotient won't fit in 'Context.Precision()' digits </exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Max(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns the maximum of this BigDecimal and Value
            </summary>
            
            <param name="Value">Value to be used to compute the maximum with</param>
            
            <returns>
            <c>Max(this, Value)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Min(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns the minimum of this BigDecimal and Value
            </summary>
            
            <param name="Value">Value to be used to compute the minimum with</param>
            
            <returns>
            <c>Min(this, val)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePointLeft(System.Int32)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved N places to the left.
            <para>If <c>N &lt; 0</c> then the decimal point is moved -N places to the right.
            The result is obtained by changing its scale.
            If the scale of the result becomes negative, then its precision is increased such that the scale is zero.
            Note, that MovePointLeft(0) returns a result which is mathematically equivalent, but which has scale >= 0.</para>
            </summary>
            
            <param name="N">Number of places the decimal point has to be moved</param>
            
            <returns>
            <c>this * 10^(-N)</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePointRight(System.Int32)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved N places to the right. 
            <para>If N &lt; 0 then the decimal point is moved -N places to the left.
            The result is obtained by changing its scale.
            If the scale of the result becomes negative, then its precision is increased such that the scale is zero.
            Note, that MovePointRight(0) returns a result which is mathematically equivalent, but which has scale >= 0.</para>
            </summary>
            
            <param name="N">Number of placed the decimal point has to be moved</param>
            
            <returns>
            <c>this * 10^n</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * Multiplicand</c>.
            <para>The scale of the result is the sum of the scales of the two arguments</para>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            
            <returns>
            <c>this * Multiplicand</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * multiplicand</c>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="Multiplicand">Value to be multiplied with this</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this * multiplicand</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Negate">
            <summary>
            Returns a new BigDecimal whose value is the <c>-this</c>.
            </summary>
            
            <returns>
            <c>-this</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Negate(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is the <c>-this</c>.
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            The result is <c>-this</c> rounded according to the passed context
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Plus">
            <summary>
            Returns a new BigDecimal whose value is <c>+this</c>.
            </summary>
            
            <returns>
            <c>+this</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Plus(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>+this</c>.
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>+this</c> rounded according to the passed context 
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Pow(System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this ^ N</c>.
            <para>The scale of the result is N times the scales of this.
            <c>x.pow(0)</c> returns 1, even if x == 0.</para>
            </summary>
            
            <param name="N">Exponent to which this is raised</param>
            
            <returns>
            <c>this ^ N</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if <c>N &lt; 0</c> or <c>N &gt; 999999999</c></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Pow(System.Int32,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this ^ N</c>.
            <para>The result is rounded according to the passed context.</para>
            </summary>
            
            <param name="N">Exponent to which this is raised</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this ^ N</c>
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if <c>N &lt; 0</c> or <c>N &gt; 999999999</c></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this % divisor</c>.
            <para>The remainder is defined as <c>this - DivideToIntegralValue(Divisor) * Divisor</c>.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            
            <returns>
            <c>this % divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Remainder(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is <c>this % divisor</c>.
            <para>The remainder is defined as <c>this - DivideToIntegralValue(Divisor) * Divisor</c>.
            The specified rounding mode Context is used for the division only.</para>
            </summary>
            
            <param name="Divisor">Value by which this is divided</param>
            <param name="Context">Rounding mode and precision to be used</param>
            
            <returns>
            <c>this % divisor</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Round(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal whose value is this, rounded according to the passed context.
            <para>If Context.Precision = 0, then no rounding is performed.
            If Context.Precision and Context.RoundingMode == UNNECESSARY, then an ArithmeticException 
            is thrown if the result cannot be represented exactly within the given precision.</para>
            </summary>
            
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            This rounded according to the passed context
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ScaleByPowerOfTen(System.Int32)">
            <summary>
            Returns a new BigDecimal whose value is <c>this 10^ N</c>.
            <para>The scale of the result is Scale() - N.
            The precision of the result is the precision of this.
            This method has the same effect as MovePointRight, except that the precision is not changed.</para>
            </summary>
            
            <param name="N">Number of places the decimal point has to be moved</param>
            
            <returns>
            <c>this 10^ N</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            If the new scale is smaller than the old scale, then trailing zeros are removed.
            If the trailing digits are not zeros then an ArithmeticException is thrown.
            If no exception is thrown, then the following equation holds: <c>x.SetScale(s).CompareTo(x) == 0</c>.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            
            <returns>
            A new BigDecimal instance with the specified scale.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            If the new scale is smaller than the old scale, then trailing digits are removed.
            In this case no rounding is necessary.
            If these trailing digits are not zero, then the remaining unscaled value has to be rounded.
            For this rounding operation the specified rounding mode is used.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            <param name="RoundingMode">Rounding mode to be used to round the result</param>
            
            <returns>
            A new BigDecimal instance with the specified scale
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetScale(System.Int32,System.Int32)">
            <summary>
            Returns a new BigDecimal instance with the specified scale.
            <para>If the new scale is greater than the old scale, then additional zeros are added to the unscaled value.
            In this case no rounding is necessary.
            If the new scale is smaller than the old scale, then trailing digits are removed.
            If these trailing digits are not zero, then the remaining unscaled value has to be rounded.
            For this rounding operation the specified rounding mode is used.</para>
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            <param name="RoundMode">Rounding mode to be used to round the result</param>
            
            <returns>
            A new BigDecimal instance with the specified scale
            </returns>
            
            <exception cref="T:System.ArgumentException">Thrown if RoundMode is not a valid rounding mode</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Signum">
            <summary>
            Returns the sign of this BigDecimal
            </summary>
            
            <returns>
            Returns <c>-1</c> if <c>this &lt; 0</c>, <c>0</c> if <c>this == 0</c>, <c>1</c> if <c>this &gt; 0</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.StripTrailingZeros">
            <summary>
            Returns a new BigDecimal instance with the same value as this but with a 
            unscaled value where the trailing zeros have been removed.
            <para>If the unscaled value of this has n trailing zeros, 
            then the scale and the precision of the result has been reduced by n.
            </para>
            </summary>
            
            <returns>
            A new BigDecimal instance equivalent to this where the trailing zeros of the unscaled value have been removed
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this - subtrahend</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            
            <returns>
            <c>this - subtrahend</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Subtract(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            Returns a new BigDecimal}whose value is <c>this - subtrahend</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="Subtrahend">Value to be subtracted from this</param>
            <param name="Context">Rounding mode and precision for the result of this operation</param>
            
            <returns>
            <c>this - subtrahend</c>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToBigInteger">
            <summary>
            Returns this BigDecimal as a big integer instance.
            <para>A fractional part is discarded.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a big integer instance
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToBigIntegerExact">
            <summary>
            Returns this BigDecimal as a big integer instance if it has no fractional part.
            <para>If this BigDecimal has a fractional part, i.e. if rounding would be necessary, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            this BigDecimal as a big integer value
            </returns>
            
            <exception cref="T:System.ArithmeticException">Thrown if rounding is necessary</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToByteExact">
            <summary>
            Returns this BigDecimal as a byte value if it has no fractional part and 
            if its value fits to the byte range ([-128..127]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a byte value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToDouble">
            <summary>
            Returns this BigDecimal as a double value.
            <para>If this is too big to be represented as an float, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a double value
            </returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 53 significant digits, 
            then this decimal cannot be represented exactly in a double variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be 
            represented exactly as a double, and thus <c>x1.Equals(new BigDecimal(x1.ToDouble())</c> 
            returns false for this case.
            Similarly, if the instance <c>new BigDecimal(9007199254740993L)</c>c> is converted to a double, 
            the result is 9.007199254740992E15.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToEngineeringString">
            <summary>
            Returns a string representation of this BigDecimal.
            <para>This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - Precision >= 6 then engineering notation is used.
            Engineering notation is similar to the scientific notation except that the exponent is made to be a multiple of 3 such that the integer part is >= 1 and &lt; 1000.</para>
            </summary>
            
            <returns>
            Returns a string representation of this in engineering notation if necessary
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt16Exact">
            <summary>
            Returns this BigDecimal as a short value if it has no fractional part 
            and if its value fits to the short range ([-2^{15}..2^{15}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a short value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt32">
            <summary>
            Returns this BigDecimal as an int value.
            <para>If the integral part of this is too big to be represented as an int, then this % 2^32 is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as an int value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt32Exact">
            <summary>
            Returns this BigDecimal as an int value. Any fractional part is discarded.
            <para>Returns this BigDecimal as a int value if it has no fractional part and if 
            its value fits to the int range ([-2^{31}..2^{31}-1]).
            If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            This BigDecimal as a int value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt64">
            <summary>
            Returns this BigDecimal as an long value. Any fractional part is discarded.
            <para>If the integral part of this is too big to be represented as an long, then this % 2^64 is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a long value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToInt64Exact">
            <summary>
            Returns this BigDecimal as a long value if it has no fractional part and if its value fits to the int range ([-2^{63}..2^{63}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <returns>
            this BigDecimal as a long value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToPlainString">
            <summary>
            Returns a string representation of this BigDecimal.
            <para>No scientifi notation is used. This methods adds zeros where necessary.
            If this string representation is used to create a new instance, 
            this instance is generally not identical to this as the precision changes.
            <c>x.Equals(new BigDecimal(x.ToPlainString())</c> usually returns false.
            <c>x.CompareTo(new BigDecimal(x.ToPlainString())} returns 0</c></para>
            </summary>
            
            <returns>
            A string representation of this without exponent part.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToSingle">
            <summary>
            Returns this BigDecimal as a float value.
            <para>If this is too big to be represented as an float, 
            then Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <returns>
            Returns this BigDecimal as a float value
            </returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 24 significant digits, 
            then this decimal cannot be represented exactly in a float variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be represented exactly as a float, 
            and thus <c>x1.Equals(new BigDecimal(x1.FloatValue())</c> returns false for this case.
            Similarly, if the instance <c>new BigDecimal(16777217)</c> is converted to a float, the result is 1.6777216E7.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Ulp">
            <summary>
            Returns the unit in the last place (ULP) of this BigDecimal instance.
            <para>An ULP is the distance to the nearest big decimal with the same precision.</para>para>
            </summary>
            
            <returns>
            Returns unit in the last place (ULP) of this BigDecimal instance
            </returns>
            
            <remarks>
            <para>The amount of a rounding error in the evaluation of a floating-point operation is 
            often expressed in ULPs. An error of 1 ULP is often seen as a tolerable error.
            For class BigDecimal, the ULP of a number is simply 10^(-scale).
            For example, {@code new BigDecimal(0.1).ulp()} returns {@code 1E-55}.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Double)">
            <summary>
            Returns a new BigDecimal instance whose value is equal to value.
            <para>The new decimal is constructed as if the BigDecimal(String) constructor is called
            with an argument which is equal to Double.toString(val). 
            For example, ValueOf("0.1")} is converted to (unscaled=1, scale=1), although the double 0.1 cannot be
            represented exactly as a double value. In contrast to that, a new BigDecimal(0.1) instance has the value 
            0.1000000000000000055511151231257827021181583404541015625 with an unscaled value 
            1000000000000000055511151231257827021181583404541015625}and the scale 55.</para>
            </summary>
            
            <param name="Value">Double value to be converted to a {@code BigDecimal</param>
            
            <returns>
            BigDecimal instance with the value 
            </returns>
            
            <exception cref="T:System.FormatException">Thrown if Value is infinite or not a number</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Int64)">
            <summary>
            Returns a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance whose value is equal to <paramref name="UnscaledVal"/>. 
            <para>The scale of the result is <c>0</c>, and its unscaled value is <paramref name="UnscaledVal"/>.</para>
            </summary>
            
            <param name="UnscaledVal">The value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/></param>
            <returns>
            Returns a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance with the value <paramref name="UnscaledVal"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueOf(System.Int64,System.Int32)">
            <summary>
            Returns a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance whose value is equal to 
            <paramref name="UnscaledVal"/> 10^(-<paramref name="Scale"/>). 
            <para>The scale of the result is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale"/>, and its unscaled value is <see cref="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue"/>.</para>
            </summary>
            
            <param name="UnscaledVal">The unscaled value to be used to construct the new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/></param>
            <param name="Scale">The scale to be used to construct the new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>.</param>
            
            <returns>
            Returns a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance with the value <c>UnscaledVal * 10^(-scale)</c>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.AproxPrecision">
            <summary>
            If the precision already was calculated it returns that value, otherwise it calculates a very good approximation efficiently .
            </summary>
            
            <returns>
            Returns an approximation of Precision() value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.BitLength(System.Int64)">
            <summary>
            The bit length
            </summary>
            
            <param name="SmallValue"> The small value</param>
            
            <returns>
            The <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.BitLength(System.Int32)">
            <summary>
            The bit length
            </summary>
            
            <param name="SmallValue">The small value</param>
            
            <returns>
            The <see cref="T:System.Int32"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DivideBigIntegers(VTDev.Libraries.CEXEngine.Numeric.BigInteger,VTDev.Libraries.CEXEngine.Numeric.BigInteger,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Divide big integers
            </summary>
            <param name="ScaledDividend">The scaled dividend</param>
            <param name="ScaledDivisor">The scaled divisor</param>
            <param name="Scale">The scale</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> remainder
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DividePrimitiveLongs(System.Int64,System.Int64,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Divide primitive longs
            </summary>
            
            <param name="ScaledDividend">The scaled dividend</param>
            <param name="ScaledDivisor">The scaled divisor</param>
            <param name="Scale">The scale</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/>
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.DoubleToLongBits(System.Double)">
            <summary>
            Convert a double to long
            </summary>
            
            <param name="Value">The value to convert</param>
            
            <returns>
            The long integer value
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetUnscaledValue">
            <summary>
            The get unscaled value
            </summary>
            <returns>
            The <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetZeroScaledBy(System.Int64)">
            <summary>
            It returns the value 0 with the most approximated scale of type int
            </summary>
            
            <param name="LongScale">The scale to which the value 0 will be scaled</param>
            
            <returns>
            The value 0 scaled by the closer scale of type int
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.InplaceRound(VTDev.Libraries.CEXEngine.Numeric.MathContext)">
            <summary>
            It does all rounding work of the public method Round(MathContext), performing an inplace rounding without creating a new object.
            </summary>
            
            <param name="Context">MathContext for perform the rounding</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsNaN(System.Double)">
            <summary>
            Test if the value is Not a Number
            </summary>
            
            <param name="Value">The value to test</param>
            
            <returns>True if NaN, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsNegativeZero(System.Double)">
            <summary>
            Test if the value is negative zero
            </summary>
            
            <param name="Value">The value to test</param>
            
            <returns>True if negative zero, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.IsZero">
            <summary>
            Is BigDecimal zero
            </summary>
            
            <returns>
            True if BigDecimal is zero, otherwise fals
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.LongCompareTo(System.Int64,System.Int64)">
            <summary>
            Compare two longs
            </summary>
            
            <param name="A">The first value</param>
            <param name="B">The second value</param>
            
            <returns>
            Returns 1 for A more than B, -1 for A less B, and 0 for equal
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.MovePoint(System.Int64)">
            <summary>
            Returns a new BigDecimal instance where the decimal point has been moved to the right based on the scale.
            </summary>
            
            <param name="NewScale">Scale of the result returned</param>
            
            <returns>
            BigDecimal
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.RoundingBehavior(System.Int32,System.Int32,VTDev.Libraries.CEXEngine.Numeric.RoundingModes)">
            <summary>
            Return an increment that can be -1, 0, or 1, depending of RoundingMode
            </summary>
            
            <param name="ParityBit">Can be 0 or 1, it's only used in the case HALF_EVEN</param>
            <param name="Fraction">The type of rounding Mantisa to be analyzed</param>
            <param name="RoundingMode">The rounding mode</param>
            
            <returns>
            Returns the carry propagated after rounding
            </returns>
            
            <exception cref="T:System.ArithmeticException"></exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SetUnscaledValue(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            The set unscaled value
            </summary>
            <param name="unscaledValue">
            The unscaled value
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.SmallRound(VTDev.Libraries.CEXEngine.Numeric.MathContext,System.Int32)">
            <summary>
            This method implements an efficient rounding for numbers which unscaled value fits in the type long.
            </summary>
            
            <param name="Context">The context to use</param>
            <param name="DiscardedPrecision">The number of decimal digits that are discarded</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToIntScale(System.Int64)">
            <summary>
            It tests if a scale of type long fits in 32 bits.
            It returns the same scale being casted to int type when is possible, otherwise throws an exception.
            </summary>
            
            <param name="LongScale">A 64 bit scale</param>
            <returns>
            A 32 bit scale when is possible
            </returns>
            
            <exception cref="T:System.ArithmeticException">Throws ArithmeticException when Scale doesn't fit in int type</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToStringInternal">
            <summary>
            The to string internal.
            </summary>
            <returns>
            The <see cref="T:System.String"/>.
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ValueExact(System.Int32)">
            <summary>
            Counts the number of bits of value and checks if it's out of the range of the primitive type.
            </summary>
            
            <param name="BitLengthOfType">umber of bits of the type whose value will be calculated</param>
            
            <returns>
            The exact value of the integer part of BigDecimal when is possible
            </returns>
            
            <exception cref="T:System.ArithmeticException">Throws if rounding is necessary or the number don't fit in the primitive type</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Equals(System.Object)">
            <summary>
            Returns true if Obj is a BigDecimal instance and if this instance is equal to this big decimal.
            <para>Two big decimals are equal if their unscaled value and their scale is equal.
            For example, <c>1.0 (10*10^(-1))</c> is not equal to <c>1.00 (100*10^(-2))</c>.
            Similarly, zero instances are not equal if their scale differs.</para>
            </summary>
            
            <param name="Obj">Object to be compared with this</param>
            
            <returns>
            Returns true if Obj is a BigDecimal and this == Obj
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.GetHashCode">
            <summary>
            Returns a hash code for this BigDecimal
            </summary>
            
            <returns>
            Hash code for this
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.ToString">
            <summary>
            Returns a canonical string representation of this BigDecimal.
            <para>If necessary, scientific notation is used.
            This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - precision >= 6 then scientific notation is used.</para>
            </summary>
            
            <returns>
            Returns a string representation of this in scientific notation if necessary
            </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> class
            </summary>
            
            <param name="Info">The info</param>
            <param name="Context">The context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            The get object data
            </summary>
            <param name="Info">The info</param>
            <param name="Context">The context</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Addition(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Add two <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> values.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns>Returns a new BigDecimal whose value is <c>A + B</c>.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Subtraction(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A - B</c>.
            <para>The scale of the result is the maximum of the scales of the two arguments.</para>
            </summary>
            
            <param name="A">The first value A</param>
            <param name="B">The second value B</param>
            
            <returns><c>A - B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Division(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A / B</c>.
            <para>The scale of the result is the difference of the scales of this and Divisor.
            If the exact result requires more digits, then the scale is adjusted accordingly.
            For example, <c>1/128 = 0.0078125</c> which has a scale of 7 and precision 5.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The divisor B</param>
            
            <returns><c>A / B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Modulus(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>A % B</c>.
            <para>The remainder is defined as <c>A - DivideToIntegralValue(B) * B</c>.</para>
            </summary>
            
            <param name="A">The value</param>
            <param name="B">The divisor</param>
            
            <returns><c>A % B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Multiply(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>this * Multiplicand</c>.
            <para>The scale of the result is the sum of the scales of the two arguments</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The multiplicand</param>
            
            <returns><c>A * B</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_UnaryPlus(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is <c>+A</c>.
            </summary>
            
            <param name="A">The value A</param>
            
            <returns><c>+A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_UnaryNegation(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns a new BigDecimal whose value is the <c>-A</c>.
            </summary>
            
            <param name="A">The value A</param>
            
            <returns><c>-A</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Equality(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if "A" is a BigDecimal instance and if this instance is equal to "B".
            <para>Two big decimals are equal if their unscaled value and their scale is equal.
            For example, 1.0 (10*10^(-1)) is not equal to 1.00 (100*10^(-2)).
            Similarly, zero instances are not equal if their scale differs.</para>
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if "B" is a BigDecimal and A == B</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Inequality(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is not equal to BigDecimal "B".
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A != B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_GreaterThan(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is more than BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A > B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_LessThan(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is less than BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A &lt; B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_GreaterThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is more than or equal to BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A >= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_LessThanOrEqual(VTDev.Libraries.CEXEngine.Numeric.BigDecimal,VTDev.Libraries.CEXEngine.Numeric.BigDecimal)">
            <summary>
            Returns true if BigDecimal value "A" is less than or equal to BigDecimal value "B"
            </summary>
            
            <param name="A">The value A</param>
            <param name="B">The value B</param>
            
            <returns>Returns true if <c>A &lt;= B</c>, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int16">
            <summary>
            Returns this BigDecimal as a short value if it has no fractional part 
            and if its value fits to the short range ([-2^{15}..2^{15}-1]).
            <para>If these conditions are not met, an ArithmeticException is thrown.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a short value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int32">
            <summary>
            Returns this BigDecimal as an int value.
            <para>If the integral part of this is too big to be represented as an int, then this % 2^32 is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as an int value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Int64">
            <summary>
            Returns this BigDecimal as an long value. Any fractional part is discarded.
            <para>If the integral part of this is too big to be represented as an long, then this % 2^64 is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a long value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Single">
            <summary>
            Returns this BigDecimal as a float value.
            <para>If this is too big to be represented as an float, 
            then Float.POSITIVE_INFINITY or Float.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a float value</returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 24 significant digits, 
            then this decimal cannot be represented exactly in a float variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be represented exactly as a float, 
            and thus <c>x1.Equals(new BigDecimal(x1.FloatValue())</c> returns false for this case.
            Similarly, if the instance <c>new BigDecimal(16777217)</c> is converted to a float, the result is 1.6777216E7.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.Double">
            <summary>
            Returns this BigDecimal as a double value.
            <para>If this is too big to be represented as an float, then Double.POSITIVE_INFINITY or Double.NEGATIVE_INFINITY is returned.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a double value</returns>
            
            <remarks>
            <para>Note, that if the unscaled value has more than 53 significant digits, 
            then this decimal cannot be represented exactly in a double variable.
            In this case the result is rounded.
            For example, if the instance <c>x1 = new BigDecimal("0.1")</c> cannot be 
            represented exactly as a double, and thus <c>x1.Equals(new BigDecimal(x1.ToDouble())</c> 
            returns false for this case.
            Similarly, if the instance <c>new BigDecimal(9007199254740993L)</c>c> is converted to a double, 
            the result is 9.007199254740992E15.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~VTDev.Libraries.CEXEngine.Numeric.BigInteger">
            <summary>
            Returns this BigDecimal as a big integer instance.
            <para>A fractional part is discarded.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns this BigDecimal as a BigInteger instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigDecimal)~System.String">
            <summary>
            Returns a canonical string representation of this BigDecimal.
            <para>If necessary, scientific notation is used.
            This representation always prints all significant digits of this value.
            If the scale is negative or if Scale - precision >= 6 then scientific notation is used.</para>
            </summary>
            
            <param name="X">The BigDecimal to convert</param>
            
            <returns>Returns a string representation of this in scientific notation if necessary</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Int64)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given long value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The long value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Double)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance from the 64bit double value. 
            <para>The constructed big decimal is equivalent to the given double.</para>
            </summary>
            
            <param name="Value">The double value to be converted to a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigDecimal"/> instance</param>
            
            <returns>A new BigDecimal instance</returns>
            
            <remarks>
            For example, <c>new BigDecimal(0.1)</c> is equal to <c>0.1000000000000000055511151231257827021181583404541015625</c>. 
            This happens as <c>0.1</c> cannot be represented exactly in binary.
            <para>To generate a big decimal instance which is equivalent to <c>0.1</c> use the <see cref="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.#ctor(System.String)"/> constructor.</para>
            </remarks>
            
            <exception cref="T:System.FormatException">Thown if <paramref name="Value"/> is infinity or not a number.</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(System.Int32)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given int value.
            <para>The scale of the result is 0.</para>
            </summary>
            
            <param name="Value">The int value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.op_Implicit(VTDev.Libraries.CEXEngine.Numeric.BigInteger)~VTDev.Libraries.CEXEngine.Numeric.BigDecimal">
            <summary>
            Constructs a new BigDecimal instance from the given BigInteger value.
            <para>The scale of the result is 0</para>
            </summary>
            
            <param name="Value">Value to be converted to a BigDecimal instance</param>
            
            <returns>A new BigDecimal instance</returns>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Precision">
            <summary>
            Returns the precision of this BigDecimal.
            <para>The precision is the number of decimal digits used to represent this decimal.
            It is equivalent to the number of digits of the unscaled value.
            The precision of 0 is 1 (independent of the scale).</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.Scale">
            <summary>
            Returns the scale of this BigDecimal.
            <para>The scale is the number of digits behind the decimal point.
            The value of this BigDecimal is the unsignedValue * 10^(-scale). 
            If the scale is negative, then this BigDecimal represents a big integer.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Numeric.BigDecimal.UnScaledValue">
            <summary>
            Returns the unscaled value (mantissa) of this BigDecimal instance as a BigInteger.
            <para>The unscaled value can be computed as this <c>10^(scale)</c>.</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo">
            <summary>
            A structure containing information about a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/> file.
            <para>Used to display statistics about a PackageKeys current state.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo.Description">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription"/> structure containing a complete description of the cipher instance.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo.Created">
            <summary>
            The creation date/time of this key
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo.Origin">
            <summary>
            The origin id as a Guid
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo.Tag">
            <summary>
            The package tag as a string
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo.SubKeyCount">
            <summary>
            The number of Key Sets contained in this key package file.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo.Policies">
            <summary>
            A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyPolicies">Policies</see> array that contains the set of policy flags
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo.Expiration">
            <summary>
            The date/time this key expires
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageInfo.#ctor(VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey)">
            <summary>
            Build the PackageInfo structure from a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.PackageKey"/> file
            </summary>
            
            <param name="Package">Populated PackageKey structure</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB">
            <summary>
            <h3>Implements a Output FeedBack Mode: OFB.</h3>
            <para>OFB as outlined in the NIST document: SP800-38A<cite>SP800-38A</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>ICipherMode</c> interface:</description>
            <code>
            using (ICipherMode cipher = new OFB(new RDX(), [DisposeEngine]))
            {
                // initialize for encryption
                cipher.Initialize(true, new KeyParams(Key, IV));
                // encrypt a block
                cipher.Transform(Input, Output);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Cipher Engine is automatically disposed of unless DisposeEngine is set to <c>false</c> in the class constructor <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.CBC.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)"/></description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST: <see href="http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf">SP800-38A</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.IBlockCipher,System.Boolean)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Cipher">Underlying encryption algorithm</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Dispose"/> on this class is called</param>
            
            <exception cref="T:System.ArgumentNullException">Thrown if a null Cipher is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the Cipher
            </summary>
            
            <param name="Encryption">Cipher is used. for encryption, false to decrypt</param>
            <param name="KeyParam">The KeyParams containing key and vector</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSymmetricException">Thrown if a null Key or IV is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Transform(System.Byte[],System.Byte[])">
            <summary>
            <para>Transform a block of bytes. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt/Decrypt</param>
            <param name="Output">Encrypted or Decrypted bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Transform(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            <para>Transform a block of bytes with offset parameters. 
            <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Initialize(System.Boolean,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> must be called before this method can be used.</para>
            </summary>
            
            <param name="Input">Bytes to Encrypt</param>
            <param name="InOffset">Offset in the Input array</param>
            <param name="Output">Encrypted bytes</param>
            <param name="OutOffset">Offset in the Output array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.BlockSize">
            <summary>
            Get: Unit block size of internal cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Engine">
            <summary>
            Get: Underlying Cipher
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.IsEncryption">
            <summary>
            Get: Initialized for encryption, false for decryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.IsInitialized">
            <summary>
            Get: Cipher is ready to transform data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.IV">
            <summary>
            Get: The current state of the initialization Vector
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.OFB.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom">
            <summary>
            <h3>An implementation of a Cryptographically Secure Pseudo Random Number Generator: SecureRandom.</h3> 
            
            <para>Uses the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class to generate non-negative random numbers.</para>
            </summary>
            
            <example>
            <c>
            int x;
            using (SecureRandom rnd = new SecureRandom())
                x = rnd.NextInt32();
            </c>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/04/28" version="1.4.0.0">Added thread safety</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.#ctor(System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="BufferSize">Size of the internal buffer; must be more than zero</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if a zero size buffer is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Reset">
            <summary>
            Reset the SecureRandom instance
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if RNGCryptoServiceProvider initialization failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextChar">
            <summary>
            Get a random char
            </summary>
            
            <returns>Random char</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.AnyDouble">
            <summary>
            Get a non-ranged random double
            </summary>
            
            <returns>Random double</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextDouble">
            <summary>
            Get a random double in the range 0.0 to 1.0
            </summary>
            
            <returns>Random double</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16(System.Int16)">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt16(System.Int16,System.Int16)">
            <summary>
            Get a random non-negative short integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <returns>Random UInt16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16(System.UInt16)">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt16</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt16(System.UInt16,System.UInt16)">
            <summary>
            Get a random unsigned short integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Next">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32(System.Int32)">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt32(System.Int32,System.Int32)">
            <summary>
            Get a random non-negative 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32">
            <summary>
            Get a random unsigned 32bit integer
            </summary>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32(System.UInt32)">
            <summary>
            Get a random unsigned integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt32(System.UInt32,System.UInt32)">
            <summary>
            Get a random unsigned integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64">
            <summary>
            Get a random long integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64(System.Int64)">
            <summary>
            Get a random long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextInt64(System.Int64,System.Int64)">
            <summary>
            Get a random long integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64(System.UInt64)">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.NextUInt64(System.UInt64,System.UInt64)">
            <summary>
            Get a random unsigned long integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random UInt64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBytes(System.Int32)">
            <summary>
            Gets bytes of pseudo random
            </summary>
            
            <param name="Size">Size of request</param>
            
            <returns>P-Rand bytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBytes(System.Byte[])">
            <summary>
            Gets bytes of pseudo random
            </summary>
            
            <param name="Data">Array to fill with pseudo random</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetChars(System.Int32)">
            <summary>
            Gets pseudo random chars
            </summary>
            
            <param name="Size">Size of request</param>
            
            <returns>P-Rand chars</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetByteRange(System.Int64)">
            <remarks>
            Returns the number of bytes needed to build 
            an integer existing within a byte range
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.GetBits(System.Byte[],System.Int64)">
            <remarks>
            If you need a dice roll, use the Random class (smaller range = reduced entropy)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.SecureRandom.Name">
            <summary>
            Get: Algorithm Name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">
            <summary>
            Wraps exceptions thrown within a PRNG Generators operational context.
            <para>This exception is used throughout the Prng and Seed classes.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException.#ctor(System.String,System.String)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException.#ctor(System.String,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
            
            <param name="Origin">The origin of the exception</param>
            <param name="Message">A custom message or error data</param>
            <param name="InnerException">The underlying exception</param>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException.Origin">
            <summary>
            The origin of the exception in the format Class:Method
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher">
            <summary>
            <h3>Volume cipher helper class.</h3>
            <para>A helper class used to encrypt or decrypt a series of files on a directory or volume.
            Note: If the cipher is for encryption, files are encrypted in place.
            If the cipher is for decryption, individual files or the entire directory can be decrypted.</para>
            </summary> 
            
            <example>
            <description>Example of encrypting and decrypting a Directory:</description>
            <code>
            public static void VolumeCipherTest(string InputDirectory)
            {
                string[] paths = DirectoryTools.GetFiles(InputDirectory);
            
                // set cipher paramaters
                CipherDescription desc = new CipherDescription(
                    Engines.RDX, 32,
                    IVSizes.V128,
                    CipherModes.CTR,
                    PaddingModes.X923,
                    BlockSizes.B128,
                    RoundCounts.R14,
                    Digests.Keccak512,
                    64,
                    Digests.Keccak512);
            
                // define the volume key
                VolumeKey vkey = new VolumeKey(desc, paths.Length);
                // key will be written to this stream
                MemoryStream keyStream = new MemoryStream();
            
                // create the volume key stream
                using (VolumeFactory vf = new VolumeFactory(keyStream))
                    vf.Create(vkey);
            
                // encrypt the files in the directory
                using (VolumeCipher vc = new VolumeCipher(true, keyStream))
                    vc.Transform(paths);
            
                // decrypt the files in the directory
                using (VolumeCipher vc = new VolumeCipher(false, keyStream))
                    vc.Transform(paths);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/05/22" version="1.3.6.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.CipherDescription">VTDev.Libraries.CEXEngine.Crypto.Processing.Structures CipherDescription Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode Interface</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">VTDev.Libraries.CEXEngine.Crypto.Engines Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Uses any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode">Cipher Mode</see> wrapped <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.SymmetricEngines">Block Ciphers</see>, or any of the implemented <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Stream.IStreamCipher">Stream Ciphers</see>.</description></item>
            <item><description>Cipher Engine can be Disposed when this class is Disposed, set the DisposeEngine parameter in the class Constructor to true to dispose automatically.</description></item>
            <item><description>Streams can be Disposed when the class is Disposed, set the DisposeStream parameter in the Initialize(Stream, Stream, bool) call to true to dispose automatically.</description></item>
            <item><description>Implementation has a Progress counter that returns total sum of bytes processed per either of the 'Transform()' calls.</description></item>
            <item><description>Changes to the Cipher or StreamCipher ParallelBlockSize must be set after initialization.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.#ctor(System.Boolean,System.IO.Stream)">
            <summary>
            Initialize the class with a CipherDescription Structure; containing the cipher implementation details, and a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class containing the Key material.
            <para>This constructor creates and configures cryptographic instances based on the cipher description contained in a CipherDescription. 
            Cipher modes, padding, and engines are destroyed automatically through this classes Dispose() method.</para>
            </summary>
            
            <param name="Encryption">Cipher is an encryptor</param>
            <param name="KeyStream">A stream containing a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey"/> and the keying material</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if an invalid <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Structure.VolumeKey"/> is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.Transform(System.String)">
            <summary>
            Encrypt or Decrypt the files in the specified directory
            </summary>
            
            <param name="DirectoryPath">The directory containing the files to be processed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.Transform(System.String[])">
            <summary>
            Encrypt or Decrypt the files in the specified directory
            </summary>
            
            <param name="FilePaths">A list of the files to be processed</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if the VolumeKey does not contain enough keys to encrypt all the files in the directory</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ErrorNotification">
            <summary>
            Error Notification; alerts the caller to an error condition that has not halted processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.IsParallel">
            <summary>
            Get/Set: Automatic processor parallelization
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ParallelBlockProfile">
            <summary>
            Get/Set: Determines how the size of a parallel block is calculated; using the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.BlockProfiles">Block Profiles</see>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ParallelBlockSize">
            <summary>
            Get/Set: Parallel block size. Must be a multiple of <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ParallelMinimumSize"/>.
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoProcessingException">Thrown if a parallel block size is not evenly divisible by ParallelMinimumSize, 
            or the size is less than ParallelMinimumSize or more than ParallelMaximumSize values</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ParallelMaximumSize">
            <summary>
            Get: Maximum input size with parallel processing
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ParallelMinimumSize">
            <summary>
            Get: The smallest parallel block size. Parallel blocks must be a multiple of this size.
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ProcessorCount">
            <summary>
            Get: The system processor count
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.BlockProfiles">
            <summary>
            ParallelBlockProfile enumeration
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.BlockProfiles.ProgressProfile">
            <summary>
            Set parallel block size as a division of 100 segments
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.BlockProfiles.SpeedProfile">
            <summary>
            Set parallel block size for maximum possible speed
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Processing.VolumeCipher.NotificationDelegate">
            <summary>
            Error notification delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="message">The bnature of the error</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng">
            <summary>
            <h3>CTRPrng: An implementation of a Encryption Counter based Deterministic Random Number Generator.</h3>
            <para>A Block Cipher Counter DRBG as outlined in NIST document: SP800-90A<cite>SP800-90B</cite></para>
            </summary> 
            
            <example>
            <description>Example using an <c>IRandom</c> interface:</description>
            <code>
            int num;
            using (IRandom rnd = new CTRPrng([BlockCiphers], [SeedGenerators]))
            {
                // get random int
                num = rnd.Next([Minimum], [Maximum]);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/09" version="1.4.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block">VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block Namespace</seealso>
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Seed">VTDev.Libraries.CEXEngine.Crypto.Seed ISeed Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers">VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Can be initialized with any block <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers">cipher</see>.</description></item>
            <item><description>Can use either a random seed generator for initialization, or a user supplied Seed array.</description></item>
            <item><description>Numbers generated with the same seed will produce the same random output.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NIST SP800-90B: <see href="http://csrc.nist.gov/publications/drafts/800-90/draft-sp800-90b.pdf">Recommendation for the Entropy Sources Used for Random Bit Generation</see>.</description></item>
            <item><description>NIST Fips 140-2: <see href="http://csrc.nist.gov/publications/fips/fips140-2/fips1402.pdf">Security Requirments For Cryptographic Modules</see>.</description></item>
            <item><description>NIST SP800-22 1a: <see href="http://csrc.nist.gov/groups/ST/toolkit/rng/documents/SP800-22rev1a.pdf">A Statistical Test Suite for Random and Pseudorandom Number Generators for Cryptographic Applications</see>.</description></item>
            <item><description>Security Bounds for the NIST Codebook-based: <see href="http://eprint.iacr.org/2006/379.pdf">Deterministic Random Bit Generator</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.#ctor(VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers,VTDev.Libraries.CEXEngine.Crypto.Enumeration.SeedGenerators,System.Int32,System.Int32)">
            <summary>
            Initialize the class
            </summary>
            
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="SeedEngine">The Seed engine used to create keyng material (default is CSPRsg)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            <param name="KeySize">The key size (in bytes) of the symmetric cipher; a <c>0</c> value will auto size the key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.#ctor(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Enumeration.BlockCiphers,System.Int32)">
            <summary>
            Initialize the class with a Seed; note: the same seed will produce the same random output
            </summary>
            
            <param name="Seed">The Seed bytes used to initialize the digest counter; (min. length is key size + counter 16)</param>
            <param name="BlockEngine">The block cipher that powers the rng (default is RDX)</param>
            <param name="BufferSize">The size of the cache of random bytes (must be more than 1024 to enable parallel processing)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if the seed is null or too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong">
            <summary>
            Get a pseudo random 64bit integer
            </summary>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Reset">
            <summary>
            Reset the CTRPrng instance
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CTRPrng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators">
            <summary>
            Random Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.CTRDrbg">
            <summary>
            An implementation of a Encryption Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.DGCDrbg">
            <summary>
            An implementation of a Digest Counter based DRBG
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.HKDF">
            <summary>
            A Hash based Key Derivation Function HKDF
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.KDF2Drbg">
            <summary>
            An implementation of a Hash based Key Derivation Function PBKDF2
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.PKCS5">
            <summary>
            An implementation of a Hash based Key Derivation PKCS#5 Version 2
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Generators.SP20Drbg">
            <summary>
            An implementation of a Salsa20 Counter based DRBG
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator">
             <summary>
             An Generalized Merkle Signature Scheme Signature Scheme Key-Pair Generator
             </summary>
            
             <example>
             <description>Example of creating a keypair:</description>
             <code>
             GMSSKeyGenerator encParams = (GMSSParameters)GMSSParamSets.GMSSN2P10.DeepCopy();
             GMSSKeyGenerator keyGen = new GMSSKeyGenerator(encParams);
             IAsymmetricKeyPair keyPair = keyGen.GenerateKeyPair();
             </code>
             </example>
             
             <revisionHistory>
             <revision date="2015/07/06" version="1.4.0.0">Initial release</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSSign">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSSign Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSPublicKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS GMSSPrivateKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Prngs Enumeration</seealso>
             
             <remarks>
             <description><h4>Guiding Publications:</h4></description>
             <list type="number">
             <item><description>Selecting Parameters for the Generalized Merkle Signature Scheme Signature Scheme<cite>Generalized Merkle Signature Scheme Parameters</cite>.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CiphersParams">The GMSSParameters instance containing the cipher settings</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if a Prng that requires pre-initialization is specified; (wrong constructor)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Use an initialized prng to generate the key; use this constructor with an Rng that requires pre-initialization, i.e. PBPrng
            </summary>
            
            <param name="CiphersParams">The GMSSParameters instance containing the cipher settings</param>
            <param name="RngEngine">An initialized random generator instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.GenerateKeyPair">
            <summary>
            Generate an encryption Key pair
            </summary>
            
            <returns>A GMSSKeyPair containing public and private keys</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.GenerateCurrentAuthpathAndRoot(System.Byte[],System.Collections.Generic.List{System.Byte[]},System.Byte[],System.Int32)">
            <summary>
            Calculates the authpath for tree in layer h which starts with seed[h] additionally computes the rootSignature of underlaying root
            </summary>
            
            <param name="LowerRoot">Stores the root of the lower tree</param>
            <param name="CurrentStack">Stack used for the treehash instance created by this method</param>
            <param name="Seed">Starting seeds</param>
            <param name="H">Actual layer</param>
            <returns>An initialized GMSSRootCalc</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.GenerateNextAuthpathAndRoot(System.Collections.Generic.List{System.Byte[]},System.Byte[],System.Int32)">
            <summary>
            Calculates the authpath and root for tree in layer h which starts with seed[h]
            </summary>
            
            <param name="NextStack">Stack used for the treehash instance created by this method</param>
            <param name="Seed">Starting seeds</param>
            <param name="H">Actual layer</param>
            
            <returns>An initialized GMSSRootCalc</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.Initialize">
            <summary>
            Initalizes the key pair generator using a parameter set as input
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.GMSSKeyGenerator.Name">
            <summary>
            Get: Generator name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig">
            <summary>
            This class implements the distributed signature generation of the Winternitz
            one-time signature scheme (OTSS), described in C.Dods, N.P. Smart, and M.
            Stam, "Hash Based Digital Signature Schemes", LNCS 3796, pages 96&#8211;115,
            2005. The class is used by the GMSS classes.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Byte[][],System.Int32[])">
            <summary>
            This constructor regenerates a prior GMSSRootSig object used by the GMSSPrivateKeyASN.1 class
            </summary>
            
            <param name="Digest">The hash function</param>
            <param name="StatByte">The status byte array</param>
            <param name="StatInt">The status int array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.#ctor(VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest,System.Int32,System.Int32)">
            <summary>
            The constructor generates the PRNG and initializes some variables
            </summary>
            
            <param name="Digest">The hash function</param>
            <param name="W">The winternitz parameter</param>
            <param name="Height">The heigth of the tree</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.InitSign(System.Byte[],System.Byte[])">
            <summary>
            This method initializes the distributed sigature calculation.
            Variables are reseted and necessary steps are calculated.
            </summary>
            
            <param name="Seed">The initial OTSseed</param>
            <param name="Message">The massage which will be signed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.UpdateSign">
            <summary>
            This Method performs <c>steps</c> steps of distributed signature calculaion
            </summary>
            
            <returns>Return true if signature is generated completly, else false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.GetSig">
            <summary>
            Return private OTS key
            </summary>
            
            <returns>The private OTS key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.OneStep">
            <summary>
            Return The one-time signature of the message, generated step by step
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.GetLog(System.Int32)">
            <summary>
            This method returns the least integer that is greater or equal to the logarithm to the base 2 of an integer <c>Value</c>
            </summary>
            
            <param name="Value">An integer</param>
            
            <returns>The least integer greater or equal to the logarithm to the base 2 of <c>Value</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.GetStatByte">
            <summary>
            This method returns the status byte array
            </summary>
            
            <returns>Return statBytes</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.GetStatInt">
            <summary>
            This method returns the status int array
            </summary>
            
            <returns>Return statInt</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.GetStatLong">
            <summary>
            Converts the long parameters into byte arrays to store it in statByte array
            </summary>
            
            <returns>Return statByte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.GMSS.Arithmetic.GMSSRootSig.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey">
            <summary>
            An NTRU Public Key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Int32,System.Int32)">
            <summary>
            Constructs a new public key from a polynomial
            </summary>
            
            <param name="H">The polynomial <c>H</c> which determines the key</param>
            <param name="N">The number of coefficients in the polynomial <c>H</c></param>
            <param name="Q">The "big" NtruEncrypt modulus</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.#ctor(System.IO.Stream)">
            <summary>
            Read a Public Key from a Stream
            </summary>
            
            <param name="KeyStream">An input stream containing an encoded key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be loaded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.#ctor(System.Byte[])">
            <summary>
            Read a Public Key from a byte array
            </summary>
            
            <param name="KeyArray">The encoded key array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.From(System.Byte[])">
            <summary>
            Read a Public key from a byte array
            </summary>
            
            <param name="KeyArray">The byte array containing the encoded key</param>
            
            <returns>An initialized NTRUPublicKey class</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.From(System.IO.MemoryStream)">
            <summary>
            Read a Public key from a stream
            </summary>
            
            <param name="KeyStream">The stream containing the encoded key</param>
            
            <returns>An initialized NTRUPublicKey class</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the stream can not be read</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.ToBytes">
            <summary>
            Converts the Public key to an encoded byte array
            </summary>
            
            <returns>The encoded NTRUPublicKey</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.ToStream">
            <summary>
            Converts the Public key to an encoded MemoryStream
            </summary>
            
            <returns>The Public Key encoded as a MemoryStream</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.WriteTo(System.Byte[])">
            <summary>
            Writes the encoded NTRUPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded as a byte array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Writes the encoded NTRUPublicKey to an output byte array
            </summary>
            
            <param name="Output">The Public Key encoded to a byte array</param>
            <param name="Offset">The starting position within the Output array</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.WriteTo(System.IO.Stream)">
            <summary>
            Writes the encoded NTRUPublicKey to an output stream
            </summary>
            
            <param name="Output">The Output Stream receiving the encoded Public Key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the key could not be written</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.GetHashCode">
            <summary>
            Get the hash code for this object
            </summary>
            
            <returns>Hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Equals(System.Object)">
            <summary>
            Compare this object instance with another
            </summary>
            
            <param name="Obj">Object to compare</param>
            
            <returns>True if equal, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Clone">
            <summary>
            Create a shallow copy of this NTRUPublicKey instance
            </summary>
            
            <returns>NTRUPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.DeepCopy">
            <summary>
            Create a deep copy of this NTRUPublicKey instance
            </summary>
            
            <returns>The NTRUPublicKey copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Name">
            <summary>
            Get: Private key name
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.N">
            <summary>
            The number of coefficients in the polynomial <c>H</c>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.Q">
            <summary>
            The big Q modulus
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey.H">
            <summary>
            The polynomial <c>H</c> which determines the key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt">
            <summary>
            An NTRU asymmetric cipher implementation
            </summary>
            
            <example>
            <description>Example of encryption/decryption of plain text:</description>
            <code>
            // use a predefined parameter set
            NtruParameters prm = NTRUParamSets.APR2011743FAST;
            NtruKeyPair keyPair;
            byte[] enc, dec;
            byte[] data = new byte[64];
            
            // generate a key pair
            using (NTRUKeyGenerator gen = new NTRUKeyGenerator(prm))
                NtruKeyPair keyPair = gen.GenerateKeyPair();
            
            // encrypt a message
            using (NtruEncrypt ntru = new NtruEncrypt(ps))
            {
                // initialize with public key for encryption
                ntru.Initialize(keyPair.PublicKey);
                // encrypt using public key
                enc = ntru.Encrypt(data);
            }
            
            // decrypt a message
            using (NtruEncrypt ntru = new NtruEncrypt(ps))
            {
                // initialize with both keys for decryption
                ntru.Initialize(keyPair);
                // decrypt using key pair
                dec = ntru.Decrypt(enc);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.0.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUKeyPair Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUParameters Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricCipher Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h4>Basic Operations:</h4></description>
            
            <description><h5>Encryption</h5></description>
            <list type="table">
            <item><description>Randomly select a small polynomial <c>r  Dr</c>.</description></item>
            <item><description>Calculate the ciphertext e as <c>e  r  h+m (mod q)</c>.</description></item>
            </list>
            
            <description><h5>Decryption:</h5></description>
            <list type="table">
            <item><description>Calculate <c>a  center(f  e)</c>, where the centering operation center reduces its input into the interval <c>[A,A+q1]</c>.</description></item>
            <item><description>Recover m by calculating <c>m  fp  a (mod p)</c>.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NTRU: A Ring Based Public Key Crypto System<cite>NTRU Crypto</cite>.</description></item>
            <item><description>Optimizations for NTRU<cite>NTRU Optimizations</cite>.</description></item>
            <item><description>Adaptive Key Recovery Attacks on NTRU-based Somewhat Homomorphic Encryption Schemes<cite>NTRU Adaptive</cite>.</description></item>
            <item><description>Efficient Embedded Security Standards (EESS)<cite>NTRU EESS</cite>.</description></item>
            <item><description>Practical lattice-based cryptography: NTRUEncrypt and NTRUSign<cite>NTRU Practical</cite>.</description></item>
            <item><description>NTRU Cryptosystems Technical Report<cite>NTRU Technical</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent java project NTRU Encrypt by Tim Buktu: <see href="https://github.com/tbuktu/ntru/description">Release 1.2</see>, and
            the NTRUOpenSourceProject/ntru-crypto project provided by Security Innovation, Inc: <see href="https://github.com/NTRUOpenSourceProject/ntru-crypto">Release 1.2</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters)">
            <summary>
            Constructs a new instance with a set of encryption parameters
            </summary>
            
            <param name="NtruParams">Encryption parameters</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Decrypt(System.Byte[])">
            <summary>
            Decrypts a message
            </summary>
            
            <param name="Input">The message to decrypt</param>
            
            <returns>The decrypted message</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">If not initialized, the specified hash algorithm is invalid, the encrypted data is invalid, or <c>MaxLenBytes</c> is greater than 255</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Encrypt(System.Byte[])">
            <summary>
            Encrypts a message
            </summary>
            
            <param name="Input">The message to encrypt</param>
            
            <returns>The encrypted message</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">If not initialized, the specified hash algorithm is invalid, the encrypted data is invalid, or <c>maxLenBytes</c> is greater than 255</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GenerateSalt(System.Int32)">
            <summary>
            A convenience method that generates a random salt vector for key pair generation.
            </summary>
            
            <param name="Size">Byte length of the new salt</param>
            
            <returns>A new salt vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher for Encryption; This Initialize() method is only for Encryption.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey"/> for encryption operations.
            For Decryption use the se the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair)"/> method and pass a KeyPair with both Public and Private keys.
            </para>
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the NTRU Public key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if a key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair)">
            <summary>
            Initialize the cipher for Decryption; This Initialize() method is only for Decryption.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey"/> for encryption, or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey"/> for decryption contained in an <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair"/> class.
            NTRU requires both Public and Private keys to decrypt a message.
            Use the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)"/> method and pass the NTRUPublicKey for Encryption.
            </para>
            </summary>
            
            <param name="KeyPair">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair"/> containing the NTRU public or private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if a key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Decrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IPolynomial,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial)">
            <summary>
            Decrypts an integer polynomial
            </summary>
            
            <param name="E">Encrypted polynomial</param>
            <param name="PrivT">A polynomial such that if <c>fastFp=true</c>, <c>f=1+3*priv_t</c>; otherwise, <c>f=priv_t</c></param>
            <param name="PrivFp">Fp</param>
            
            <returns>Derypted polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the Prng
            </summary>
            
            <param name="Prng">Prng type</param>
            
            <returns>Instance of Prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GetSeed(System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Polynomial.IntegerPolynomial,System.Byte[])">
            <summary>
            Generates a seed for the Blinding Polynomial Generation Function
            </summary>
            
            <param name="Message">The plain-text message</param>
            <param name="PubKey">The public key</param>
            <param name="Bits">Bits of random data</param>
            
            <returns>A byte array containing a seed value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.GenerateBlindingPoly(System.Byte[])">
            <summary>
            Deterministically generates a blinding polynomial from a seed and a message representative
            </summary>
            
            <param name="Seed">The seed value</param>
            
            <returns>A blinding polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.MGF(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            An implementation of MGF-TP-1 from P1363.1 section 8.4.1.1.
            </summary>
            
            <param name="Seed">The seed value</param>
            <param name="N">N paramater</param>
            <param name="MinCallsMask">Minimum Calls Mask</param>
            <param name="HashSeed">Whether to hash the seed</param>
            
            <returns></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.IsEncryption">
            <summary>
            Get: The cipher is initialized for encryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if the cipher is not initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUEncrypt.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement">
            <summary>
            This class implements an element of the finite field <c>GF(2^n)</c>.
            <para>It is represented in an optimal normal basis representation and holds the pointer <c>mField</c> to its corresponding field.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Construct a random element over the field <c>gf2n</c>, using the specified source of randomness
            </summary>
            
            <param name="Gf2n">The field</param>
            <param name="SecRnd">The source of randomness</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField,System.Byte[])">
            <summary>
            Construct a new GF2nONBElement from its encoding
            </summary>
            
            <param name="Gf2n">The field</param>
            <param name="Encoded">The encoded element</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField,VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Construct the element of the field <c>Gf2n</c> with the specified value <c>Value</c>
            </summary>
            
            <param name="Gf2n">The field</param>
            <param name="Value">The value represented by a BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField,System.Int64[])">
            <summary>
            Construct the element of the field <c>Gf2n</c> with the specified value <c>Value</c>
            </summary>
            
            <param name="Gf2n">The field</param>
            <param name="Value">The value in ONB representation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement)">
            <summary>
            Copy the field values from another GF2nONBElement instance
            </summary>
            
            <param name="Gf2n">The GF2nONBElement to copy</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.InvertThis">
            <summary>
            Multiplicatively invert of this element (overwrite <c>this</c>)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.One(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField)">
            <summary>
            Create the one element
            </summary>
            
            <param name="Gf2n">The finite field</param>
            
            <returns>Returns the one element in the given finite field</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.ReverseOrder">
            <summary>
            Reverses the bit-order in this element(according to 1363). This is a hack!
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Zero(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBField)">
            <summary>
            Create the zero element
            </summary>
            
            <param name="Gf2n">The finite field</param>
            
            <returns>The zero element in the given finite field</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Assign(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Assigns to this element the value <c>Value</c>
            </summary>
            
            <param name="Value">The value represented by a BigInteger</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Assign(System.Byte[])">
            <summary>
            Assigns to this element the value <c>val</c>. First: inverting the order of val into reversed[]
            </summary>
            
            <param name="Value">The value in ONB representation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Assign(System.Int64[])">
            <summary>
            Assigns to this element the value <c>Value</c>
            </summary>
            
            <param name="Value">The value in ONB representation</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.GetElement">
            <summary>
            Returns this element in its ONB representation
            </summary>
            
            <returns>The element in its ONB representation</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.GetElementReverseOrder">
            <summary>
            Returns the ONB representation of this element. The Bit-Order is exchanged (according to 1363)!
            </summary>
            
            <returns>Returns this element in its representation and reverse bit-order</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Add(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the sum of this element and <c>Addend</c>.
            </summary>
            
            <param name="Addend">The addend</param>
            
            <returns>Returns <c>this + other</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.AddToThis(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute <c>this + addend</c> (overwrite <c>this</c>)
            </summary>
            
            <param name="Addend">The addend</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.AssignOne">
            <summary>
            Assigns to this element the one element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.AssignZero">
            <summary>
            Assigns to this element the zero element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Clone">
            <summary>
            Create a new GF2nONBElement by cloning this GF2nPolynomialElement
            </summary>
            
            <returns>Returns a copy of this element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Equals(System.Object)">
            <summary>
            Compare this element with another object
            </summary>
            
            <param name="Obj">The object for comprison</param>
            
            <returns>Returns <c>true</c> if the two objects are equal, <c>false</c> otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.GetHashCode">
            <summary>
            Returns the hash code of this element
            </summary>
            
            <returns>The hash code</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Increase">
            <summary>
            Compute <c>this</c> element + 1
            </summary>
            
            <returns>Returns <c>this</c> + 1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.IncreaseThis">
            <summary>
            Increases this element by one
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Invert">
            <summary>
            Compute the multiplicative inverse of this element
            </summary>
            
            <returns>Returns <c>this^-1</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.IsOne">
            <summary>
            Tests if the GF2nPolynomialElement has 'one' as value
            </summary>
            
            <returns>Returns true if <c>this</c> equals one (this == 1)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.IsZero">
            <summary>
            Checks whether this element is zero
            </summary>
            
            <returns>Returns <c>true</c> if <c>this</c> is the zero element</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Multiply(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute the product of this element and <c>factor</c>
            </summary>
            
            <param name="Factor">he factor</param>
            
            <returns>Returns <c>this * factor</c> </returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.MultiplyThisBy(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.IGFElement)">
            <summary>
            Compute <c>this * factor</c> (overwrite <c>this</c>).
            </summary>
            
            <param name="Factor">The factor</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.SolveQuadraticEquation">
            <summary>
            Solves a quadratic equation
            <para>Let z^2 + z = <c>this</c>. Then this method returns z.</para>
            </summary>
            
            <returns>Returns z with z^2 + z = <c>this</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Square">
            <summary>
            Compute <c>this</c> element to the power of 2
            </summary>
            
            <returns>Returns <c>this</c>^2</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.SquareThis">
            <summary>
            Squares <c>this</c> element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.SquareRoot">
            <summary>
            Compute the square root of this element and return the result in a new GF2nElement
            </summary>
            
            <returns>Returns <c>this^1/2</c> (newly created)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.SquareRootThis">
            <summary>
            Compute the square root of this element
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.TestBit(System.Int32)">
            <summary>
            Checks whether the indexed bit of the bit representation is set
            <para>Note: GF2nElement currently stores its bits in reverse order</para>
            </summary>
            
            <param name="Index">The index of the bit to test</param>
            
            <returns>Returns <c>true</c> if the indexed bit is set</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.TestRightmostBit">
            <summary>
            Returns whether the rightmost bit of the bit representation is set. 
            This is needed for data conversion according to 1363.
            </summary>
            
            <returns>Returns true if the rightmost bit of this element is set</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.ToByteArray">
            <summary>
            Converts this GF2nPolynomialElement to a byte[] according to 1363
            </summary>
            
            <returns>Returns a byte[] representing the value of this GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.ToFlexiBigInt">
            <summary>
            Converts this GF2nPolynomialElement to an integer according to 1363
            </summary>
            
            <returns>Returns a BigInteger representing the value of this GF2nPolynomialElement</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.ToString">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal radix in MSB-first order
            </summary>
            
            <returns>Returns a String representing this Bitstrings value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.ToString(System.Int32)">
            <summary>
            Returns a string representing this Bitstrings value using hexadecimal or binary radix in MSB-first order
            </summary>
            
            <param name="Radix">The radix to use (2 or 16, otherwise 2 is used)</param>
            
            <returns>Returns a String representing this Bitstrings value.</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.Algebra.GF2nONBElement.Trace">
            <summary>
            Computes the trace of this element
            </summary>
            
            <returns>Returns the trace of this element</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Networking.PacketBuffer">
            <summary>
            A class that contains a searchable list of packet streams
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.#ctor(System.Int32)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="QueueDepth">The maximum queue depth</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Clear">
            <summary>
            Clear the buffer, disposing of each element
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">Thrown if the clearing the queue produced an error</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Destroy(System.Int64)">
            <summary>
            Remove and Dispose of a packet stream from the buffer
            </summary>
            
            <param name="Sequence">The packet sequence number</param>
            
            <returns>Returns true if the packet was destroyed, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Exists(System.Int64)">
            <summary>
            Check if the buffer contains a packet with this key
            </summary>
            
            <param name="Sequence">The packet sequence number</param>
            
            <returns>Returns <c>true</c> if the key exists, otherwise <c>false</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.GetHighKey">
            <summary>
            Get the key with the lowest sequence number
            </summary>
            
            <returns>The lowest key, or -1 for empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.GetLowKey">
            <summary>
            Get the key with the highest sequence number
            </summary>
            
            <returns>The highest key, or -1 for empty</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Peek(System.Int64)">
            <summary>
            Return the packet stream with the specified sequence number
            </summary>
            
            <param name="Sequence">The packet sequence number</param>
            
            <returns>Returns the packet stream, or if not found, an empty MemoryStream object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Pop(System.Int64)">
            <summary>
            Return the packet stream with the specified sequence number and removes it from the buffer
            </summary>
            
            <param name="Sequence">The packet sequence number</param>
            
            <returns>Returns the packet stream, or if not found, an empty MemoryStream object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Position(System.Int64)">
            <summary>
            Returns the position of a packet within the buffer, <c>-1</c> is returned if the sequence number can not be found
            </summary>
            
            <param name="Sequence">The packet sequence number</param>
            
            <returns>Returns the index of the packet within the buffer, or if not found, returns the value <c>-1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Push(System.Int64,System.IO.MemoryStream)">
            <summary>
            Add a packet stream to the buffer.
            <para>If a packet is added and the buffer size exceeds the Queue Depth, 
            the packet with the lowest sequence number is removed</para>
            </summary>
            
            <param name="Sequence">The packet sequence number</param>
            <param name="Packet">The packet stream</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Remove(System.Int64)">
            <summary>
            Remove a packet stream from the buffer
            </summary>
            
            <param name="Sequence">The packet sequence number</param>
            
            <returns>Returns true if the packet was removed, otherwise false</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Count">
            <summary>
            Get: The number of packet streams in the buffer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.PacketBuffer.Depth">
            <summary>
            Get/Set: The size of the buffer queue
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">Thrown if the queue depth is less than 1</exception>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.ArrayEx">
            <summary>
            Array type extensions
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.AddAt``1(System.Int32[],System.Int32,``0)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array to be expanded</param>
            <param name="Index">The insertion point within the source array</param>
            <param name="Value">The new value</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.AddRange``1(``0[],``0[],System.Int32)">
            <summary>
            Add a new value member to an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array to be expanded</param>
            <param name="Data">The new value members</param>
            <param name="Index">The insertion point within the source array</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Deserialize``1(System.Byte[])">
            <summary>
            Convert a byte array to a class objct
            </summary>
            
            <typeparam name="T">Return object type</typeparam>
            <param name="Data">The byte array containing the class</param>
            
            <returns>The class object</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.CopyOf``1(``0[],System.Int32)">
            <summary>
            Create a copy of an array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array source</param>
            <param name="Length">Number of elements to copy</param>
            
            <returns>A copy of the source array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.CopyOfRange``1(``0[],System.Int32,System.Int32)">
            <summary>
            Create a ranged copy of a byte array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Byte source array</param>
            <param name="From">First element to copy</param>
            <param name="To">Last element to copy</param>
            
            <returns>Byte array copy</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Fill``1(``0[],``0)">
            <summary>
            Fill an array with a value; defaults to zeroes
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array to fill</param>
            <param name="Value">Value used to fill array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Fill``1(``0[0:,0:],``0)">
            <summary>
            Fill an array with a value; defaults to zeroes
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">Array to fill</param>
            <param name="Value">Value used to fill array</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.RemoveAt``1(``0[],System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <typeparam name="T">The type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The index of the element to remove</param>
            
            <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.RemoveRange``1(``0[],System.Int32,System.Int32)">
            <summary>
            Remove an element from the array
            </summary>
            
            <param name="Source">The source array</param>
            <param name="From">First element to remove</param>
            <param name="To">Last element to remove</param>
            
            /// <returns>Resized array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Serialize(System.Object)">
            <summary>
            Serialize an object to a byte array
            </summary>
            
            <param name="Obj">The object to serialize</param>
            
            <returns>The object as a serialized byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Shuffle``1(``0[])">
            <summary>
            Shuffle an array using the SecureRandom class
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The list instance</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.Shuffle``1(``0[],VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Shuffle an array with a specific Prng class
            </summary>
            
            <typeparam name="T">Type of list</typeparam>
            <param name="Source">The list instance</param>
            <param name="Rng">The pseudo random generator</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.ArrayEx.SubArray``1(``0[],System.Int32,System.Int32)">
            <summary>
            Return a sub array
            </summary>
            
            <typeparam name="T">Type of array</typeparam>
            <param name="Source">The source array</param>
            <param name="Index">The starting position within the source array</param>
            <param name="Count">The number of bytes to copy</param>
            
            <returns>The sub array</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC">
            <summary>
            <h3>SHA256 Hash based Message Authentication Code Wrapper using SHA-2 256.</h3>
            <para>A SHA512 HMAC as outlined in the NIST document: Fips 198-1<cite>Fips 198-1</cite></para>
            </summary>
            
            <example>
            <description>Example using an <c>IMac</c> interface:</description>
            <code>
            using (IMac mac = new SHA256HMAC(), [DisposeEngine])
            {
                // initialize
                mac.Initialize(KeyParams);
                // get mac
                Output = mac.ComputeMac(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="N:VTDev.Libraries.CEXEngine.Crypto.Digest">VTDev.Libraries.CEXEngine.Crypto.Digest Namespace</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Key size should be equal to digest output size<cite>RFC 2104</cite>; 32 bytes, (256 bits).</description></item>
            <item><description>Block size is 64 bytes, (512 bits).</description></item>
            <item><description>Digest size is 32 bytes, (256 bits).</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Boolean)">Constructors</see> DisposeEngine parameter determines if Digest engine is destroyed when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> is called on this class; default is <c>true</c>.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.ComputeMac(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>RFC 2104: <see href="http://tools.ietf.org/html/rfc2104">HMAC: Keyed-Hashing for Message Authentication</see>.</description></item>
            <item><description>NIST Fips 198-1: <see href="http://csrc.nist.gov/publications/fips/fips198-1/FIPS-198-1_final.pdf">The Keyed-Hash Message Authentication Code (HMAC)</see>.</description></item>
            <item><description>NIST Fips 180-4: <see href="http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf">Secure Hash Standard (SHS)</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Bouncy Castle Java <see href="http://bouncycastle.org/latest_releases.html">Release 1.51</see> version.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Boolean)">
            <summary>
            Initialize the class
            <para>When using this constructor, you must call <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> before processing.</para>
            </summary>
            
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> on this class is called</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.#ctor(System.Byte[],System.Boolean)">
            <summary>
            Initialize the class and working variables.
            <para>When this constructor is used, <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)"/> is called automatically.</para>
            </summary>
            
            <param name="Key">HMAC Key; passed to HMAC Initialize() through constructor</param>
            <param name="DisposeEngine">Dispose of digest engine when <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose"/> on this class is called</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if a null Key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the hash buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.ComputeMac(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Mac value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Process the last block of data
            </summary>
            
            <param name="Output">The hash value return</param>
            <param name="OutOffset">The offset in the data</param>
            
            <returns>The number of bytes processed</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoMacException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Initialize(VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the HMAC.
            <para>Uses the Key field of the KeyParams class.</para>
            </summary>
            
            <param name="KeyParam">KeyParams containing HMAC Key. 
            <para>Uses the Key field of the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/> class. 
            Key should be equal in size to the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DigestSize"/></para>
            </param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Dispose">
            <summary>
            Dispose of this class, and dependant resources
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.BlockSize">
            <summary>
            Get: The Ciphers internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.IsInitialized">
            <summary>
            Get: Mac is ready to digest data
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Mac.SHA256HMAC.Name">
            <summary>
            Get: Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyScope">
            <summary>
            Key authentication scope. 
            <para>Indicates at which privilege level the key can be accessed. 
            Used by the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Processing.Factory.PackageFactory"/> class as an access level description.</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyScope.Creator">
            <summary>
            Creator of this key; full access
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyScope.Operator">
            <summary>
            Key recipient; decrypt only access
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.KeyScope.NoAccess">
            <summary>
            The operator is denied access to this key
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign">
             <summary>
             An Rainbow Asymmetric Signature Scheme implementation
             </summary>
             
             <example>
             <description>Example of using the signing and verifying an array:</description>
             <code>
             byte[] code;
             byte[] data = new byte[100];
             
             RNBWParameters kpm = (RNBWParameters)RNBWParamSets.RNBWN33L5.DeepCopy();
             RNBWKeyGenerator gen = new RNBWKeyGenerator(kpm);
             IAsymmetricKeyPair keyPair = gen.GenerateKeyPair();
            
             // get the message code for an array of bytes
             using (RNBWSign sign = new RNBWSign(kpm))
             {
                 sign.Initialize(kp.PrivateKey);
                 code = sign.Sign(data, 0, data.Length);
             }
            
             // test the message for validity
             using (RNBWSign sign = new RNBWSign(kpm))
             {
                 sign.Initialize(kp.PublicKey);
                 bool valid = sign.Verify(data, 0, data.Length, code);
             }
             </code>
             </example>
             
             <revisionHistory>
             <revision date="2015/07/06" version="1.4.0.0">Initial release</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWSign Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWPublicKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW RNBWPrivateKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom">VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration Prngs Enumeration</seealso>
             
             <remarks>
             <description><h4>Guiding Publications:</h4></description>
             <list type="number">
             <item><description>Selecting Parameters for the Rainbow Signature Scheme<cite>Rainbow Parameters</cite>.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWParameters)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The RNBW cipher used to encrypt the hash</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the Key for Sign (Private) or Verify (Public)
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the Rainbow Public (verify) or Private (sign) key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if an invalid key is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Reset">
            <summary>
            Reset the underlying digest engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Sign(System.IO.Stream)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="InputStream">The stream containing the data</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if an invalid key is used, or signer has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Sign(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="Input">The byte array contining the data</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if input array is too short, signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Verify(System.IO.Stream,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="InputStream">The stream containing the data to test</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Verify(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="Input">The stream containing the data to test</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if input array is too short, signer is not initialized, or the key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.InitSign(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.MapLayer[],System.Int16[])">
            <summary>
            Initial operations before solving the Linear equation system
            </summary>
            
            <param name="Layer">The current layer for which a LES is to be solved</param>
            <param name="Message">The message that should be signed</param>
            
            <returns>The modified document needed for solving LES, (Y_ = A1^{-1}*(Y-b1)) linear map L1 = A1 x + b1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.GenerateSignature(System.Byte[])">
            <summary>
            This function signs the message that has been updated, making use of the private key.
            <para>For computing the signature, L1 and L2 are needed, as well as LES should be solved 
            for each layer in order to find the Oil-variables in the layer.
            The Vinegar-variables of the first layer are random generated.</para>
            </summary>
            
            <param name="Message">The message</param>
            
            <returns>The signature of the message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.VerifySignature(System.Byte[],System.Byte[])">
            <summary>
            This function verifies the signature of the message that has been updated, with the aid of the public key
            </summary>
            
            <param name="Message">The message</param>
            <param name="Signature">The signature of the message</param>
            
            <returns>Returns true if the signature has been verified, false otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.VerifySignatureIntern(System.Int16[])">
            <summary>
            Signature verification using public key
            </summary>
            
            <param name="Signature">The signature vector of dimension n</param>
            <returns>Returns document hash of length n - v1</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.MakeMessageRepresentative(System.Byte[])">
            <summary>
            This function creates the representative of the message which gets signed or verified
            </summary>
            
            <param name="Message">The message</param>
            
            <returns>Returns the message representative</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.IsSigner">
            <summary>
            Get: This class is initialized for Signing with the Private key
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.RNBWSign.Name">
            <summary>
            Get: The Signer name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField">
            <summary>
            This class offers different operations on matrices in field GF2^8.
            <para>Implements functions for finding inverse of a matrix, 
            solving linear equation systems using the Gauss-Elimination method,
            and basic operations like matrix multiplication, addition and so on.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.AddSquareMatrix(System.Int16[][],System.Int16[][])">
            <summary>
            Adds the n x n matrices matrix1 and matrix2
            </summary>
            <param name="M1">The first summand</param>
            <param name="M2">The second summand</param>
            <returns>Returns addition of matrix1 and matrix2; both having the dimensions n x n</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the addition is not possible because of different dimensions of the matrices</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.AddVect(System.Int16[],System.Int16[])">
            <summary>
            Addition of two vectors.
            </summary>
            
            <param name="V1">The first summand, always of dim n</param>
            <param name="V2">The second summand, always of dim n</param>
            
            <returns>Returns <c>V1+V2</c></returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the addition is impossible due to inconsistency in the dimensions</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.Inverse(System.Int16[][])">
            <summary>
            This function computes the inverse of a given matrix using the Gauss-Elimination method.
            <para>An exception is thrown if the matrix has no inverse</para>
            </summary>
            
            <param name="Coef">The matrix which inverse matrix is needed</param>
            
            <returns>The inverse matrix of the input matrix</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the given matrix is not invertible</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.MultiplyMatrix(System.Int16[][],System.Int16[][])">
            <summary>
            This function multiplies two given matrices.
            <para>If the given matrices cannot be multiplied due to different sizes, an exception is thrown.</para>
            </summary>
            
            <param name="M1">The 1st matrix</param>
            <param name="M2">The 2nd matrix</param>
            
            <returns></returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the given matrices cannot be multiplied due to different dimensions</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.MultiplyMatrix(System.Int16[][],System.Int16[])">
            <summary>
            This function multiplies a given matrix with a one-dimensional array.
            <para>An exception is thrown, if the number of columns in the matrix and the number of rows in the one-dimensional array differ.</para>
            </summary>
            
            <param name="M1">The matrix to be multiplied</param>
            <param name="M">The one-dimensional array to be multiplied</param>
            
            <returns>Returns <c>M1*m</c></returns>
            
            <exception cref="T:System.ArgumentException">Thrown in case of dimension inconsistency</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.MultMatrix(System.Int16,System.Int16[][])">
            <summary>
            Multiplies matrix with scalar
            </summary>
            
            <param name="Scalar">The scalar galois element to multiply matrix with</param>
            <param name="Matrix">The matrix 2-dim n x n matrix to be multiplied</param>
            
            <returns>Returns matrix multiplied with scalar</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.MultVect(System.Int16,System.Int16[])">
            <summary>
            Multiplies vector with scalar
            </summary>
            
            <param name="Scalar">The scalar galois element to multiply vector with</param>
            <param name="Vector">The vector to be multiplied</param>
            
            <returns>Returns vector multiplied with scalar</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.MultVects(System.Int16[],System.Int16[])">
            <summary>
            Multiplication of column vector with row vector
            </summary>
            
            <param name="V1"> column vector, always n x 1</param>
            <param name="V2"> row vector, always 1 x n</param>
            
            <returns> resulting n x n matrix of multiplication</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if the multiplication is impossible due to inconsistency in the dimensions</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.SolveEquation(System.Int16[][],System.Int16[])">
            <summary>
            This function finds a solution of the equation Bx = b.
            </summary>
            
            <param name="B">This matrix is the left part of the equation (B in the equation above)</param>
            <param name="Br">The right part of the equation (b in the equation above)</param>
            
            <returns>The solution of the equation if it is solvable null otherwise</returns>
            
            <exception cref="T:System.ArgumentException">Thrown if LES is not solvable</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.ComputeZerosUnder(System.Boolean)">
            <summary>
            Elimination under the diagonal.
            <para>This function changes a matrix so that it contains only zeros under the diagonal(Ai,i) using only Gauss-Elimination operations.
            It is used in solveEquaton as well as in the function for finding an inverse of a matrix: inverse.
            Both of them use the Gauss-Elimination Method.
            The result is stored in the global matrix A</para>
            </summary>
            
            <param name="ForInverse">Shows if the function is used by the solveEquation-function or by the inverse-function and according to this creates matrices of different sizes.</param>
            
            <exception cref="T:System.ArgumentException">Thrown if the multiplicative inverse of 0 is needed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.ComputeZerosAbove">
            <summary>
            Elimination above the diagonal.
            <para>This function changes a matrix so that it contains only zeros above the diagonal(Ai,i) using only Gauss-Elimination operations.
            It is used in the inverse-function
            The result is stored in the global matrix A.</para>
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a multiplicative inverse of 0 is needed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.Substitute">
            <summary>
            This function uses backward substitution to find x of the linear equation system (LES) B*x = b, 
            where A a triangle-matrix is (contains only zeros under the diagonal) and b is a vector.
            <para>If the multiplicative inverse of 0 is needed, an exception is thrown. 
            In this case is the LES not solvable.</para>
            </summary>
            
            <exception cref="T:System.ArgumentException">Thrown if a multiplicative inverse of 0 is needed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.ComputeInField.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder">
            <summary>
            Converts a coefficient array to a compact byte array and vice versa.
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeMod3Sves(System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Decodes a <c>byte</c> array encoded with EncodeMod3Sves(int[], boolean) back to an <c>int</c> array with <c>N</c> coefficients between <c>-1</c> and <c>1</c>.
            <para>Ignores any excess bytes.
            See P1363.1 section 9.2.2.</para>
            </summary>
            
            <param name="Data">Data an encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="SkipFirst">Whether to leave the constant coefficient zero and start populating at the linear coefficient</param>
            
            <returns>The decoded coefficients</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeMod3Tight(System.Byte[],System.Int32)">
            <summary>
            Converts a byte array produced by EncodeMod3Tight(int[]) back to an <c>int</c> array
            </summary>
            
            <param name="Data">The byte array</param>
            <param name="N">The number of coefficients</param>
            
            <returns>The decoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeMod3Tight(System.IO.MemoryStream,System.Int32)">
            <summary>
            Converts data produced by EncodeMod3Tight(int[]) back to an <c>int</c> array
            </summary>
            
            <param name="InputStream">The input stream containing the data to decode</param>
            <param name="N">The number of coefficients</param>
            
            <returns>The decoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeModQ(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decodes a <c>byte</c> array encoded with EncodeModQ(int[], int)} back to an <c>int</c> array.
            <para><c>N</c> is the number of coefficients. <c>Q</c> must be a power of <c>2</c>.
            Ignores any excess bytes.</para>
            </summary>
            
            <param name="Data">Data an encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="Q">The modulus</param>
            
            <returns>Returns an array containing <c>N</c> coefficients between <c>0</c> and <c>q-1</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.DecodeModQ(System.IO.Stream,System.Int32,System.Int32)">
            <summary>
            Decodes data encoded with encodeModQ(int[], int) back to an <c>int</c> array.
            <para><c>N</c> is the number of coefficients. <c>q</c> must be a power of <c>2</c>.
            Ignores any excess bytes.</para>
            </summary>
            
            <param name="InputStream">An encoded ternary polynomial</param>
            <param name="N">The number of coefficients</param>
            <param name="Q">The modulus</param>
            
            <returns>The decoded polynomial</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.EncodeMod3Sves(System.Int32[],System.Boolean)">
            <summary>
            Encodes an <c>int</c> array whose elements are between <c>-1</c> and <c>1</c>, to a byte array.
            <para><c>coeffs[2*i]</c> and <c>coeffs[2*i+1]</c> must not both equal -1 for any integer <c>i</c>,
            so this method is only safe to use with arrays produced by {@link #decodeMod3Sves(byte[], int, boolean)}.
            See P1363.1 section 9.2.3.</para>
            </summary>
            
            <param name="Data">The input array</param>
            <param name="SkipFirst">Whether to skip the constant coefficient</param>
            
            <returns>The encoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.EncodeMod3Tight(System.Int32[])">
            <summary>
            Encodes an <c>int</c> array whose elements are between <c>-1</c> and <c>1</c>, to a byte array
            </summary>
            
            <param name="Data">The input array</param>
            
            <returns>he encoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.EncodeModQ(System.Int32[],System.Int32)">
            <summary>
            Encodes an int array whose elements are between 0 and <c>Q</c>, to a byte array leaving no gaps between bits.
            <para><c>Q</c> must be a power of 2.</para>
            </summary>
            
            <param name="A">The input array</param>
            <param name="Q">The modulus</param>
            
            <returns>The encoded array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.EncodeModQTrunc(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Like EncodeModQ(int[], int) but only returns the first <c>NumBytes</c> bytes of the encoding
            </summary>
            
            <param name="Data">The input array</param>
            <param name="Q">The modulus</param>
            <param name="NumBytes">The encoded array</param>
            
            <returns>Returns T</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.ReadFullLength(System.IO.Stream,System.Int32)">
            <summary>
            Reads a given number of bytes from an <c>InputStream</c>.
            <para>If there are not enough bytes in the stream, an <c>IOException</c> is thrown.</para>
            </summary>
            
            <param name="InputStream">The input stream containing the data to read</param>
            <param name="Length">The length of the input stream </param>
            
            <returns>An array of length <c>Length</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Encode.ArrayEncoder.ToByteArray(System.Int32)">
            <summary>
            Convert an integer value to a two byte array
            </summary>
            
            <param name="Value">The integer to convert</param>
            
            <returns>The byte array value</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets">
            <summary>
            Contains sets of predefined McEliece parameters.
            <para>Use the FromId(byte[]) or FromName(MPKCParamSets) to return a deep copy of a parameter set.</para>
            </summary>
            
            <remarks>
            <description><h4>Parameter OId:</h4></description>
            <list type="bullet">
            <item><description>A Parameter Set OId (uniquely identifies the parameter set), is always the first four bytes of a serialized parameter set.</description></item>
            <item><description>The OId format is ordered as: <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Unique</c>.</description></item>
            <item><description>A McEliece parameters Family designator (first byte) is always the value <c>1</c>, and corresponds to its entry in the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</description></item>
            <item><description>The second byte (Set), defines the CCA2 Secure variant type, and corresponds to the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCCiphers.CCA2Ciphers"/> enumeration.</description></item>
            <item><description>The third byte indicates the M-base, 11, 12, 13, or 14.</description></item>
            <item><description>The fourth byte can be a unique designator.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>McEliece Handbook of Applied Cryptography: Chapter 8<cite>McEliece Handbook of Applied Cryptography</cite>.</description></item>
            <item><description>Selecting Parameters for Secure McEliece-based Cryptosystems<cite>McEliece Parameters</cite>.</description></item>
            <item><description>Weak keys in the McEliece public-key cryptosystem<cite>McEliece Weak keys</cite>.</description></item>
            <item><description>McBits: fast constant-time code-based cryptography<cite>McEliece McBits</cite>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.FromId(System.Byte[])">
            <summary>
            Retrieve a parameter set by its identity code
            </summary>
            
            <param name="OId">The 4 byte parameter set identity code</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.FromName(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames)">
            <summary>
            Retrieve a parameter set by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.GetID(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames)">
            <summary>
            Retrieve the parameter OId by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>The 4 byte OId field</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is specified</exception>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM11T40S256">
            <summary>
            Low security; uses the Fujisaki cipher and SHA-256
            <para>Security:95, MaxText:201, K:1608 N:2048, PublicKey Size:88488, PrivateKey Size:119071, OId: 1, 1, 11, 1</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM11T48S256">
            <summary>
            Low security; uses the Fujisaki cipher and SHA-256
            <para>Security:98, MaxText:190, K:1520 N:2048, PublicKey Size:100368, PrivateKey Size:142531, OId: 1, 1, 11, 2</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM12T31S256">
            <summary>
            Low to Medium security; uses the Fujisaki cipher and SHA-256
            <para>Security:108, MaxText:465, K:3724, N:4096, PublicKey Size: 175076, PrivateKey Size:200119, OId: 1, 1, 12, 1</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM12T41S256">
            <summary>
            Medium security; uses the Fujisaki cipher and SHA-256
            <para>Security:129, MaxText:450, K:3604, N:4096, PublicKey Size: 223496, PrivateKey Size:262519, OId: 1, 1, 12, 2</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM12T48S256">
            <summary>
            Medium security; uses the Fujisaki cipher and SHA-256
            <para>Security:131?, MaxText:440, K:3520, N:4096, PublicKey Size: 253488, PrivateKey Size:306371, OId: 1, 1, 12, 3</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM12T54K256">
            <summary>
            Medium security; uses the Fujisaki cipher and Keccak 256
            <para>Security:133?, MaxText:431, K:3448, N:4096, PublicKey Size: 306371, PrivateKey Size:344039, OId: 1, 1, 12, 4</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM12T67S256">
            <summary>
            High security; uses the Fujisaki cipher and SHA-256
            <para>Security:148?, MaxText:431, K:3292, N:4096, PublicKey Size: 332540, PrivateKey Size:425928, OId: 1, 1, 12, 5</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM13T29S256">
            <summary>
            Medium security; uses the Fujisaki cipher and SHA-256
            <para>Security:128, MaxText:976, K:7815, N:8192, PublicKey Size: 375168, PrivateKey Size:403733, OId: 1, 1, 13, 1</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM13T44K256">
            <summary>
            Medium security; uses the Fujisaki cipher and Keccak 256
            <para>Security:136, MaxText:952, K:7620, N:8192, PublicKey Size: 548688, PrivateKey Size:604893, OId: 1, 1, 13, 2</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM13T95S256">
            <summary>
            High security; uses the Fujisaki cipher and SHA-256 (slow)
            <para>Security:190?, MaxText:431, K:3292, N:4096, PublicKey Size: 332540, PrivateKey Size:425928, OId: 1, 1, 13, 3</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCFM14T24K256">
            <summary>
            Low to Medium security; uses the Fujisaki cipher and Keccak 256
            <para>Security:115, MaxText:2006, K:16048, N:16384, PublicKey Size: 674064, PrivateKey Size:721847, OId: 1, 1, 14, 1</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames">
            <summary>
            Set id is defined as: Cipher(Fujisaki default), T value, M value, Digest family, Digest size 
            <para>FM11T40S256 = F(Fujisake): M11: T40: S(SHA-2): 256</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM11T40S256">
            <summary>
            Low security; uses the Fujisaki cipher and SHA-256
            <para>Security:95, MaxText:201, K:1608 N:2048, PublicKey Size:88488, PrivateKey Size:119071, OId: 1, 1, 11, 1</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM11T48S256">
            <summary>
            Low security; uses the Fujisaki cipher and SHA-256
            <para>Security:98, MaxText:190, K:1520 N:2048, PublicKey Size:100368, PrivateKey Size:142531, OId: 1, 1, 11, 2</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM12T31S256">
            <summary>
            Low to Medium security; uses the Fujisaki cipher and SHA-256
            <para>Security:108, MaxText:465, K:3724, N:4096, PublicKey Size: 175076, PrivateKey Size:200119, OId: 1, 1, 12, 1</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM12T41S256">
            <summary>
            Medium security; uses the Fujisaki cipher and SHA-256
            <para>Security:129, MaxText:450, K:3604, N:4096, PublicKey Size: 223496, PrivateKey Size:262519, OId: 1, 1, 12, 2</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM12T48S256">
            <summary>
            Medium security; uses the Fujisaki cipher and SHA-256
            <para>Security:131?, MaxText:440, K:3520, N:4096, PublicKey Size: 253488, PrivateKey Size:306371, OId: 1, 1, 12, 3</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM12T54K256">
            <summary>
            Medium security; uses the Fujisaki cipher and Keccak 256
            <para>Security:133?, MaxText:431, K:3448, N:4096, PublicKey Size: 306371, PrivateKey Size:344039, OId: 1, 1, 12, 4</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM12T67S256">
            <summary>
            High security; uses the Fujisaki cipher and SHA-256
            <para>Security:148?, MaxText:431, K:3292, N:4096, PublicKey Size: 332540, PrivateKey Size:425928, OId: 1, 1, 12, 5</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM13T29S256">
            <summary>
            Medium security; uses the Fujisaki cipher and SHA-256
            <para>Security:128, MaxText:976, K:7815, N:8192, PublicKey Size: 375168, PrivateKey Size:403733, OId: 1, 1, 13, 1</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM13T44K256">
            <summary>
            Medium security; uses the Fujisaki cipher and Keccak 256
            <para>Security:136, MaxText:952, K:7620, N:8192, PublicKey Size: 548688, PrivateKey Size:604893, OId: 1, 1, 13, 2</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM13T95S256">
            <summary>
            High security; uses the Fujisaki cipher and SHA-256 (slow)
            <para>Security:190?, MaxText:431, K:3292, N:4096, PublicKey Size: 332540, PrivateKey Size:425928, OId: 1, 1, 13, 3</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.McEliece.MPKCParamSets.MPKCParamNames.FM14T24K256">
            <summary>
            Low to Medium security; uses the Fujisaki cipher and Keccak 256
            <para>Security:115, MaxText:2006, K:16048, N:16384, PublicKey Size: 674064, PrivateKey Size:721847, OId: 1, 1, 14, 1</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity">
            <summary>
            The DtmIdentity structure; contains the identity field and session information for a host.
            <para>This structure is used as storage for the active identity, symmetric session, and asymmetric parameters.</para>
            </summary>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmClient structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmPacket structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmSession structure</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmParameters class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmKex class</seealso>
            
            <revisionHistory>
            <revision date="2015/06/14" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.Identity">
            <summary>
            The active Identity field; used to identify a host in the key exchange
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.PkeId">
            <summary>
            The Asymmetric parameters Id; can be the Asymmetric cipher parameters OId, or a serialized Asymmetric Parameters class
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.Session">
            <summary>
            The Symmetric sessions cipher parameters; contains a complete description of the Symmetric cipher
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.OptionFlag">
            <summary>
            This flag can be used as a time stamp indicating the expiry time of the corresponding session key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.#ctor(System.Byte[],System.Byte[],VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession,System.Int64)">
            <summary>
            DtmIdentity partial constructor; used for the <c>Init</c> exchange and contains an empty Secret Id
            </summary>
            
            <param name="Identity">The active Identity field; used to first identify a host during the <c>Init</c> stage of a key exchange</param>
            <param name="PkeId">The Asymmetric parameters Id; can be the Asymmetric cipher parameters OId, or a serialized Asymmetric Parameters class</param>
            <param name="Session">The Symmetric sessions cipher parameters; contains a complete description of the Symmetric cipher</param>
            <param name="OptionFlag">This flag can be used as a time stamp indicating the expiry time of the corresponding session key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.#ctor(System.Byte[])">
            <summary>
            Extracts a DtmIdentity from a byte array
            </summary>
            
            <param name="IdentityArray">The byte array containing the DtmIdentity structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.#ctor(System.IO.Stream)">
            <summary>
            Extracts a DtmIdentity from a Stream
            </summary>
            
            <param name="IdentityStream">The Stream containing the DtmIdentity structure</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.DeSerialize(System.IO.Stream)">
            <summary>
            Deserialize a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/>
            </summary>
            
            <param name="IdentityStream">Stream containing a serialized DtmIdentity</param>
            
            <returns>A populated DtmIdentity</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.Serialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity)">
            <summary>
            Serialize a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/> structure
            </summary>
            
            <param name="Identity">A DtmIdentity structure</param>
            
            <returns>A stream containing the DtmIdentity data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.GetHeaderSize">
            <summary>
            Get the header Size in bytes
            </summary>
            
            <returns>Header size</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.Reset">
            <summary>
            Reset all struct members
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.ToBytes">
            <summary>
            Returns the DtmParameters as an encoded byte array
            </summary>
            
            <returns>The serialized DtmIdentity</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity.ToStream">
            <summary>
            Returns the DtmPacket as an encoded MemoryStream
            </summary>
            
            <returns>The serialized DtmPacket</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Networking.StateToken">
            <summary>
            State object for receiving data from remote device
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.StateToken.Client">
            <summary>
            The Client socket
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.StateToken.Buffer">
            <summary>
            The Receive buffer
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.StateToken.Data">
            <summary>
            Received data container
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.StateToken.#ctor(System.Net.Sockets.Socket,System.Int32)">
            <summary>
            The state token constructor
            </summary>
            
            <param name="Client">The client socket instance</param>
            <param name="BufferSize">Size of the Tcp buffer; default is 8 Kib (8192 bytes)</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Networking.DataReceivedEventArgs">
            <summary>
            An event arguments class containing the error state information.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.DataReceivedEventArgs.OptionFlag">
            <summary>
            The option flag containing optional state information
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.DataReceivedEventArgs.Owner">
            <summary>
            The owner object
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.DataReceivedEventArgs.#ctor(VTDev.Libraries.CEXEngine.Networking.StateToken,System.Int32)">
            <summary>
            Returned when data has been received from a TCP Receive operation
            </summary>
            
            <param name="Owner">The <see cref="T:VTDev.Libraries.CEXEngine.Networking.StateToken"/> owner object</param>
            <param name="OptionFlag">The option flag containing additional state information</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Networking.TcpSocket">
            <summary>
            A disposable socket class that wraps asychronous and sychronous network operations
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.TcpSocket.MAXRCVBUFFER">
            <summary>
            Maximum send or receive packet size, default is 240mb
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.TcpSocket.RECEIVETIMEOUT">
            <summary>
            The maximum time to wait for a receive operation before the connection times out, default is infinite
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SENDTIMEOUT">
            <summary>
            The maximum time to wait for a send operation before the connection times out, default is infinite
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.TcpSocket.RECEIVEBUFFER">
            <summary>
            The size of a receive buffer element, default is 8kib
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SENDBUFFER">
            <summary>
            The size of a send buffer element, default is 8kib
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.#ctor">
            <summary>
            Initialize this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.GetStreamData(System.Int32,System.Int32)">
            <summary>
            Blocking method returns when the specified length of data has been read from the NetworkStream
            </summary>
            
            <param name="Length">The number of bytes to read</param>
            <param name="TimeOut">The timeout period</param>
            
            <returns>A MemoryStream containing the data</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the MaxAllocation size is exceeded, or the socket is in an error state</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.IsPortOpen(System.Int32)">
            <summary>
            Test if an application is listening on a port
            </summary>
            
            <param name="Port">The port to test</param>
            
            <returns>Returns <c>true</c> if an application is listening on the port, otherwise <c>false</c></returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the operation is in an error state</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.NextOpenPort(System.Int32,System.Int32)">
            <summary>
            Get an open and randomly selected port number within a range
            </summary>
            
            <param name="From">The minimum port number (default is 49152)</param>
            <param name="To">The maximum port number (default is 65535)</param>
            <returns>An open port number</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the operation is in an error state</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Close">
            <summary>
            Close the Client connection
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Connect(System.String,System.Int32,System.Int32)">
            <summary>
            Start Blocking connect to a remote host
            </summary>
            
            <param name="HostName">The remote machines Host Name</param>
            <param name="Port">The remote machines Port number</param>
            <param name="Timeout">The connection time out in milliseconds (default is 5 seconds)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp connect operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Connect(System.Net.IPAddress,System.Int32,System.Int32)">
            <summary>
            Start Blocking connect to a remote host
            </summary>
            
            <param name="Address">The remote machines IP address</param>
            <param name="Port">The remote machines Port number</param>
            <param name="Timeout">The connection time out in milliseconds (default is 5 seconds)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp connect operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ConnectAsync(System.String,System.Int32,System.Int32)">
            <summary>
            Start Non-Blocking connect to a remote host
            </summary>
            
            <param name="HostName">The remote machines Host Name</param>
            <param name="Port">The remote machines Port number</param>
            <param name="Timeout">The connection time out in milliseconds (default is 5 seconds)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp connect operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ConnectAsync(System.Net.IPAddress,System.Int32,System.Int32)">
            <summary>
            Start Non-Blocking connect to a remote host
            </summary>
            
            <param name="Address">The remote machines IP address</param>
            <param name="Port">The remote machines Port number</param>
            <param name="Timeout">The connection time out in milliseconds (default is 5 seconds)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp connect operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ConnectCallback(System.IAsyncResult)">
            <summary>
            The async connect callback
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Listen(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Start Blocking listen on a port for an incoming connection
            </summary>
            
            <param name="HostName">The Host Name assigned to this server</param>
            <param name="Port">The Port number assigned to this server</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp listen operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Listen(System.Net.IPAddress,System.Int32,System.Int32)">
            <summary>
            Start Blocking listen on a port for an incoming connection
            </summary>
            
            <param name="Address">The IP address assigned to this server</param>
            <param name="Port">The Port number assigned to this server</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp listen operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ListenAsync(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Start Non-Blocking listen on a port for an incoming connection
            </summary>
            
            <param name="HostName">The Host Name assigned to this server</param>
            <param name="Port">The Port number assigned to this server</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp listen operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ListenAsync(System.Net.IPAddress,System.Int32,System.Int32,System.Int32)">
            <summary>
            Start Non-Blocking listen on a port for an incoming connection
            </summary>
            
            <param name="Address">The IP address assigned to this server</param>
            <param name="Port">The Port number assigned to this server</param>
            <param name="MaxConnections">The maximum number of simultaneous connections allowed (default is 10)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp listen operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ListenCallback(System.IAsyncResult)">
            <summary>
            The Listen callback
            </summary>
            
            <param name="Ar">The IAsyncResult</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp listen operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ListenStop">
            <summary>
            Stop listening for a connection
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ReceiveAsync(System.Net.Sockets.SocketFlags)">
            <summary>
            Begin Non-Blocking receiver of incoming messages (called after a connection is made)
            </summary>
            
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp receive operation has failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ReceiveCallback(System.IAsyncResult)">
            <summary>
            The ReceiveAsync callback
            </summary>
            
            <param name="Ar">The IAsyncResult</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown on socket error or if the Tcp stream is larger than the maximum allocation size</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
            <summary>
            Blocking transmission of a byte array to the remote host
            </summary>
            
            <param name="DataArray">The data byte array to send</param>
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp Send operation has failed, or the maximum allocation size is exceeded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Send(System.IO.MemoryStream,System.Net.Sockets.SocketFlags)">
            <summary>
            Blocking transmission of a stream to the remote host
            </summary>
            
            <param name="DataStream">The data stream to send</param>
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp Send operation has failed, or the maximum allocation size is exceeded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            <summary>
            Blocking transmission of a byte array to the remote host
            </summary>
            
            <param name="DataArray">The data byte array to send</param>
            <param name="Offset">The start position within the buffer array</param>
            <param name="Size">The number of bytes to send</param>
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp Send operation has failed, or the maximum allocation size is exceeded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Send(System.IO.MemoryStream,System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            <summary>
            Blocking transmission of a stream to the remote host
            </summary>
            
            <param name="DataStream">The data stream to send</param>
            <param name="Offset">The start position within the stream</param>
            <param name="Size">The number of bytes to send</param>
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp Send operation has failed, or the maximum allocation size is exceeded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SendAsync(System.Byte[],System.Net.Sockets.SocketFlags)">
            <summary>
            Non-Blocking transmission of a byte array to the remote host
            </summary>
            
            <param name="DataArray">The byte array data to send</param>
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp Send operation has failed, or the maximum allocation size is exceeded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SendAsync(System.IO.MemoryStream,System.Net.Sockets.SocketFlags)">
            <summary>
            Non-Blocking transmission of a stream to the remote host
            </summary>
            
            <param name="DataStream">The stream data to send</param>
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp Send operation has failed, or the maximum allocation size is exceeded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SendAsync(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            <summary>
            Non-Blocking transmission of a byte array to the remote host
            </summary>
            
            <param name="DataArray">The byte array data to send</param>
            <param name="Offset">The start position within the buffer</param>
            <param name="Size">The number of bytes to send</param>
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp Send operation has failed, or the maximum allocation size is exceeded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SendAsync(System.IO.MemoryStream,System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
            <summary>
            Non-Blocking transmission of stream data to the remote host
            </summary>
            
            <param name="DataStream">The data stream to send</param>
            <param name="Offset">The start position within the stream</param>
            <param name="Size">The number of bytes to send</param>
            <param name="SocketFlag">The bitwise combination of Socket Flags (default is None)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the Tcp Send operation has failed, or the maximum allocation size is exceeded</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SendCallback(System.IAsyncResult)">
            <summary>
            The Send callback
            </summary>
            
            <param name="Ar">the IAsyncResult</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SendFile(System.String)">
            <summary>
            Synchronous file transmission operation
            </summary>
            
            <param name="FilePath">The full path to the file</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Connected">
            <summary>
            The Client Connected event; fires each time a connection has been established
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Networking.TcpSocket.DisConnected">
            <summary>
            The Client Connected event; fires each time a connection has been established
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Networking.TcpSocket.DataReceived">
            <summary>
            The Data Received event; fires each time data has been received
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.Client">
            <summary>
            Get: The TCP Client Socket instance
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.IsConnected">
            <summary>
            Get: The TCP Client is connected
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.IsListening">
            <summary>
            Get: The TCP Client is actively listening for a connection
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.IsServer">
            <summary>
            Get: The TCP Client was started as a Listener
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.LocalAddress">
            <summary>
            Get: The local ip address
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.LocalPort">
            <summary>
            Get: The local port number
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.MaxAllocation">
            <summary>
            Get: Maximum allocation size of a Send or Receive buffer
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoSocketException">Thrown if the size is less than 1, or greater than 1GB</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ReceiveBufferSize">
            <summary>
            Get/Set: The size of the TCP receive buffer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ReceiveTimeout">
            <summary>
            Get/Set: The synchronous read time out
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SendBufferSize">
            <summary>
            Get/Set: The size of the TCP transmission buffer
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.SendTimeout">
            <summary>
            Get/Set: The synchronous send time out
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.RemoteAddress">
            <summary>
            Get: The remote ip address
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.RemotePort">
            <summary>
            Get: The remote port number
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Networking.TcpSocket.TcpStream">
            <summary>
            Get: The underlying Client NetworkStream instance
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Networking.TcpSocket.ConnectedDelegate">
            <summary>
            The Client Connected delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:System.Net.Sockets.SocketAsyncEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Networking.TcpSocket.DisConnectedDelegate">
            <summary>
            The Packet Received delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="Flag">The socket error flag</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Networking.TcpSocket.DataReceivedDelegate">
            <summary>
            The Packet Received delegate
            </summary>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Networking.DataReceivedEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Utility.BigIntUtils">
            <summary>
            This class is a utility class for manipulating <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> arrays
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.Equals(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Checks if two <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> arrays contain the same entries
            </summary>
            
            <param name="A">The first BigInteger array</param>
            <param name="B">The second BigInteger array</param>
            
            <returns>Returns A[] is equal to B[]</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.Fill(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Fill the given <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> array with the given value
            </summary>
            
            <param name="A">The BigInteger array</param>
            <param name="Value">The BigInteger value</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.SubArray(VTDev.Libraries.CEXEngine.Numeric.BigInteger[],System.Int32,System.Int32)">
            <summary>
            Generates a subarray of a given <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> array
            </summary>
            
            <param name="Input">The input BigInteger array</param>
            <param name="Start">The start index</param>
            <param name="End">The end index</param>
            
            <returns>Returns a subarray of <c>input</c>, ranging from <c>Start</c> to <c>End</c></returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.ToIntArray(VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Converts a <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> array into an integer array
            </summary>
            
            <param name="Input">The BigInteger array</param>
            
            <returns>Returns the integer array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.ToIntArrayModQ(System.Int32,VTDev.Libraries.CEXEngine.Numeric.BigInteger[])">
            <summary>
            Converts a BigInteger array into an integer array, reducing all BigIntegers mod q
            </summary>
            
            <param name="Q">The modulus</param>
            <param name="Input">The BigInteger array</param>
            
            <returns>Returns the integer array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Utility.BigIntUtils.ToMinimalByteArray(VTDev.Libraries.CEXEngine.Numeric.BigInteger)">
            <summary>
            Return the value of <see cref="T:VTDev.Libraries.CEXEngine.Numeric.BigInteger"/> as a byte array
            </summary>
            
            <param name="Value">The <c>BigInteger</c> value to be converted to a byte array</param>
            
            <returns>Returns the value <c>big</c> as byte array</returns>
            
            <remarks>
            <para>Although BigInteger has such a method, it uses an extra bit to indicate the sign of the number.
            For elliptic curve cryptography, the numbers usually are positive.
            Thus, this helper method returns a byte array of minimal length, ignoring the sign of the number.</para>
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng">
            <summary>
            <h3>An implementation of a Cryptographically Secure PRNG using the RNGCryptoServiceProvider class.</h3>
            <para>Implements a random number generator using the RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class</para>
            </summary>
            
            <example>
            <code>
            int x;
            using (IRandom rnd = new CSPRng())
                x = rnd.Next();
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.3.0.0">Initial release</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <remarks>
            <description><h4>Guiding Publications:</h4>:</description>
            <list type="number">
            <item><description>RNGCryptoServiceProvider<cite>RNGCryptoServiceProvider</cite> class documentation.</description></item>
            <item><description>NIST SP800-90B: <cite>SP800-90B</cite>Recommendation for the Entropy Sources Used for Random Bit Generation.</description></item>
            <item><description>NIST Fips 140-2: <cite>Fips 140-2</cite>Security Requirments For Cryptographic Modules.</description></item>
            <item><description>RFC 4086: <cite>RFC 4086</cite>Randomness Requirements for Security.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.#ctor">
            <summary>
            Initialize the class
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoRandomException">Thrown if RNGCryptoServiceProvider initialization failed</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.GetBytes(System.Int32)">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Size">Size of requested byte array</param>
            
            <returns>Random byte array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.GetBytes(System.Byte[])">
            <summary>
            Fill an array with pseudo random bytes
            </summary>
            
            <param name="Data">Array to fill with random bytes</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next(System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Next(System.Int32,System.Int32)">
            <summary>
            Get a ranged pseudo random 32bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong">
            <summary>
            Get a pseudo random 32bit integer
            </summary>
            
            <returns>Random Int32</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong(System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.NextLong(System.Int64,System.Int64)">
            <summary>
            Get a ranged pseudo random 64bit integer
            </summary>
            
            <param name="Minimum">Minimum value</param>
            <param name="Maximum">Maximum value</param>
            
            <returns>Random Int64</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Reset">
            <summary>
            Reset the RNGCryptoServiceProvider instance
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Prng.CSPRng.Name">
            <summary>
            Algorithm name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">
            <summary>
            Pseudo Random Generators
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.BBSG">
            <summary>
            A Blum-Blum-Shub random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.CCG">
            <summary>
            A Cubic Congruential Generator II (CCG) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.CSPRng">
            <summary>
             A Secure PRNG using RNGCryptoServiceProvider
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.CTRPrng">
            <summary>
            A Symmetric Cipher Counter mode random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.DGCPrng">
            <summary>
            A Digest Counter mode random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.MODEXPG">
            <summary>
            A Modular Exponentiation Generator (MODEXPG) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.PBPrng">
            <summary>
            An implementation of a passphrase based PKCS#5 random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.QCG1">
            <summary>
            A Quadratic Congruential Generator I (QCG-I) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.QCG2">
            <summary>
            A Quadratic Congruential Generator II (QCG-II) random number generator
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs.SP20Prng">
            <summary>
            An implementation of a Salsa20 Counter based Prng
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024">
            <summary>
            <h3>Keccak1024: An implementation of the SHA-3 Keccak digest.</h3>
            <h4>Note: Experimental! may need future adjustments</h4>
            <para>SHA-3 competition winner<cite>SHA-3 Standardization</cite>: The Keccak<cite>Keccak</cite> digest</para>
            </summary>
            
            <example>
            <description>Example using an <c>IDigest</c> interface:</description>
            <code>
            using (IDigest hash = new Keccak1024())
            {
                // compute a hash
                byte[] Output = ComputeHash(Input);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2014/11/11" version="1.2.0.0">Initial release</revision>
            <revision date="2015/01/23" version="1.3.0.0">Changes to formatting and documentation</revision>
            <revision date="2015/01/23" version="1.3.5.0">Rewritten for improvements to security and speed</revision>
            <revision date="2015/07/01" version="1.4.0.0">Added library exceptions</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Implementation Notes:</h4></description>
            <list type="bullet">
            <item><description>Hash sizes are 128 and 96 bytes (1024, 768 bits).</description></item>
            <item><description>Block sizes are 40, and 54 bytes (288, 320 bits).</description></item>
            <item><description>Use the <see cref="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockSize"/> property to determine block sizes at runtime.</description></item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.ComputeHash(System.Byte[])"/> method wraps the <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)"/> and DoFinal methods.</description>/&gt;</item>
            <item><description>The <see cref="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DoFinal(System.Byte[],System.Int32)"/> method resets the internal state.</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>SHA3 <see href="http://keccak.noekeon.org/Keccak-submission-3.pdf">Keccak Submission</see>.</description></item>
            <item><description>SHA3: <see href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">Third-Round Report of the SHA-3 Cryptographic Hash Algorithm Competition</see>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent HashLib project implementation <see href="http://hashlib.codeplex.com/">Keccak.cs</see> class, 
            and the <see href="https://github.com/gvanas/KeccakCodePackage">Keccak Code Package</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.#ctor(System.Int32)">
            <summary>
            Initialize the digest
            </summary>
            
            <param name="DigestSize">Digest return size in bits</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockUpdate(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Update the SHA3 buffer
            </summary>
            
            <param name="Input">Input data</param>
            <param name="InOffset">Offset within Input array</param>
            <param name="Length">Amount of data to process in bytes</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if an invalid Input size is chosen</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.ComputeHash(System.Byte[])">
            <summary>
            Get the Hash value
            </summary>
            
            <param name="Input">Input data</param>
            
            <returns>Hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DoFinal(System.Byte[],System.Int32)">
            <summary>
            Do final processing and get the hash value
            </summary>
            
            <param name="Output">The Hash value container</param>
            <param name="OutOffset">The starting offset within the Output array</param>
            
            <returns>Size of Hash value</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoHashException">Thrown if Output array is too small</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Reset">
            <summary>
            Reset the internal state
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Update(System.Byte)">
            <summary>
            Update the digest with a single byte
            </summary>
            
            <param name="Input">Input byte</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.BlockSize">
            <summary>
            Get: The Digests internal blocksize in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.DigestSize">
            <summary>
            Get: Size of returned digest in bytes
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Digest.Keccak1024.Name">
            <summary>
            Get: Digest name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.GF2Field">
            <summary>
            This class provides the basic operations like addition, multiplication and finding the multiplicative inverse of an element in GF2^8.
            <para>The operations are implemented using the irreducible polynomial 1+x^2+x^3+x^6+x^8 ( 1 0100 1101 = 0x14d ).
            This class makes use of lookup tables(exps and logs) for implementing the operations in order to increase the efficiency of Rainbow.</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.GF2Field.AddElem(System.Int16,System.Int16)">
            <summary>
            This function calculates the sum of two elements as an operation in GF2^8
            </summary>
            
            <param name="X">The first element that is to be added</param>
            <param name="Y">The second element that should be add</param>
            
            <returns>Returns the sum of the two elements x and y in GF2^8</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.GF2Field.GetExp(System.Int16)">
            <summary>
            This function returns the values of exps-lookup table which correspond to the input
            </summary>
            
            <param name="X">The index in the lookup table exps</param>
            
            <returns>Returns exps-value, corresponding to the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.GF2Field.GetLog(System.Int16)">
            <summary>
            This function returns the values of logs-lookup table which correspond to the input
            </summary>
            
            <param name="X">The index in the lookup table logs</param>
            
            <returns>Returns logs-value, corresponding to the input</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.GF2Field.InvElem(System.Int16)">
            <summary>
            This function computes the multiplicative inverse of a given element in GF2^8 The 0 has no multiplicative inverse and in this case 0 is returned.
            </summary>
            
            <param name="X">The element which multiplicative inverse is to be computed</param>
            
            <returns>Returns the multiplicative inverse of the given element, in case it exists or 0, otherwise</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Sign.RNBW.Arithmetic.GF2Field.MultElem(System.Int16,System.Int16)">
            <summary>
            This function multiplies two elements in GF2^8; if one of the two elements is 0, 0 is returned
            </summary>
            
            <param name="X">The first element to be multiplied</param>
            <param name="Y">The second element to be multiplied</param>
            
            <returns>Returns the product of the two input elements in GF2^8</returns>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign">
             <summary>
             An Ring-LWE One Time Sign (OTS) message sign and verify implementation.
             <para>Sign: uses the specified digest to hash a message; the hash value is then encrypted with a RLWE public key.
             Verify: decrypts the RLWE cipher text, and then compares the value to a hash of the message.</para>
             </summary>
             
             <example>
             <description>Example of using the signing and verifying an array:</description>
             <code>
             RLWEParameters ps = RLWEParamSets.RLWEN256Q768;
             RLWEKeyGenerator gen = new RLWEKeyGenerator(ps);
             IAsymmetricKeyPair kp = gen.GenerateKeyPair();
             byte[] code;
             byte[] data = new byte[100];
            
             // get the message code for an array of bytes
             using (RLWESign sgn = new RLWESign(ps))
             {
                 sgn.Initialize(new RLWEKeyPair(kp.PublicKey));
                 code = sgn.Sign(data, 0, data.Length);
             }
            
             // authenticate the message
             using (RLWESign sgn = new RLWESign(ps))
             {
                 sgn.Initialize(new RLWEKeyPair(kp.PrivateKey));
                 bool valid = sgn.Verify(data, 0, data.Length, code);
             }
             </code>
             </example>
             
             <revisionHistory>
             <revision date="2015/06/07" version="1.4.0.0">Initial release</revision>
             </revisionHistory>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE RLWEPublicKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE RLWEPrivateKey Class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
             
             <remarks>
             <description><h4>Implementation Notes:</h4></description>
             <list type="bullet">
             <item><description>Signing is intended as a one time only key implementation (OTS); keys should never be re-used.</description></item>
             <item><description>Digests can be any of the implemented digests; Blake, Keccak, SHA-2 or Skein.</description></item>
             </list>
             
             <description><h4>Code Base Guides:</h4></description>
             <list type="table">
             <item><description>Based on the Ring-LWE-Encryption C version: <see href="https://github.com/ruandc/Ring-LWE-Encryption">ruandc/Ring-LWE-Encryption</see>.</description></item>
             </list> 
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters,VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="CipherParams">The RLWE cipher used to encrypt the hash</param>
            <param name="Digest">The type of digest engine used</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the RLWE Public (Sign) or Private (Verify) key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid key pair is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Reset">
            <summary>
            Reset the underlying digest engine
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Sign(System.IO.Stream)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="InputStream">The stream containing the data</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid key pair is used, or signer has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Sign(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Get the signing code for a stream
            </summary>
            
            <param name="Input">The byte array contining the data</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The encrypted hash code</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if input array is too short, signer is not initialized, or keys are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Verify(System.IO.Stream,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="InputStream">The stream containing the data to test</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if signer is not initialized, or keys are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Verify(System.Byte[],System.Int32,System.Int32,System.Byte[])">
            <summary>
            Test the hashed value of a stream against the decrypted code
            </summary>
            
            <param name="Input">The stream containing the data to test</param>
            <param name="Offset">The starting offset within the Input array</param>
            <param name="Length">The number of bytes to process</param>
            <param name="Code">The encrypted hash code</param>
            
            <returns>Returns <c>true</c> if the codes match</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if input array is too short, signer is not initialized, or keys are invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Compute(System.IO.Stream)">
            <summary>
            Compute the hash from a stream
            </summary>
            
            <param name="InputStream">The input stream</param>
            
            <returns>The hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compute the hash from a byte array
            </summary>
            
            <param name="Input">The data byte array</param>
            <param name="Offset">The starting offset within the array</param>
            <param name="Length">The number of bytes to process</param>
            
            <returns>The hash value</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Engine">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.IsSigner">
            <summary>
            Get: This class is initialized for Signing with the Public key
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricSignException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can decrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWESign.Name">
            <summary>
            Get: Signer name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt">
            <summary>
            An Ring-LWE cipher implementation
            </summary>
            
            <example>
            <description>Example of encrypting and decrypting an array:</description>
            <code>
            RLWEParameters encParams = new RLWEParameters(512, 12289, 12.18, new byte[] { 2, 5, 1 }))
            RLWEKeyGenerator keyGen = new RLWEKeyGenerator(encParams);
            IAsymmetricKeyPair keyPair = keyGen.GenerateKeyPair();
            
            byte[] data = new byte[64];
            byte[] enc, dec;
            
            // encrypt an array
            using (RLWEEncrypt cipher = new RLWEEncrypt(encParams))
            {
                cipher.Initialize(keyPair.PublicKey);
                enc = cipher.Encrypt(data);
            }
            
            // decrypt the cipher text
            using (RLWEEncrypt cipher = new RLWEEncrypt(encParams))
            {
                cipher.Initialize(keyPair.PrivateKey);
                dec = cipher.Decrypt(enc);
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/06/07" version="1.4.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE RLWEPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE RLWEPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest">VTDev.Libraries.CEXEngine.Crypto.Digest.IDigest Interface</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration Digests Enumeration</seealso>
            
            <remarks>
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>Efficient Software Implementation of Ring-LWE Encryption<cite>Ring-LWE Encryption</cite>.</description></item>
            <item><description>Compact Ring-LWE Cryptoprocessor<cite>Ring-LWE Cryptoprocessor</cite>.</description></item>
            <item><description>A Simple Provably Secure Key Exchange Scheme Based on the Learning with Errors Problem<cite>RLWE Scheme</cite>.</description></item>
            <item><description>The Knuth-Yao Quadrangle-Inequality Speedup is a Consequence of Total-Monotonicity<cite>Knuth-Yao Quadrangle-Inequality Speedup</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Based on the Ring-LWE-Encryption C version: <see href="https://github.com/ruandc/Ring-LWE-Encryption">ruandc/Ring-LWE-Encryption</see>.</description></item>
            </list> 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters)">
            <summary>
            Initialize this class; Prng is created automatically
            </summary>
            
            <param name="CipherParams">The cipher engine</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Initialize this class with an initialized Prng
            </summary>
            
            <param name="CipherParams">The cipher parameters</param>
            <param name="Engine">The initialized cipher prng</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.Decrypt(System.Byte[])">
            <summary>
            Decrypt a cipher text
            </summary>
            
            <param name="Input">The cipher text</param>
            
            <returns>The plain text</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.Encrypt(System.Byte[])">
            <summary>
            Encrypt a plain text message
            </summary>
            
            <param name="Input">The plain text</param>
            
            <returns>The cipher text</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if cipher has not been initialized, or input text is too long</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.GetKeySize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Return the key size of the working key
            </summary>
            
            <param name="AsmKey">The key</param>
            
            <returns>The size of the key</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if cipher has not been initialized, or key is invalid</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.Initialize(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey)">
            <summary>
            Initialize the cipher.
            <para>Requires a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPublicKey"/> for encryption, or a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEPrivateKey"/> for decryption</para>
            </summary>
            
            <param name="AsmKey">The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/> containing the Ring-LWE Public or Private key</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the cipher engine
            </summary>
            
            <param name="Prng">The Prng</param>
            
            <returns>An initialized prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.IsEncryption">
            <summary>
            Get: The cipher is initialized for encryption
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.IsInitialized">
            <summary>
            Get: The cipher has been initialized with a key
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.MaxPlainText">
            <summary>
            Get: The maximum number of bytes the cipher can encrypt
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if cipher has not been initialized</exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.RLWE.RLWEEncrypt.Name">
            <summary>
            Get: Cipher name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets">
            <summary>
            A set of pre-defined EES encryption parameter sets 
            based on <see href="https://github.com/tbuktu/ntru/blob/master/src/main/java/net/sf/ntru/encrypt/EncryptionParameters.java">EncryptionParameters.java</see>.
            <para>Note: Sets names starting with 'A' (ex. A2011439), are the recommended sets from the original author (T. Buktu). Sets pre-fixed with 'F' (ex. FE1087EP2) are the fast polynomial versions. 
            Sets prefixed with 'CX' (ex. CX1931) are experimental, they use larger N, df, and dm values, and a 512 bit digest for the IGF and mask.</para>
            </summary>
            
            <remarks>
            <description><h4>Parameter OId:</h4></description>
            <list type="bullet">
            <item><description>A Parameter Set OId (uniquely identifies the parameter set), is always the first four bytes of a serialized parameter set.</description></item>
            <item><description>The OId format is ordered as: <c>Family</c>, <c>Set</c>, <c>SubSet</c>, and <c>Unique</c>.</description></item>
            <item><description>An NTRU parameters <c>Family</c> designator (first byte) is always the value <c>2</c>, and corresponds to its entry in the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.AsymmetricEngines"/> enumeration.</description></item>
            <item><description>The second byte: <c>Set</c>, defines the parameter origin: ESS is the value <c>1</c>, APR is <c>2</c>, and CEX is <c>3</c>.</description></item>
            <item><description>The third byte: <c>SubSet</c>, defines the PolyType; simple <c>1</c> or product form <c>2</c>.</description></item>
            <item><description>The fourth byte can be a unique designator.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.FromId(System.Byte[])">
            <summary>
            Retrieve a parameter set by its identity code
            </summary>
            
            <param name="OId">The 4 byte parameter set identity code</param>
            
            <returns>A parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.FromName(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames)">
            <summary>
            Retrieve a parameter set by its enumeration name
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>A populated parameter set</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid or unknown OId is used</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.GetID(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames)">
            <summary>
            Retrieve the OId for a parameter set
            </summary>
            
            <param name="Name">The enumeration name</param>
            
            <returns>The parameters 4 byte OId</returns>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if an invalid name is used</exception>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.CX1931SK512">
            <summary>
            Experimental, use with caution. Uses a larger ring and Skein512.
            <para>MaxText: 233, N:1931 Q:2048, Df:380, PublicKey Size: 2660, PrivateKey Size: 388</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.CX1861SK512">
            <summary>
            Experimental, use with caution. Uses a larger ring and Skein512.
            <para>MaxText: 219, N:1861 Q:2048, Df:290, PublicKey Size: 2563, PrivateKey Size: 374</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1087EP2">
            <summary>
            A conservative parameter set that gives 256 bits of security and is optimized for key size.
            <para>MaxText: 170, N:1087 Q:2048, Df:120, PublicKey Size: 1499, PrivateKey Size: 221</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1087EP2FAST">
            <summary>
            A product-form version of <c>EES1087EP2</c>
            <para>MaxText: 170, N:1087 Q:2048, Df:120, PublicKey Size: 1499, PrivateKey Size: 93</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1171EP1">
            <summary>
            A conservative parameter set that gives 256 bits of security and is a tradeoff between key size and encryption/decryption speed.
            <para>MaxText: 186, N:1171 Q:2048, Df:106, PublicKey Size: 1615, PrivateKey Size: 237</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1171EP1FAST">
            <summary>
            A product-form version of <c>EES1171EP1</c>
            <para>MaxText: 186, N:1171 Q:2048, Df:106, PublicKey Size: 1615, PrivateKey Size: 237</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1499EP1">
            <summary>
            A conservative parameter set that gives 256 bits of security and is optimized for encryption/decryption speed.
            <para>MaxText: 248, N:1499 Q:2048, Df:79, PublicKey Size: 2066, PrivateKey Size: 302</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.EES1499EP1FAST">
            <summary>
            A product-form version of <c>EES1499EP1</c>
            <para>MaxText: 248, N:1499 Q:2048, Df:79, PublicKey Size: 2066, PrivateKey Size: 302</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.APR2011743">
            <summary>
            A parameter set that gives 256 bits of security and uses simple ternary polynomials.
            <para>MaxText: 106, N:743 Q:2048, Df:248, PublicKey Size: 1026, PrivateKey Size: 153</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.APR2011743FAST">
            <summary>
            Like <c>APR2011_743</c>, this parameter set gives 256 bits of security but uses product-form polynomials and <c>f=1+pF</c>. 
            <para>MaxText: 106, N:743 Q:2048, Df:248, PublicKey Size: 1026, PrivateKey Size: 123</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.APR2011439">
            <summary>
            A parameter set that gives 128 bits of security and uses simple ternary polynomials.
            <para>MaxText: 65, N:439 Q:2048, Df:146, PublicKey Size: 608, PrivateKey Size: 92</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.APR2011439FAST">
            <summary>
            Like <c>APR2011_439</c>, this parameter set gives 128 bits of security but uses product-form polynomials and <c>f=1+pF</c>.
            <para>MaxText: 65, N:439 Q:2048, Df:146, PublicKey Size: 608, PrivateKey Size: 79</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames">
            <summary>
            EES set id's for common parameter values
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.CX1931">
            <summary>
            Experimental, use with caution. Uses a larger ring and Skein512.
            <para>MaxText: 233, N:1931 Q:2048, Df:380, PublicKey Size: 2660, PrivateKey Size: 388</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.CX1861">
            <summary>
            Experimental, use with caution. Uses a larger ring and Skein512.
            <para>MaxText: 219, N:1861 Q:2048, Df:290, PublicKey Size: 2563, PrivateKey Size: 374</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.E1087EP2">
            <summary>
            A conservative parameter set that gives 256 bits of security and is optimized for key size.
            <para>MaxText: 170, N:1087 Q:2048, Df:120, PublicKey Size: 1499, PrivateKey Size: 221</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.E1171EP1">
            <summary>
            A conservative parameter set that gives 256 bits of security and is a tradeoff between key size and encryption/decryption speed.
            <para>MaxText: 186, N:1171 Q:2048, Df:106, PublicKey Size: 1615, PrivateKey Size: 237</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.E1499EP1">
            <summary>
            A conservative parameter set that gives 256 bits of security and is optimized for encryption/decryption speed.
            <para>MaxText: 248, N:1499 Q:2048, Df:79, PublicKey Size: 2066, PrivateKey Size: 302</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.A2011439">
            <summary>
            A parameter set that gives 128 bits of security and uses simple ternary polynomials.
            <para>MaxText: 65, N:439 Q:2048, Df:146, PublicKey Size: 608, PrivateKey Size: 92</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.A2011743">
            <summary>
            A parameter set that gives 256 bits of security and uses simple ternary polynomials.
            <para>MaxText: 106, N:743 Q:2048, Df:248, PublicKey Size: 1026, PrivateKey Size: 153</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FE1087EP2">
            <summary>
            A product-form version of <c>EES1087EP2</c>
            <para>MaxText: 170, N:1087 Q:2048, Df:120, PublicKey Size: 1499, PrivateKey Size: 93</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FE1171EP1">
            <summary>
            A product-form version of <c>EES1171EP1</c>
            <para>MaxText: 186, N:1171 Q:2048, Df:106, PublicKey Size: 1615, PrivateKey Size: 237</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FE1499EP1">
            <summary>
            A product-form version of <c>EES1499EP1</c>
            <para>MaxText: 248, N:1499 Q:2048, Df:79, PublicKey Size: 2066, PrivateKey Size: 302</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FA2011743">
            <summary>
            Like <c>APR2011743</c>, this parameter set gives 256 bits of security but uses product-form polynomials and <c>f=1+pF</c>. 
            <para>MaxText: 106, N:743 Q:2048, Df:248, PublicKey Size: 1026, PrivateKey Size: 123</para>
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParamSets.NTRUParamNames.FA2011439">
            <summary>
            Like <c>APR2011_439</c>, this parameter set gives 128 bits of security but uses product-form polynomials and <c>f=1+pF</c>.
            <para>MaxText: 65, N:439 Q:2048, Df:146, PublicKey Size: 608, PrivateKey Size: 79</para>
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator">
            <summary>
            This class implements the key pair generation of the NTRU Public Key Crypto System
            </summary>
            
            <example>
            <description>Example of generating a key pair:</description>
            <code>
            // use a predefined parameters set
            NtruParameters ps = DefinedParameters.EES1087EP3;
            
            using (NTRUKeyGenerator gen = new NTRUKeyGenerator(ps))
            {
                // generate a keypair
                NtruKeyPair kp = gen.GenerateKeyPair();
            }
            </code>
            </example>
            
            <revisionHistory>
            <revision date="2015/01/23" version="1.0.0.0">Initial release</revision>
            </revisionHistory>
            
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUKeyPair Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPublicKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUPublicKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUPrivateKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUPrivateKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU NTRUParameters Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricCipher">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricCipher Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKeyPair Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces IAsymmetricKey Class</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests Enumeration</seealso>
            <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs">VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs Enumeration</seealso>
            
            <remarks>
            <description><h5>Key Generation:</h5></description>
            <list type="table">
            <item><description>Randomly generate polynomials f and g in Df, Dg respectively.</description></item>
            <item><description>Invert f in Rq to obtain fq, invert f in Rp to obtain fp, and check that g is invertible in Rq.</description></item>
            <item><description>The public key h = p  g  fq (mod q). The private key is the pair (f, fp).</description></item>
            </list>
            
            <description><h4>Guiding Publications:</h4></description>
            <list type="number">
            <item><description>NTRU: A Ring Based Public Key Crypto System<cite>NTRU Crypto</cite>.</description></item>
            <item><description>Optimizations for NTRU<cite>NTRU Optimizations</cite>.</description></item>
            <item><description>Adaptive Key Recovery Attacks on NTRU-based Somewhat Homomorphic Encryption Schemes<cite>NTRU Adaptive</cite>.</description></item>
            <item><description>Efficient Embedded Security Standards (EESS)<cite>NTRU EESS</cite>.</description></item>
            <item><description>Practical lattice-based cryptography: NTRUEncrypt and NTRUSign<cite>NTRU Practical</cite>.</description></item>
            <item><description>NTRU Cryptosystems Technical Report<cite>NTRU Technical</cite>.</description></item>
            </list>
            
            <description><h4>Code Base Guides:</h4></description>
            <list type="table">
            <item><description>Inspired by the excellent java project NTRU Encrypt by Tim Buktu: <see href="https://github.com/tbuktu/ntru/description">Release 1.2</see>, and
            the NTRUOpenSourceProject/ntru-crypto project provided by Security Innovation, Inc: <see href="https://github.com/NTRUOpenSourceProject/ntru-crypto">Release 1.2</see>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters,System.Boolean)">
            <summary>
            Constructs a new instance with a set of encryption parameters
            </summary>
            
            <param name="CipherParams">Encryption parameters</param>
            <param name="Parallel">Use parallel processing when generating a key; set to false if using a passphrase type generator (default is true)</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoAsymmetricException">Thrown if a Prng that requires pre-initialization is specified; (wrong constructor)</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUParameters,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,System.Boolean)">
            <summary>
            Use an initialized prng to generate the key; use this constructor with an Rng that requires pre-initialization, i.e. PBPrng
            </summary>
            
            <param name="CipherParams">The NTRUParameters instance containing the cipher settings</param>
            <param name="RngEngine">An initialized Prng instance</param>
            <param name="Parallel">Use parallel processing when generating a key; set to false if using a passphrase type generator (default is true)</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateKeyPair">
            <summary>
            Generates a new encryption key pair
            </summary>
            
            <returns>A key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateKeyPair(System.Byte[],System.Byte[])">
            <summary>
            Generates an encryption key pair using a passphrase based prng.
            <para>Invoking this method with the same passphrase and salt will always return the same key pair.</para>
            </summary>
            
            <param name="Passphrase">The passphrase</param>
            <param name="Salt">Salt for the passphrase; can be <c>null</c> but this is strongly discouraged</param>
            
            <returns>A populated IAsymmetricKeyPair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateSalt(System.Int32)">
            <summary>
            A convenience method that generates a random salt vector for key pair generation.
            </summary>
            
            <param name="Size">Byte length of the new salt</param>
            
            <returns>A new salt vector</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateKeyPair(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a new encryption key pair
            </summary>
            
            <param name="RngEngine">The random number generator to use for generating the secret polynomials f and g</param>
            
            <returns>A key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateKeyPair(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <summary>
            Generates a new encryption key pair
            </summary>
            
            <param name="RngF">The random number generator to use for generating the secret polynomial f</param>
            <param name="RngG">The random number generator to use for generating the secret polynomial g</param>
            
            <returns>A key pair</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GenerateG(VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom)">
            <remarks>
            Generates the ephemeral secret polynomial 'g'.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest engine
            </summary>
            
            <param name="Digest">Engine type</param>
            
            <returns>Instance of digest</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the Prng
            </summary>
            
            <param name="Prng">Prng type</param>
            
            <returns>Instance of Prng</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.NTRUKeyGenerator.Name">
            <summary>
            Get: Generator name
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519">
             <summary>
             Generic 64-bit integer implementation of Curve25519 ECDH.
             <para>Written by Matthijs van Duin, 200608242056
             Based on work by Daniel J Bernstein; 
             A state of the art Diffie-Hellman function<cite>A state-of-the-art Diffie-Hellman function</cite>
             Ported from C to Java by Dmitry Skiba [sahn0], 23/02/08.
             Ported to C# by John Underhill, 14/03/15.
             Original: <see href="http://cds.xs4all.nl:8081/ecdh/"/></para>
             </summary>
             
             <remarks>
             <example>
             <description>DIGITAL SIGNATURES : Deterministic EC-KCDSA</description>
             <code>
                s is the private key for signing
                P is the corresponding internal key
                Z is the context data (signer internal key or certificate, etc)
             </code>
             
             <description>signing:</description>
             <code>
                m = hash(Z, message)
                x = hash(m, s)
                keygen25519(Y, NULL, x);
                r = hash(Y);
                h = m XOR r
                sign25519(v, h, x, s);
            
                output (v,r) as the signature
             </code>
             
             <description>verification:</description>
             <code>
                m = hash(Z, message);
                h = m XOR r
                verify25519(Y, v, h, P)
            
                confirm  r == hash(Y)
             </code>
             </example>
             
             <para>It would seem to me that it would be simpler to have the signer directly do 
             h = hash(m, Y) and send that to the recipient instead of r, who can verify 
             the signature by checking h == hash(m, Y).  If there are any problems with 
             such a scheme, please let me know.</para>
             <para>Also, EC-KCDSA (like most DS algorithms) picks x random, which is a waste of 
             perfectly good entropy, but does allow Y to be calculated in advance of (or 
             parallel to) hashing the message.</para>
             </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Clamp(System.Byte[])">
            <summary>
            Private key clamping
            </summary>
            
            <param name="K">Private key for key agreement</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Keygen(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Key-pair generation
            </summary>
            
            <param name="P">Public key</param>
            <param name="S">Private key for signing</param>
            <param name="K">Private key for key agreement</param>
            
            <remarks>if S is not NULL, this function has data-dependent timing</remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Curve(System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Key agreement
            </summary>
            
            <param name="Z">Shared secret (needs hashing before use)</param>
            <param name="K">Private key for key agreement</param>
            <param name="P">Peer's internal key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Sign(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Signature generation primitive, calculates (x-h)s mod q
            </summary>
            
            <param name="V">Signature value</param>
            <param name="H">Signature hash (of message, signature pub key, and context data)</param>
            <param name="X">Signature private key</param>
            <param name="S">Private key for signing</param>
            
            <returns>True on success, false on failure (use different x or h)</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Verify(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <summary>
            Signature verification primitive, calculates Y = vP + hG
            </summary>
            
            <param name="Y">Signature internal key</param>
            <param name="V">Signature value</param>
            <param name="H">Signature hash</param>
            <param name="P">Public key</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MulaSmall(System.Byte[],System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <remarks>
            p[m..n+m-1] = q[m..n+m-1] + z * x, n is the size of x 
            n+m is the size of p and q
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Mula32(System.Byte[],System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <remarks>
            p += x * y * z  where z is a small integer.
            x is size 32, y is size t, p is size 32+t
            y is allowed to overlap with p+32 if you don't care about the upper half
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.DivMod(System.Byte[],System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <remarks>
            divide r (size n) by d (size t), returning quotient q and remainder r
            quotient is size n-t+1, remainder is size t
            requires t > 0 &amp; d[t-1] != 0
            requires that r[-1] and d[-1] are valid memory locations
            q may overlap with r+t
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Egcd32(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <remarks>
            Returns x if a contains the gcd, y if b.
            Also, the returned buffer contains the inverse of a mod b, as 32-byte signed.
            x and y must have 64 bytes space for temporary use.
            requires that a[-1] and b[-1] are valid memory locations
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Unpack(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Byte[])">
            <remarks>
            Convert to internal format from little-endian byte format
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.IsOverflow(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Check if reduced-form input >= 2^255-19
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Pack(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Byte[])">
            <remarks>
            Convert from internal format to little-endian byte format. 
            The number must be in a reduced form which is output by the following ops:
            unpack, mul, sqr
            set --  if input in range 0 .. P25
            If you're unsure if the number is reduced, first multiply it by 1.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Copy(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Copy a number
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Set(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Int32)">
            <remarks>
            Set a number to value, which must be in range -185861411 .. 185861411
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.AddXY(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Add/subtract two numbers.  The inputs must be in reduced form, and the 
            output isn't, so to do another addition or subtraction on the output, 
            first multiply it by one to reduce it. 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MulSmall(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Int64)">
            <remarks>
            Multiply a number by a small integer in range -185861411 .. 185861411.
            The output is in reduced form, the input x need not be.  x and xy may point
            to the same buffer. 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Mul(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Multiply two numbers.  The output is in reduced form, the inputs need not be.
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Sqr(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Square a number. Optimization of  mul25519(x2, x, x)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Recip(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,System.Int32)">
            <remarks>
            Calculates a reciprocal. The output is in reduced form, the inputs need not be. 
            Simply calculates  y = x^(p-2)  so it's not too fast. 
            When sqrtassist is true, it instead calculates y = x^((p-5)/8)
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.IsNegative(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Checks if x is "negative", requires reduced input 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Sqrt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            A square root
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MontPrep(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            t1 = ax + az
            t2 = ax - az 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MontAdd(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            A = P + Q   where:
            X(A) = ax/az
            X(P) = (t1+t2)/(t1-t2)
            X(Q) = (t3+t4)/(t3-t4)
            X(P-Q) = dx
            clobbers t1 and t2, preserves t3 and t4 
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.MontDbl(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            B = 2 * Q   where:
            X(B) = bx/bz
            X(Q) = (t3+t4)/(t3-t4)
            clobbers t1 and t2, preserves t3 and t4
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.XtoY2(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10)">
            <remarks>
            Y^2 = X^3 + 486662 X^2 + X
            t is a temporary
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Core(System.Byte[],System.Byte[],System.Byte[],System.Byte[])">
            <remarks>
            P = kG   and  s = sign(P)/k
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Encrypt.NTRU.Curve.Curve25519.Long10">
            <remarks>
            Using this class instead of long[10] to avoid bounds checks.
            </remarks>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes">
            <summary>
            The <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/> primary message types.
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes.Service">
            <summary>
            The packet contains a service instruction
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes.Message">
            <summary>
            The packet contains message data
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes.Transfer">
            <summary>
            The packet contains file transfer information
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes.Exchange">
            <summary>
            The packet is part of a key exchange
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex">
             <summary>
             Performs an Asymmetric Key Exchange using the Deferred Trust Model KEX.
             <para>This work is preliminary, and subject to modification when the scheme is deployed. (eta is fall of 2015)</para>
             </summary>
             
             <example>
             <description>Creating a DTM Server:</description>
             <code>
             // dtm server exchange parameters X11RNS1R2
             DtmParameters srvDtmParams = DtmParamSets.FromName(DtmParamSets.DtmParamNames.X42RNS1R1);       // preset contains all the settings required for the exchange
            
             // dtm server id
             DtmClient srvDmtId = new DtmClient(
                 new byte[] { 3, 3, 3, 3 },      // the clients public id, (should be at least 32 bytes, can be used as a contact lookup and initial auth)
                 new byte[] { 4, 4, 4, 4 });     // the clients secret id, (secret id can be anything.. a serialized structure, signed data, hash, etc)
            
             // create the server
             _dtmServer = new DtmKex(srvDtmParams, srvDmtId);
             _dtmServer.IdentityReceived += new DtmKex.IdentityReceivedDelegate(OnIdentityReceived);         // returns the client public and secret id fields, used to authenticate a host
             _dtmServer.PacketReceived += new DtmKex.PacketReceivedDelegate(OnPacketReceived);               // notify that a packet has been received (optional)
             _dtmServer.SessionEstablished += new DtmKex.SessionEstablishedDelegate(OnSessionEstablished);   // notify when the vpn state is up
             _dtmServer.PacketSent += new DtmKex.PacketReceivedDelegate(OnPacketSent);                       // notify when a packet has been sent to the remote host (optional)
             _dtmServer.DataReceived += new DtmKex.DataTransferredDelegate(OnDataReceived);                  // returns the decrypted message data
             _dtmServer.FileReceived += new DtmKex.FileTransferredDelegate(OnFileReceived);                  // notify that a file transfer has completed
             _dtmServer.FileRequest += new DtmKex.FileRequestDelegate(OnFileRequest);                        // notify that the remote host wants to send a file, can cancel or provide a path for the new file
             _dtmServer.SessionError += new DtmKex.SessionErrorDelegate(OnSessionError);                     // notify of any error conditions; includes the exception, and a severity code contained in the option flag
            
             // server starts listening
             _dtmServer.Listen(IPAddress.Any, Port);
             </code>
             </example>
             
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM DtmParameters class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmClient structure</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmIdentity structure</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmPacket structure</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures DtmSession</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments DtmErrorEventArgs class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmEstablishedEventArgs">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments DtmEstablishedEventArgs class</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments DtmPacketEventArgs class</seealso>
             <seealso cref="!:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmErrorStates">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages DtmErrorStates enumeration</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages DtmPacketFlag enumeration</seealso>
             <seealso cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes">VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages DtmPacketTypes enumeration</seealso>
             
             <remarks>
             <description><h4>Overview:</h4></description>
             <para>DTM is designed for maximum flexibility, for this reason authentication between hosts is 'deffered' to another layer of software, whereby the users actions and settings can at 
             least in part determine the level of security, authentication, repudiation, and how an exchange is transacted.</para>
             
             <para>The protocol is directed at end to end data exchanges, (such as voice or video conferencing between nodes), and a means by which nodes may authenticate and execute a secure
             communications channel without the need for signing, certificates, or third party authenticators. 
             This is intended as a semi-closed system of authentication, whereby a node may choose to engage a session with an unknown actor, 
             with both nodes determining a local trust value (ex. adding a contact to a list during a call, banning a host, etc.). 
             Expansions of the system beyond a closed or semi-closed framework are considered as a layer above this implementation; i.e. a shared trust model based on a signature scheme, 
             or the movement of contacts within a trust model framework.</para>
             
             <para>Tasks such as host Authentication and Repudiation are forwarded to an upper layer of software, which in turn can determine an appropriate action. 
             For example; the identity exchange notifies the client via events; the <see cref="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.IdentityReceived"/> forwards an id field, and the symmetric, and asymmetric cipher parameters. 
             If the parameter sets do not meet a minimum security context, or the conversation is otherwise refused, that layer of software can terminate the session 
             simply by setting the Cancel flag to true in the event arguments, and a packet can be sent back to the requesting host notifying them of the cause of failure. 
             This could in turn, trigger another exchange attempt with stronger parameters.</para>
             
             <para>This model proposes using two post-quantum secure ciphers; the first cipher should be considered as the Authenticator, or <c>Auth-Stage</c>. 
             The authenticating asymmetric cipher is used to encrypt the first (symmetric) session key. This session key is in turn used to encrypt the asymmetric parameters and the Public key
             of the second <c>Primary-Stage</c> asymmetric cipher. The primary asymmetric cipher encrypts a second symmetric key; which is used as the primary session key in the VPN.</para>
             <para>Both channels (Send and Receive) are encrypted with seperate keys; data Bob sends to Alice is encrypted with the symmetric key that Bob generated and exchanged, and data Bob receives
             from Alice is decrypted with the symmetric key that Alice generated. In this way each actor defines the security context for the channel that they transmit data on.</para>
             
             <description><h4>Exchange States:</h4></description>
             <list type="table">
                 <listheader>
                     <term>Stage</term>
                     <term>Description</term>
                 </listheader>
                 <item>
                     <description>Connect</description>
                     <description>The server and client exchange a DtmIdentity structure; containing just the public id field.</description>
                 </item>
                 <item>
                     <description>Init</description>
                     <description>The server and client exchange a full DtmIdentity structure; containing the public id field and the PKE Parameters Id, used to create the <c>Auth-Stage</c> Asymmetric keys.</description>
                 </item>
                 <item>
                     <description>PreAuth</description>
                     <description>The server and client exchange their <c>Auth-Stage</c> Asymmetric Public Keys.</description>
                 </item>
                 <item>
                     <description>AuthEx</description>
                     <description>The server and client exchange their <c>Auth-Stage</c> Symmetric KeysParams.</description>
                 </item>
                 <item>
                     <description>Auth</description>
                     <description>The server and client exchange their private identity fields, used to mutually authenticate.</description>
                 </item>
                 <item>
                     <description>Sync</description>
                     <description>The server and client exchange their <c>Primary-Stage</c> Asymmetric and Session Parameters.</description>
                 </item>
                 <item>
                     <description>PrimeEx</description>
                     <description>The server and client exchange their <c>Primary-Stage</c> Asymmetric Public Key.</description>
                 </item>
                 <item>
                     <description>Primary</description>
                     <description>The server and client exchange their <c>Primary-Stage</c> Symmetric KeyParams.</description>
                 </item>
                 <item>
                     <description>Establish</description>
                     <description>The server and client acknowledge their mutual trust; the VPN is UP.</description>
                 </item>
             </list>
             
             <description><h4>Structures:</h4></description>
             <list type="table">
                 <listheader>
                     <term>Structure</term>
                     <term>Description</term>
                 </listheader>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/></description>
                     <description>The primary packet header used in a DTM key exchange; used to classify and describe the message content.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/></description>
                     <description>Storage for the active identity, symmetric session, and asymmetric parameters.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmMessage"/></description>
                     <description>A header that encapsulates encrypted messages; it contains describe the payload and padding.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient"/></description>
                     <description>Used to store data that uniquely identifies the host.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters"/></description>
                     <description>Defines the working parameters used by the DTM Key Exchange using a DtmKex instance.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession"/></description>
                     <description>Contains a minimal description of the symmetric cipher.</description>
                 </item>
             </list>
             
             <description><h4>Enumerations:</h4></description>
             <list type="table">
                 <listheader>
                     <term>Enumeration</term>
                     <term>Description</term>
                 </listheader>
                 <item>
                     <description><see cref="!:DtmErrorStates"/> </description>
                     <description>This enum represents the error flags that can be applied to the DtmPacket Option flag.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmServiceFlags"/></description>
                     <description>Describes the state of the key exchange progress; used as a flag in a Request operation.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes"/></description>
                     <description>Contains the primary message types; used as the Message flag in a DtmPacket.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTrustStates"/></description>
                     <description>This enum represents the requested trust relationship (for future use).</description>
                 </item>
             </list>
             
             <description><h4>Events:</h4></description>
             <list type="table">
                 <listheader>
                     <term>Event</term>
                     <term>Description</term>
                 </listheader>
                 <item>
                     <description><see cref="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.PacketReceived"/></description>
                     <description>Event fires each time a valid packet has been received.</description>
                 </item>
                 <item>
                     <description><see cref="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.PacketSent"/></description>
                     <description>Event fires each time a valid packet has been sent.</description>
                 </item>
                 <item>
                     <description><see cref="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.IdentityReceived"/></description>
                     <description>Event fires when a packet containing identity data is received.</description>
                 </item>
                 <item>
                     <description><see cref="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SessionError"/></description>
                     <description>Event fires when an error has occured.</description>
                 </item>
                 <item>
                     <description><see cref="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SessionEstablished"/></description>
                     <description>Event fires when the vpn has been established.</description>
                 </item>
             </list>
             
             <description><h4>Arguments:</h4></description>
             <list type="table">
                 <listheader>
                     <term>Argument</term>
                     <term>Description</term>
                 </listheader>
                 <item>
                     <description><see cref="!:DtmErrorStates"/></description>
                     <description>Class contains the error state information.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmEstablishedEventArgs"/> </description>
                     <description>Class contains the final symmetric keys from a completed exchange.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs"/></description>
                     <description>Class contains the identity of a client.</description>
                 </item>
                 <item>
                     <description><see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs"/></description>
                     <description>Class contains the exchange state information.</description>
                 </item>
             </list>
             </remarks>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CHUNKSIZE">
            <summary>
            The default buffer size used in the message exchange
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.EXCHTIMEOUT">
            <summary>
            The number of milliseconds to wait on a blocking call, default 4 minutes
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.MAXRCVBUFFER">
            <summary>
            The maximum size of a single message
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.MAXSNDATTEMPT">
            <summary>
            Maximum number of times the instance will accept a retransmission request
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.DEFTIMEOUT">
            <summary>
            The default connection timeout interval
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient,System.Int32,System.Boolean)">
            <summary>
            Initialize this class
            </summary>
            
            <param name="Parameters">A populated <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters"/> class containing the session parameters</param>
            <param name="Host">A populated <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient"/> class containing the servers identity data</param>
            <param name="BufferCount">The number of send/receive buffers, default is 1024</param>
            <param name="DisposeEngines">if set to true (default), the primary symmetric ciphers are disposed when this class is disposed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.#ctor(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient,VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom,System.Int32,System.Boolean)">
            <summary>
            Initialize this class with a random generator
            </summary>
            
            <param name="Parameters">A populated <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmParameters"/> class containing the session parameters</param>
            <param name="Host">A populated <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmClient"/> class containing the servers identity data</param>
            <param name="Generator">The initialized <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Prng.IRandom"/> Prng instance</param>
            <param name="BufferCount">The number of send/receive buffers, default is 1024</param>
            <param name="DisposeEngines">if set to true (default), the primary symmetric ciphers are disposed when this class is disposed</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Finalize">
            <summary>
            Finalize objects
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Connect(System.String,System.Int32,System.Boolean)">
            <summary>
            Connect to a server and begin the key exchange
            </summary>
            
            <param name="HostName">The servers Host Nam</param>
            <param name="Port">The servers Port number</param>
            <param name="Async">Connect on a non-blocking TCP channel</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">Thrown if a socket error is returned</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Connect(System.Net.IPAddress,System.Int32,System.Boolean)">
            <summary>
            Connect to a server and begin the key exchange
            </summary>
            
            <param name="Address">The servers IP Address</param>
            <param name="Port">The servers Port number</param>
            <param name="Async">Connect on a non-blocking TCP channel</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">Thrown if a socket error is returned</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.OnClientConnected(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Server has accepted the connection from the Client
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">Thrown if a processing or socket error is returned</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ClientExchange">
            <summary>
            Executes the client portion the key exchange
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Listen(System.String,System.Int32,System.Boolean)">
            <summary>
            Initialize the server and listen for incoming connections
            </summary>
            
            <param name="HostName">The servers Host Name</param>
            <param name="Port">The servers Port number</param>
            <param name="Async">Listen on a non-blocking TCP connection</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">Thrown if a socket error is returned</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Listen(System.Net.IPAddress,System.Int32,System.Boolean)">
            <summary>
            Initialize the server and listen for incoming connections
            </summary>
            
            <param name="Address">The servers IP Address</param>
            <param name="Port">The servers Port number</param>
            <param name="Async">Listen on a non-blocking TCP connection</param>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">Thrown if a socket error is returned</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.OnServerConnected(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            Client has made a connection to the server
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoNetworkingException">Thrown if a processing or socket error is returned</exception>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ServerExchange">
            <summary>
            Executes the server portion of the key exchange
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.OnDataReceived(VTDev.Libraries.CEXEngine.Networking.DataReceivedEventArgs)">
            <summary>
            Entry point for post-exchange data received from the Tcp Socket
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessAndPush(VTDev.Libraries.CEXEngine.Networking.PacketBuffer,System.IO.MemoryStream)">
            <summary>
            Processes and queues incoming packets
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Disconnect">
            <summary>
            Disconnect from the remote host and teardown the connection
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Process(System.IO.MemoryStream)">
            <summary>
            Process a message.
            <para>Use this method to process <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/> data sent to the server</para>
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Resend(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket)">
            <summary>
            Resend a packet to a host
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Throttle(System.IO.MemoryStream)">
            <summary>
            Sends a packet with increasing wait times. 
            <para>After 4 attempts fires a SessionError with optional cancellation token.</para>
            </summary>
            
            <param name="PacketStream">The packet to send</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Transmit(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes,System.Int16,System.Int64,System.IO.MemoryStream,System.Boolean)">
            <summary>
            Frame and Transmit the packet to the remote client
            </summary>
            
            <param name="PacketType">The packet class</param>
            <param name="PacketFlag">The packet message type flag</param>
            <param name="OptionFlag">The option flag</param>
            <param name="Payload">The packet payload flag</param>
            <param name="Blocking">Blocking or Async transmit</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SendReceive(System.IO.MemoryStream,System.Int32)">
            <summary>
            Blocking transceiver; sends a packet and waits for a response.
            <para>For use with time sensitive data, that requires fast synchronous processing.
            Sent and received packets are not queued or buffered.</para>
            </summary>
            
            <param name="DataStream">The payload data to send to the remote host</param>
            <param name="TimeOut">The number of milliseconds to wait before timing out (default is infinite)</param>
            
            <returns>The return streams decrypted payload data, or an empty stream on failure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.StartPulse">
            <summary>
            Begins the keep alive timer
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.StopPulse">
            <summary>
            Stops the keep alive timer
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.OnTimerPulse(System.Object,System.Timers.ElapsedEventArgs)">
            <summary>
            The keep alive timer event handler
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Reconnect">
            <summary>
            Attempt to reconnect to the remote host
            </summary>
            
            <returns>Returns true if connected</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreateResync">
            <summary>
            Creates a Resync packet.
            <para>The packet contains the encrypted identity field, 
            used to test for a successful resyning of the crypto stream.</para>
            </summary>
            
            <returns>A resync packet payload</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessResync(System.IO.MemoryStream)">
            <summary>
            Used to process a resync response.
            <para>The remote host has sent the number of bytes encrypted as the OptionFlag in the DtmPacket.
            The resynchronization of the crypto stream involves first encrypting an equal sized array, 
            and then testing for validity by decrypting the payload and comparing it to the stored client id.
            If the Resync fails, the client Disconnects, notifies the application, and performs a teardown of the VPN.</para>
            </summary>
            
            <param name="PacketStream">A resync packet</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.BlockingReceive">
            <summary>
            Used to read a blocking message response
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ReceiveMessage(System.IO.Stream)">
            <summary>
            Used Post-Exchange to decrypt bytes received from the client
            </summary>
            
            <param name="PacketStream">The stream containing the ciphertext</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Send(System.IO.Stream)">
            <summary>
            Used Post-Exchange to encrypt data before it is sent to the client
            </summary>
            
            <param name="PacketStream">The stream containing the data to encrypt</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ReceiveFile(System.IO.Stream)">
            <summary>
            Used Post-Exchange to setup a file transfer from the remote host
            </summary>
            
            <param name="PacketStream">The stream containing the file transfer request</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.OnFileReceived(System.Object,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs)">
            <summary>
            Fires when a file received operation has completed
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.OnFileReceivedProgress(System.Object,System.ComponentModel.ProgressChangedEventArgs)">
            <summary>
            Fires when a file receive operation completes
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SendFile(System.String)">
            <summary>
            Used to initialize the file transfer sequence.
            <para>Sends a file request with the file id, name, and size.</para>
            </summary>
            
            <param name="FilePath">The full path to the file to send</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CloseTransfer(System.Int64)">
            <summary>
            Removes a file transfer instance from the queue
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.OnFileSent(System.Object,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs)">
            <summary>
            Fires when a file send operation completes
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.OnFileSentProgress(System.Object,System.ComponentModel.ProgressChangedEventArgs)">
            <summary>
            File send progress event handler
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreateConnect(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTrustStates)">
            <summary>
            Send the servers partial public identity structure <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/>.
            <para>The packet header; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/>, contains the message type, payload length, sequence number, and exchange state.
            The payload is the servers public identity field in a default DtmIdentity structure.</para>
            </summary>
            
            <param name="Trust">The level of trust expected (for future use)</param>
            
            <returns>A raw packet containing the packet header, and the servers public identity structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessConnect(System.IO.MemoryStream)">
            <summary>
            Processes the clients public identity field for preliminary authentication.
            <para>Process the clients partial Auth-Stage public identity structure; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/></para>
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
            
            <remarks>
            Fires the <see cref="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.IdentityReceived"/> event; returning the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs"/> object containing the clients public id structure.
            <para>The session can be aborted by setting the DtmIdentityEventArgs Cancel flag to true.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreateInit">
            <summary>
            Send the servers full public identity structure <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/>; contains the public id field, the asymmetric parameters, and the symmetric session parameters.
            <para>The packet header; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/>, contains the message type, payload length, sequence number, and exchange state.
            The payload is the servers preliminary identity structure (DtmIdentity), containing the public id field, the session key parameters <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession"/>, and the
            Auth-Stage PKE parameters OId.</para>
            </summary>
            
            <returns>A raw packet containing the packet header, and the servers public identity structure</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessInit(System.IO.MemoryStream)">
            <summary>
            Processes the clients public identity and clients Auth-Stage PKE parameter set Id; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters"/>.
            <para>Process the clients Auth-Stage public identity structure; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/></para>
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
            
            <remarks>Fires the <see cref="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.IdentityReceived"/> event; returning the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs"/> object containing the clients public id structure.
            <para>The session can be aborted by setting the DtmIdentityEventArgs Cancel flag to true.</para>
            </remarks>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreatePreAuth">
            <summary>
            Send the servers Auth-Stage Asymmetric Public key; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey"/>, built using the PKE params id from the servers identity structure.
            <para>The packet header; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/>, contains the message type, payload length, sequence number, and exchange state.
            The payload is the servers Auth-Stage asymmetric Public Key.</para>
            </summary>
            
            <returns>A raw packet containing the packet header, and the servers Auth-Stage asymmetric Public Key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessPreAuth(System.IO.MemoryStream)">
            <summary>
            Processes the clients Auth-Stage <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">AsymmetricKey</see> Public key.
            <para>Stores the clients Auth-Stage Asymmetric Public Key.</para>
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreateAuthEx">
            <summary>
            Send the servers Auth-Stage Symmetric <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/>, encrypted with the clients Public Key.
            <para>The packet header; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/>, contains the message type, payload length, sequence number, and exchange state.
            The payload is the servers Auth-Stage Symmetric KeyParams, encrypted with the clients Asymmetric Public Key.</para>
            </summary>
            
            <returns>A raw packet containing the packet header, and the servers Auth-Stage Symmetric Key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessAuthEx(System.IO.MemoryStream)">
            <summary>
            Processes and stores the clients Auth-Stage Symmetric <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/>, 
            decrypted with the servers <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">Asymmetric KeyPair</see>.
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreateAuth">
            <summary>
            Sends the servers private identity; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/>, encrypted with the servers Symmetric Key.
            </summary>
            
            <returns>A raw packet containing the packet header, and the servers private identity</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessAuth(System.IO.MemoryStream)">
            <summary>
            Process the clients private identity.
            <para>Decrypts and stores the clients private identity using the clients Auth-Stage Symmetric Key.</para>
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreateSync">
            <summary>
            Send the servers Primary-Stage session parameters in a <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/> structure.
            <para>The packet header; <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmPacket"/>, contains the message type, payload length, sequence number, and exchange state.
            The payload is the servers identity structure (DtmIdentity), containing the secret id field, the session key parameters <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession"/>, and the
            primary-stage PKE parameters Id.</para>
            </summary>
            
            <returns>A raw packet containing the packet header, and the servers private identity</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessSync(System.IO.MemoryStream)">
            <summary>
            Process the clients identity structure <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmIdentity"/>.
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreatePrimeEx">
            <summary>
            Sends the servers Primary-Stage <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">AsymmetricKey</see> Public key.
            </summary>
            
            <returns>A Stream containing the raw packet data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessPrimeEx(System.IO.MemoryStream)">
            <summary>
            Processes the clients Primary-Stage <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey">AsymmetricKey</see> Public key.
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreatePrimary">
            <summary>
            Sends the servers primary-stage Symmetric <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/>.
            </summary>
            
            <returns>A Stream containing the raw packet data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessPrimary(System.IO.MemoryStream)">
            <summary>
            Processes and stores the clients primary-stage Symmetric <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams"/>, 
            decrypted with the servers <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair">Asymmetric KeyPair</see>.
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreateEstablish">
            <summary>
            Notify that the VPN is established
            </summary>
            
            <returns>A Stream containing the raw packet data</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProcessEstablish(System.IO.MemoryStream)">
            <summary>
            The VPN is two-way established.
            <para>Note that SessionEstablished event is used, it is expected that processing will continue externally.
            In this case the post-exchange symmetric cipher instances are not initialized internally, 
            and the Send and Receive methods will throw an error, i.e. you can use either the event or the internal processors.</para>
            </summary>
            
            <param name="PacketStream">A Stream containing the raw packet data</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.AsymmetricDecrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKeyPair,System.Byte[])">
            <summary>
            Decrypt an array with an asymmetric cipher
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.AsymmetricEncrypt(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricKey,System.Byte[])">
            <summary>
            Encrypt an array with an asymmetric cipher
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GenerateAsymmetricKeyPair(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters)">
            <summary>
            Generat an asymmetric key-pair
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GenerateSymmetricKey(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession)">
            <summary>
            Generate a symmetric key
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SymmetricInit(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession,VTDev.Libraries.CEXEngine.Crypto.Common.KeyParams)">
            <summary>
            Initialize the symmetric cipher
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SymmetricTransform(VTDev.Libraries.CEXEngine.Crypto.Cipher.Symmetric.Block.Mode.ICipherMode,System.Byte[])">
            <summary>
            Transform an array with the symmetric cipher
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.CreateRequest(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmPacketTypes,System.Int16,System.Int32)">
            <summary>
            Creates a serialized request packet (DtmPacket)
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GetAsymmetricCipher(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters)">
            <summary>
            Get the asymmetric cipher instance
            </summary>
            
            <param name="Parameters">The cipher parameters</param>
            
            <returns>The cipher instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GetAsymmetricGenerator(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters)">
            <summary>
            Get the asymmetric generator instance
            </summary>
            
            <param name="Parameters">The cipher parameters</param>
            
            <returns>The generator instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GetAsymmetricParams(System.Byte[])">
            <summary>
            Get the asymmetric parameters from a byte array
            </summary>
            
            <param name="Data">The encoded parameters</param>
            
            <returns>The asymmetric parameters</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GetAsymmetricPublicKey(System.IO.Stream,VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.Interfaces.IAsymmetricParameters)">
            <summary>
            Get the asymmetric public key from a stream
            </summary>
            
            <param name="KeyStream">The encoded public key</param>
            <param name="Parameters">The cipher parameters</param>
            
            <returns>The public key</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GetDigest(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Digests)">
            <summary>
            Get the digest instance
            </summary>
            
            <param name="Digest">The Digests enumeration member</param>
            
            <returns>The hash digest instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GetPrng(VTDev.Libraries.CEXEngine.Crypto.Enumeration.Prngs)">
            <summary>
            Get the Prng instance
            </summary>
            
            <param name="Prng">The Prngs enumeration member</param>
            
            <returns>The Prng instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.GetSymmetricCipher(VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Structures.DtmSession)">
            <summary>
            Get the symmetric cipher instance
            </summary>
            
            <param name="Session">The session parameters</param>
            
            <returns>The initialized cipher instance</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SendWait(System.Int32,System.Int32)">
            <summary>
            Waits a maximum (random) number of milliseconds before resuming thread
            </summary>
            
            <param name="WaitMaxMs">The maximum wait time in milliseconds</param>
            <param name="WaitMinMs">The minimum wait time in milliseconds</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.TearDown">
            <summary>
            Tear down the connection; destroys all structures provided by this class
            </summary>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.UnwrapMessage(System.Byte[])">
            <summary>
            Removes random padding from a message array
            </summary>
            
            <param name="Data">The message aray</param>
            
            <returns>The unwrapped message</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Wait(System.Int32)">
            <summary>
            Waits the number specified of milliseconds before resuming thread
            </summary>
            
            <param name="WaitMs">The wait time in milliseconds; <c>0</c> = forever</param>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.WrapMessage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Wrap a message with random bytes
            </summary>
            
            <param name="Data">The data to wrap</param>
            <param name="MaxAppend">The (random) maximum number of bytes to append</param>
            <param name="MaxPrepend">The (random) maximum number of bytes to prepend</param>
            
            <returns>The wrapped array</returns>
        </member>
        <member name="M:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Dispose">
            <summary>
            Dispose of this class
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.DataReceived">
            <summary>
            The Data Received event; fires each time data has been received through the post-exchange encrypted channel
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.FileReceived">
            <summary>
            The File Received event; fires when the file transfer operation has completed
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.FileSent">
            <summary>
            The File Received event; fires when the file transfer operation has completed
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.FileRequest">
            <summary>
            The File Request event; fires when the host receives notification of a pending file transfer.
            <para>The event is received with the file name in the FilePath field, and must return the full path to the local destination, including file name.
            To cancel the file transmission, set the <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmFileRequestEventArgs"/> to <c>true</c></para>
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.IdentityReceived">
            <summary>
            The Identity Received event; fires when a packet containing identity data is received
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.PacketReceived">
            <summary>
            The Packet Received event; fires each time a valid packet has been received
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.PacketSent">
            <summary>
            The Packet Sent event; fires each time a valid packet has been sent
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProgressPercent">
            <summary>
            Progress Percent Event; returns bytes processed as an integer percentage
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SessionError">
            <summary>
            The Session Error event; fires when an error has occured
            </summary>
        </member>
        <member name="E:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SessionEstablished">
            <summary>
            The Session Established; fires when the vpn has been established
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.AutoReconnect">
            <summary>
            Attempts to reconnect to a host if the connection is dropped through an error or timeout
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ConnectionTimeOut">
            <summary>
            The number of contiguous missed keepalives (at one second intervals), before a connection is considered dropped.
            <para>This value is used by the AutoReconnect feature as the threshold before a reconnect operation is initiated.
            Adjust this interval based on the target devices reliability, processing power, and load;
            ex. a phone should wait 30 seconds or more, a computer 10 seconds or less.
            The default value is 10 seconds.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.IsConnected">
            <summary>
            Get: The connection state
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.IsEstablished">
            <summary>
            Get: The VPN is Established
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.FileBufferSize">
            <summary>
            The size of the file Tcp and buffer queue elements.
            <para>Buffer size <c>must match</c> remote client, otherwise an excess of partial packets could break the queing mechanism.</para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.MaxResend">
            <summary>
            Get/Set: The maximum number of times a packet can be resent; default is <c>1024</c>
            </summary>
            
            <exception cref="T:VTDev.Libraries.CEXEngine.CryptoException.CryptoKeyExchangeException">Thrown if the value is less than <c>0</c></exception>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.MessageBufferSize">
            <summary>
            Get/Set: The size of the message Tcp and buffer queue elements.
            <para>Buffer size <c>must match</c> remote client, otherwise an excess of partial packets could break the queing mechanism.
            The size of the buffer should align with the implementation type, i.e. be as close to the expected output segment size as possible,
            while large enough to process every stream segment; ex. if the average output of a video processor frame is  6 KB, set the packet size to 8 KB. 
            </para>
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ResendThreshold">
            <summary>
            Get/Set: The number of queued message packets before a resend is triggered
            </summary>
        </member>
        <member name="P:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.Socket">
            <summary>
            Get: Returns the TcpSocket class instance
            </summary>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.DataTransferredDelegate">
            <summary>
            The Packet Transferred delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmDataReceivedEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.FileTransferredDelegate">
            <summary>
            The File Transferred delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.FileRequestDelegate">
            <summary>
            The File Request delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmFileRequestEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.IdentityReceivedDelegate">
            <summary>
            The Identity Received delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmIdentityEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.PacketReceivedDelegate">
            <summary>
            The Packet Received delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.PacketSentDelegate">
            <summary>
            The Packet Sent delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmPacketEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.ProgressDelegate">
            <summary>
            Progress indicator delegate
            </summary>
            
            <param name="sender">Event owner object</param>
            <param name="e">Progress event arguments containing percentage and bytes processed as the UserState param</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SessionErrorDelegate">
            <summary>
            The Session Error delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmErrorEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.DtmKex.SessionEstablishedDelegate">
            <summary>
            The Session Established delegate
            </summary>
            <param name="owner">The owner object</param>
            <param name="args">A <see cref="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Arguments.DtmEstablishedEventArgs"/> class</param>
        </member>
        <member name="T:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTransferFlags">
            <summary>
            The flag indicating the state of a transfer operation
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTransferFlags.Request">
            <summary>
            Packet contains a transfer request
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTransferFlags.Refused">
            <summary>
            The transfer request was refused
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTransferFlags.DataChunk">
            <summary>
            Packet contains transmission data
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTransferFlags.Received">
            <summary>
            The transfer receive operation has completed
            </summary>
        </member>
        <member name="F:VTDev.Libraries.CEXEngine.Crypto.Cipher.Asymmetric.KEX.DTM.Messages.DtmTransferFlags.Sent">
            <summary>
            The transfer send operation has completed
            </summary>
        </member>
    </members>
</doc>
